commit e3fb2381f20142b1a3e07234bc05a9ef68c1971a
merge: 3982abb4bd2bddd5b332fa573cfdbf79df5d68dc ade61868fbbd0134a610b8fde1c9a1b6da2d515b
author: elen-volodina
date: 2025-11-11T17:22:50+03:00
revision: 17983433

    DTCC-2622 revert coverage redesign
    
    REVIEW: 10638783

--- a/src/internal/goexperiment/flags.go	(3982abb4bd2bddd5b332fa573cfdbf79df5d68dc)
+++ b/src/internal/goexperiment/flags.go	(e3fb2381f20142b1a3e07234bc05a9ef68c1971a)
@@ -83,6 +83,10 @@ type Flags struct {
 	// by default.
 	HeapMinimum512KiB bool
 
+	// CoverageRedesign enables the new compiler-based code coverage
+	// tooling.
+	CoverageRedesign bool
+
 	// Arenas causes the "arena" standard library package to be visible
 	// to the outside world.
 	Arenas bool
--- a/src/testing/cover.go	(3982abb4bd2bddd5b332fa573cfdbf79df5d68dc)
+++ b/src/testing/cover.go	(e3fb2381f20142b1a3e07234bc05a9ef68c1971a)
@@ -6,6 +6,13 @@
 
 package testing
 
+import (
+	"fmt"
+	"internal/goexperiment"
+	"os"
+	"sync/atomic"
+)
+
 // CoverBlock records the coverage data for a single basic block.
 // The fields are 1-indexed, as in an editor: The opening line of
 // the file is number 1, for example. Columns are measured
@@ -20,6 +27,8 @@ type CoverBlock struct {
 	Stmts uint16 // Number of statements included in this block.
 }
 
+var cover Cover
+
 // Cover records information about test coverage checking.
 // NOTE: This struct is internal to the testing infrastructure and may change.
 // It is not covered (yet) by the Go 1 compatibility guidelines.
@@ -30,8 +39,86 @@ type Cover struct {
 	CoveredPackages string
 }
 
+// Coverage reports the current code coverage as a fraction in the range [0, 1].
+// If coverage is not enabled, Coverage returns 0.
+//
+// When running a large set of sequential test cases, checking Coverage after each one
+// can be useful for identifying which test cases exercise new code paths.
+// It is not a replacement for the reports generated by 'go test -cover' and
+// 'go tool cover'.
+func Coverage() float64 {
+	if goexperiment.CoverageRedesign {
+		return coverage2()
+	}
+	var n, d int64
+	for _, counters := range cover.Counters {
+		for i := range counters {
+			if atomic.LoadUint32(&counters[i]) > 0 {
+				n++
+			}
+			d++
+		}
+	}
+	if d == 0 {
+		return 0
+	}
+	return float64(n) / float64(d)
+}
+
 // RegisterCover records the coverage data accumulators for the tests.
 // NOTE: This function is internal to the testing infrastructure and may change.
 // It is not covered (yet) by the Go 1 compatibility guidelines.
 func RegisterCover(c Cover) {
+	cover = c
+}
+
+// mustBeNil checks the error and, if present, reports it and exits.
+func mustBeNil(err error) {
+	if err != nil {
+		fmt.Fprintf(os.Stderr, "testing: %s\n", err)
+		os.Exit(2)
+	}
+}
+
+// coverReport reports the coverage percentage and writes a coverage profile if requested.
+func coverReport() {
+	if goexperiment.CoverageRedesign {
+		coverReport2()
+		return
+	}
+	var f *os.File
+	var err error
+	if *coverProfile != "" {
+		f, err = os.Create(toOutputDir(*coverProfile))
+		mustBeNil(err)
+		fmt.Fprintf(f, "mode: %s\n", cover.Mode)
+		defer func() { mustBeNil(f.Close()) }()
+	}
+
+	var active, total int64
+	var count uint32
+	for name, counts := range cover.Counters {
+		blocks := cover.Blocks[name]
+		for i := range counts {
+			stmts := int64(blocks[i].Stmts)
+			total += stmts
+			count = atomic.LoadUint32(&counts[i]) // For -mode=atomic.
+			if count > 0 {
+				active += stmts
+			}
+			if f != nil {
+				_, err := fmt.Fprintf(f, "%s:%d.%d,%d.%d %d %d\n", name,
+					blocks[i].Line0, blocks[i].Col0,
+					blocks[i].Line1, blocks[i].Col1,
+					stmts,
+					count)
+				mustBeNil(err)
+			}
+		}
+	}
+	if total == 0 {
+		fmt.Println("coverage: [no statements]")
+		return
+	}
+	fmt.Printf("coverage: %.1f%% of statements%s\n", 100*float64(active)/float64(total), cover.CoveredPackages)
 }
--- a/src/testing/newcover.go	(3982abb4bd2bddd5b332fa573cfdbf79df5d68dc)
+++ b/src/testing/newcover.go	(e3fb2381f20142b1a3e07234bc05a9ef68c1971a)
@@ -8,52 +8,49 @@ package testing
 
 import (
 	"fmt"
+	"internal/goexperiment"
 	"os"
 	_ "unsafe" // for linkname
 )
 
-// cover variable stores the current coverage mode and a
+// cover2 variable stores the current coverage mode and a
 // tear-down function to be called at the end of the testing run.
-var cover struct {
+var cover2 struct {
 	mode        string
 	tearDown    func(coverprofile string, gocoverdir string) (string, error)
 	snapshotcov func() float64
 }
 
-// registerCover is invoked during "go test -cover" runs.
+// registerCover2 is invoked during "go test -cover" runs.
 // It is used to record a 'tear down' function
 // (to be called when the test is complete) and the coverage mode.
-func registerCover(mode string, tearDown func(coverprofile string, gocoverdir string) (string, error), snapcov func() float64) {
+func registerCover2(mode string, tearDown func(coverprofile string, gocoverdir string) (string, error), snapcov func() float64) {
 	if mode == "" {
 		return
 	}
-	cover.mode = mode
-	cover.tearDown = tearDown
-	cover.snapshotcov = snapcov
+	cover2.mode = mode
+	cover2.tearDown = tearDown
+	cover2.snapshotcov = snapcov
 }
 
-// coverReport reports the coverage percentage and
-// writes a coverage profile if requested.
-// This invokes a callback in _testmain.go that will
+// coverReport2 invokes a callback in _testmain.go that will
 // emit coverage data at the point where test execution is complete,
 // for "go test -cover" runs.
-func coverReport() {
-	if errmsg, err := cover.tearDown(*coverProfile, *gocoverdir); err != nil {
+func coverReport2() {
+	if !goexperiment.CoverageRedesign {
+		panic("unexpected")
+	}
+	if errmsg, err := cover2.tearDown(*coverProfile, *gocoverdir); err != nil {
 		fmt.Fprintf(os.Stderr, "%s: %v\n", errmsg, err)
 		os.Exit(2)
 	}
 }
 
-// Coverage reports the current code coverage as a fraction in the range [0, 1].
-// If coverage is not enabled, Coverage returns 0.
-//
-// When running a large set of sequential test cases, checking Coverage after each one
-// can be useful for identifying which test cases exercise new code paths.
-// It is not a replacement for the reports generated by 'go test -cover' and
-// 'go tool cover'.
-func Coverage() float64 {
-	if cover.mode == "" {
+// coverage2 returns a rough "coverage percentage so far"
+// number to support the testing.Coverage() function.
+func coverage2() float64 {
+	if cover2.mode == "" {
 		return 0.0
 	}
-	return cover.snapshotcov()
+	return cover2.snapshotcov()
 }
--- a/src/testing/testing.go	(3982abb4bd2bddd5b332fa573cfdbf79df5d68dc)
+++ b/src/testing/testing.go	(e3fb2381f20142b1a3e07234bc05a9ef68c1971a)
@@ -404,6 +404,7 @@ import (
 	"errors"
 	"flag"
 	"fmt"
+	"internal/goexperiment"
 	"internal/race"
 	"io"
 	"math/rand"
@@ -708,7 +709,10 @@ func Testing() bool {
 // values are "set", "count", or "atomic". The return value will be
 // empty if test coverage is not enabled.
 func CoverMode() string {
-	return cover.mode
+	if goexperiment.CoverageRedesign {
+		return cover2.mode
+	}
+	return cover.Mode
 }
 
 // Verbose reports whether the -test.v flag is set.
@@ -2211,7 +2215,7 @@ type testDeps interface {
 // It is not meant to be called directly and is not subject to the Go 1 compatibility document.
 // It may change signature from release to release.
 func MainStart(deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, fuzzTargets []InternalFuzzTarget, examples []InternalExample) *M {
-	registerCover(deps.InitRuntimeCoverage())
+	registerCover2(deps.InitRuntimeCoverage())
 	Init()
 	return &M{
 		deps:        deps,
