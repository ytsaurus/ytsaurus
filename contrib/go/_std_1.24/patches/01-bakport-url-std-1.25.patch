# This patch is just backport url.go file from std 1.25 version
--- a/src/net/url/url.go	(index)
+++ b/src/net/url/url.go	(working tree)
@@ -3,18 +3,19 @@
 // license that can be found in the LICENSE file.
 
 // Package url parses URLs and implements query escaping.
-package url
-
+//
 // See RFC 3986. This package generally follows RFC 3986, except where
-// it deviates for compatibility reasons. When sending changes, first
-// search old issues for history on decisions. Unit tests should also
-// contain references to issue numbers with details.
+// it deviates for compatibility reasons.
+// RFC 6874 followed for IPv6 zone literals.
+package url
+
+// When sending changes, first  search old issues for history on decisions.
+// Unit tests should also contain references to issue numbers with details.
 
 import (
 	"errors"
 	"fmt"
 	"maps"
-	"net/netip"
 	"path"
 	"slices"
 	"strconv"
@@ -68,8 +69,9 @@ func unhex(c byte) byte {
 		return c - 'a' + 10
 	case 'A' <= c && c <= 'F':
 		return c - 'A' + 10
+	default:
+		panic("invalid hex character")
 	}
-	return 0
 }
 
 type encoding int
@@ -624,61 +626,40 @@ func parseAuthority(authority string) (user *Userinfo, host string, err error) {
 // parseHost parses host as an authority without user
 // information. That is, as host[:port].
 func parseHost(host string) (string, error) {
-	if openBracketIdx := strings.LastIndex(host, "["); openBracketIdx != -1 {
+	if strings.HasPrefix(host, "[") {
 		// Parse an IP-Literal in RFC 3986 and RFC 6874.
 		// E.g., "[fe80::1]", "[fe80::1%25en0]", "[fe80::1]:80".
-		closeBracketIdx := strings.LastIndex(host, "]")
-		if closeBracketIdx < 0 {
+		i := strings.LastIndex(host, "]")
+		if i < 0 {
 			return "", errors.New("missing ']' in host")
 		}
-
-		colonPort := host[closeBracketIdx+1:]
+		colonPort := host[i+1:]
 		if !validOptionalPort(colonPort) {
 			return "", fmt.Errorf("invalid port %q after host", colonPort)
 		}
-		unescapedColonPort, err := unescape(colonPort, encodeHost)
-		if err != nil {
-			return "", err
-		}
 
-		hostname := host[openBracketIdx+1 : closeBracketIdx]
-		var unescapedHostname string
 		// RFC 6874 defines that %25 (%-encoded percent) introduces
 		// the zone identifier, and the zone identifier can use basically
 		// any %-encoding it likes. That's different from the host, which
 		// can only %-encode non-ASCII bytes.
 		// We do impose some restrictions on the zone, to avoid stupidity
 		// like newlines.
-		zoneIdx := strings.Index(hostname, "%25")
-		if zoneIdx >= 0 {
-			hostPart, err := unescape(hostname[:zoneIdx], encodeHost)
+		zone := strings.Index(host[:i], "%25")
+		if zone >= 0 {
+			host1, err := unescape(host[:zone], encodeHost)
 			if err != nil {
 				return "", err
 			}
-			zonePart, err := unescape(hostname[zoneIdx:], encodeZone)
+			host2, err := unescape(host[zone:i], encodeZone)
 			if err != nil {
 				return "", err
 			}
-			unescapedHostname = hostPart + zonePart
-		} else {
-			var err error
-			unescapedHostname, err = unescape(hostname, encodeHost)
+			host3, err := unescape(host[i:], encodeHost)
 			if err != nil {
 				return "", err
 			}
+			return host1 + host2 + host3, nil
 		}
-
-		// Per RFC 3986, only a host identified by a valid
-		// IPv6 address can be enclosed by square brackets.
-		// This excludes any IPv4 or IPv4-mapped addresses.
-		addr, err := netip.ParseAddr(unescapedHostname)
-		if err != nil {
-			return "", fmt.Errorf("invalid host: %w", err)
-		}
-		if addr.Is4() || addr.Is4In6() {
-			return "", errors.New("invalid IPv6 host")
-		}
-		return "[" + unescapedHostname + "]" + unescapedColonPort, nil
 	} else if i := strings.LastIndex(host, ":"); i != -1 {
 		colonPort := host[i:]
 		if !validOptionalPort(colonPort) {
@@ -1299,7 +1280,18 @@ func validUserinfo(s string) bool {
 		}
 		switch r {
 		case '-', '.', '_', ':', '~', '!', '$', '&', '\'',
-			'(', ')', '*', '+', ',', ';', '=', '%', '@':
+			'(', ')', '*', '+', ',', ';', '=', '%':
+			continue
+		case '@':
+			// `RFC 3986 section 3.2.1` does not allow '@' in userinfo.
+			// It is a delimiter between userinfo and host.
+			// However, URLs are diverse, and in some cases,
+			// the userinfo may contain an '@' character,
+			// for example, in "http://username:p@ssword@google.com",
+			// the string "username:p@ssword" should be treated as valid userinfo.
+			// Ref:
+			//   https://go.dev/issue/3439
+			//   https://go.dev/issue/22655
 			continue
 		default:
 			return false
