#!/usr/bin/env python

from yt.common import which, set_pdeathsig
try:
    from yt.logger import set_log_level_from_config
except:
    from yt.logger_config import LOG_LEVEL
    set_log_level_from_config = None
from yt.logger_config import LOG_PATTERN

import argparse
import fcntl
import logging
import subprocess
import time
import os
from logging.handlers import WatchedFileHandler

logger = logging.getLogger("Yt.local.watcher")

def configure_logging(log_path):
    if set_log_level_from_config is not None:
        set_log_level_from_config(logger)
    else:
        logger.setLevel(logging.__dict__[LOG_LEVEL.upper()])

    handler = WatchedFileHandler(filename=log_path, mode="a")
    handler.setFormatter(logging.Formatter(LOG_PATTERN))
    logger.addHandler(handler)

def main():
    parser = argparse.ArgumentParser(add_help=False, description="YT watcher")
    parser.add_argument("--disable-logrotate", action="store_true", default=False,
                        help="disable log rotation")
    parser.add_argument("--lock-file-path", required=True,
                        help="path of file which will be used to take a file lock")
    parser.add_argument("--logrotate-config-path", required=True, help="path with config for logrotate")
    parser.add_argument("--logrotate-state-file", required=True, help="path of logrotate state file")
    parser.add_argument("--logrotate-interval", required=True, type=int,
                        help="interval (seconds) before a next running of logrotate")
    parser.add_argument("--log-path", required=True, help="path for watcher's logs")
    parser.add_argument("--pdeathsig", type=int, help="deathsig")
    parser.add_argument("--setsid", action="store_true", help="call setsid() after start")
    parser.add_argument("--cgroup", action="append", help="cgroup path where process should be added")
    options = parser.parse_args()

    configure_logging(options.log_path)
    logger.info("YT watcher started. Logrotate config file: %s", options.logrotate_config_path)

    if options.pdeathsig is not None:
        set_pdeathsig(options.pdeathsig)

    if options.setsid:
        try:
            os.setsid()
        except OSError as e:
            logger.error(
                "os.setsid failed: errno = {}({}). pid = {}, pgid = {}"
                .format(e.errno, e.strerror, os.getpid(), os.getpgid(0)))

    if options.cgroup is not None:
        for cgroup_path in options.cgroup:
            with open(os.path.join(cgroup_path, "tasks"), "at") as handle:
                handle.write(str(os.getpid()))
                handle.write("\n")

    if options.lock_file_path:
        lock_file_descriptor = open(options.lock_file_path, "w+")
        try:
            fcntl.lockf(lock_file_descriptor, fcntl.LOCK_EX | fcntl.LOCK_NB)
        except IOError:
            logger.error("YT watcher failed. Cannot take a file lock")
            raise
        logger.info("Lock acquired")

    logrotate_enabled = not options.disable_logrotate
    if not which("logrotate"):
        logrotate_enabled = False
        logger.warning("Logrotate is disabled. Cannot find logrotate binary.")

    while True:
        if logrotate_enabled:
            logger.info("Calling logrotate process...")
            p = subprocess.Popen(["logrotate", options.logrotate_config_path, "--state", options.logrotate_state_file],
                                 stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
            stdout, stderr = p.communicate()
            if p.returncode:
                logger.error('logrotate process failed with exit code %d, '
                             'stderr: "%s", stdout: "%s"', p.returncode, stderr, stdout)
            else:
                logger.info("Successful")
            logger.info("Sleep %d seconds before next calling", options.logrotate_interval)

        time.sleep(options.logrotate_interval)

if __name__ == "__main__":
    main()
