package NYP.NClient.NApi.NProto;

// COMPAT(babenko): will be dropped after switching to pod agent.
import "yp_proto/yp/client/api/proto/cluster_api.proto";
import "yp_proto/yp/client/api/proto/pod_agent.proto";

import "yt/core/yson/proto/protobuf_interop.proto";
import "yt_proto/yt/core/ytree/proto/attributes.proto";
import "yt_proto/yt/core/misc/proto/error.proto";

option java_package = "ru.yandex.yp.client.api";
option java_outer_classname = "DataModel";

////////////////////////////////////////////////////////////////////////////////

enum EObjectType
{
    OT_NULL = -1
    [(NYT.NYson.NProto.enum_value_name) = "null"];

    OT_NODE = 0
    [(NYT.NYson.NProto.enum_value_name) = "node"];

    OT_POD = 1
    [(NYT.NYson.NProto.enum_value_name) = "pod"];

    OT_POD_SET = 2
    [(NYT.NYson.NProto.enum_value_name) = "pod_set"];

    OT_RESOURCE = 3
    [(NYT.NYson.NProto.enum_value_name) = "resource"];

    OT_NETWORK_PROJECT = 4
    [(NYT.NYson.NProto.enum_value_name) = "network_project"];

    OT_ENDPOINT = 5
    [(NYT.NYson.NProto.enum_value_name) = "endpoint"];

    OT_ENDPOINT_SET = 6
    [(NYT.NYson.NProto.enum_value_name) = "endpoint_set"];

    OT_NODE_SEGMENT = 7
    [(NYT.NYson.NProto.enum_value_name) = "node_segment"];

    OT_VIRTUAL_SERVICE = 8
    [(NYT.NYson.NProto.enum_value_name) = "virtual_service"];

    OT_USER = 9
    [(NYT.NYson.NProto.enum_value_name) = "user"];

    OT_GROUP = 10
    [(NYT.NYson.NProto.enum_value_name) = "group"];

    OT_INTERNET_ADDRESS = 11
    [(NYT.NYson.NProto.enum_value_name) = "internet_address"];

    OT_SCHEMA = 256
    [(NYT.NYson.NProto.enum_value_name) = "schema"];
}

enum EEventType
{
    ET_OBJECT_CREATED = 0
    [(NYT.NYson.NProto.enum_value_name) = "object_created"];

    ET_OBJECT_REMOVED = 1
    [(NYT.NYson.NProto.enum_value_name) = "object_removed"];

    ET_OBJECT_UPDATED = 2
    [(NYT.NYson.NProto.enum_value_name) = "object_updated"];
}

////////////////////////////////////////////////////////////////////////////////

enum EAccessControlAction
{
    ACA_ALLOW = 1
    [(NYT.NYson.NProto.enum_value_name) = "allow"];

    ACA_DENY = 2
    [(NYT.NYson.NProto.enum_value_name) = "deny"];
}

enum EAccessControlPermission
{
    ACP_READ = 1
    [(NYT.NYson.NProto.enum_value_name) = "read"];

    ACA_WRITE = 2
    [(NYT.NYson.NProto.enum_value_name) = "write"];

    ACA_CREATE = 3
    [(NYT.NYson.NProto.enum_value_name) = "create"];

    ACA_SSH_ACCESS = 4
    [(NYT.NYson.NProto.enum_value_name) = "ssh_access"];

    ACA_ROOT_SSH_ACCESS = 5
    [(NYT.NYson.NProto.enum_value_name) = "root_ssh_access"];
}

message TAccessControlEntry
{
    // Determines the access control action to take upon a match.
    required EAccessControlAction action = 1;

    // List of permissions this entry applies to.
    repeated EAccessControlPermission permissions = 2;

    // List of subjects (users and groups) this entry applies to.
    repeated string subjects = 3;
}

////////////////////////////////////////////////////////////////////////////////

message TSchemaMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    repeated TAccessControlEntry acl = 11;
}

message TSchemaSpec
{ }

message TSchemaStatus
{ }

message TSchema
{
    optional TSchemaMeta meta = 1;
    optional TSchemaSpec spec = 2;
    optional TSchemaStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

enum EResourceKind
{
    RK_CPU = 0
    [(NYT.NYson.NProto.enum_value_name) = "cpu"];

    RK_MEMORY = 1
    [(NYT.NYson.NProto.enum_value_name) = "memory"];

    RK_DISK = 2
    [(NYT.NYson.NProto.enum_value_name) = "disk"];
}

enum EDiskVolumePolicy
{
    DVP_QUOTA = 0
    [(NYT.NYson.NProto.enum_value_name) = "quota"];

    DVP_EXCLUSIVE = 1
    [(NYT.NYson.NProto.enum_value_name) = "exclusive"];
}

message TResourceMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    required string node_id = 4;
    required EResourceKind kind = 5;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TResourceSpec
{
    // TODO(babenko): deprecate
    optional EResourceKind kind = 1;
    // TODO(babenko): deprecate
    optional uint64 total_capacity = 2;

    message TCpuSpec
    {
        // In VCPU units.
        required uint64 total_capacity = 1;
        // Calibrated compute power of a single "physical" CPU core.
        // Typically "physical" CPU cores are, in fact, HT threads.
        optional double cpu_to_vcpu_factor = 2;
    }

    message TMemorySpec
    {
        // In bytes.
        required uint64 total_capacity = 1;
    }

    message TDiskSpec
    {
        // E.g. ssd, hdd etc.
        required string storage_class = 1;
        // In bytes.
        required uint64 total_capacity = 2;
        // Each volume occupies a virtual "slot".
        // This prevents assigning too many volumes to a single physical disk.
        optional uint64 total_volume_slots = 3;
        // E.g. /dev/* path.
        optional string device = 4;
        // List of supported allocation policies.
        repeated EDiskVolumePolicy supported_policies = 5;
    }

    oneof concrete_spec
    {
        TCpuSpec cpu = 3;
        TMemorySpec memory = 4;
        TDiskSpec disk = 5;
    }
}

message TResourceStatus
{
    message TCpuAllocation
    {
        required uint64 capacity = 1;
    }

    message TMemoryAllocation
    {
        required uint64 capacity = 1;
    }

    message TDiskAllocation
    {
        required uint64 capacity = 1;
        required bool exclusive = 2;
        required string volume_id = 3;
    }

    message TAllocation
    {
        optional string pod_id = 1;

        oneof concrete_allocation
        {
            TCpuAllocation cpu = 2;
            TMemoryAllocation memory = 3;
            TDiskAllocation disk = 4;
        }
    }
    repeated TAllocation scheduled_allocations = 1;
    repeated TAllocation actual_allocations = 2;
}

message TResource
{
    optional TResourceMeta meta = 1;
    optional TResourceSpec spec = 2;
    optional TResourceStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

enum EHfsmState
{
    HS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    HS_INITIAL = 100
    [(NYT.NYson.NProto.enum_value_name) = "initial"];

    HS_UP = 200
    [(NYT.NYson.NProto.enum_value_name) = "up"];

    HS_DOWN = 300
    [(NYT.NYson.NProto.enum_value_name) = "down"];

    HS_SUSPECTED = 400
    [(NYT.NYson.NProto.enum_value_name) = "suspected"];

    HS_PREPARE_MAINTENANCE = 500
    [(NYT.NYson.NProto.enum_value_name) = "prepare_maintenance"];

    HS_MAINTENANCE = 600
    [(NYT.NYson.NProto.enum_value_name) = "maintenance"];

    HS_PROBATION = 700
    [(NYT.NYson.NProto.enum_value_name) = "probation"];
}

enum ENodeMaintenanceState
{
    NMS_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    NMS_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    NMS_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];

    NMS_IN_PROGRESS = 300
    [(NYT.NYson.NProto.enum_value_name) = "in_progress"];
}

message TNodeMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TNodeSpec
{
    message TIP6Subnet
    {
        // IP6 /64-subnet, in textual form.
        required string subnet = 1;

        // E.g. backbone or fastbone.
        required string vlan_id = 2;
    }
    // MTN subnets.
    repeated TIP6Subnet ip6_subnets = 1;

    message TIP6Address
    {
        // IP6 address, in textual form.
        required string address = 1;

        // E.g. backbone or fastbone.
        required string vlan_id = 2;
    }
    // Host (dom0) IP6 addresses.
    repeated TIP6Address ip6_addresses = 2;

    // Used to construct /pod/status/transient_fqdn.
    // Typically this is the first part of the node's FQDN, i.e.
    // "sas1-3329" for "sas1-3329.search.yandex.net".
    optional string short_name = 3;

    // Calibrated compute power of a single "physical" CPU core.
    // Typically "physical" CPU cores are, in fact, HT threads.
    optional double cpu_to_vcpu_factor = 4;

    message THfsm
    {
        // Setting this to false prevents automatic HFSM status updates.
        optional bool enable_sync = 2;
    }
    // HFSM controls.
    optional THfsm hfsm = 5;

    // NOC module in "physical" network topology.
    optional string network_module_id = 6;
}

message TNodeStatus
{
    // Current epoch used for master-agent communication.
    optional string epoch_id = 1;

    // Timestamp of last agent heartbeat.
    optional uint64 last_seen_time = 2;

    // Used for properly sequencing master-agent communication.
    optional uint64 heartbeat_sequence_number = 3;

    // Address of GPRC service at agent used for out-of-band notifications.
    optional string agent_address = 4;

    message THfsm
    {
        // Current HFSM state.
        optional EHfsmState state = 1;

        // Timestamp of last change.
        optional uint64 last_updated = 2;

        // Comment for the last change.
        optional string message = 3;
    }
    // HFSM info.
    optional THfsm hfsm = 5;

    message TMaintenance
    {
        // Current maintenance state.
        optional ENodeMaintenanceState state = 1;

        // Timestamp of last change.
        optional uint64 last_updated = 2;

        // Comment for the last change.
        optional string message = 3;
    }
    // Maintenance workflow.
    optional TMaintenance maintenance = 6;
}

message TNodeControl
{
    message TUpdateHfsmState
    {
        // New HFSM state.
        optional EHfsmState state = 1;

        // Comment for changing HFSM state.
        optional string message = 2;
    }

    // Enables updating HFSM state.
    optional TUpdateHfsmState update_hfsm_state = 1;
}

message TNode
{
    optional TNodeMeta meta = 1;
    optional TNodeSpec spec = 2;
    optional TNodeStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
    optional TNodeControl control = 6;
}

////////////////////////////////////////////////////////////////////////////////

enum EPodCurrentState
{
    PCS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    PCS_START_PENDING = 100
    [(NYT.NYson.NProto.enum_value_name) = "start_pending"];

    PCS_STARTED = 200
    [(NYT.NYson.NProto.enum_value_name) = "started"];

    PCS_STOP_PENDING = 300
    [(NYT.NYson.NProto.enum_value_name) = "stop_pending"];

    PCS_STOPPED = 400
    [(NYT.NYson.NProto.enum_value_name) = "stopped"];
}

enum EPodTargetState
{
    PTS_UNKNOWN = 0
    [(NYT.NYson.NProto.enum_value_name) = "unknown"];

    PTS_REMOVED = 1
    [(NYT.NYson.NProto.enum_value_name) = "removed"];

    PTS_ACTIVE = 100
    [(NYT.NYson.NProto.enum_value_name) = "active"];
}

message TPodMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    required string pod_set_id = 4;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TPodSpec
{
    // Raw ISS payload to be delivered to agent.
    // COMPAT(babenko): will be deprecated after switching to pod agent.
    optional bytes iss_payload = 1;

    // Structured ISS spec.
    // COMPAT(babenko): will be deprecated after switching to pod agent.
    optional NYP.NClient.NApi.NClusterApiProto.HostConfiguration iss = 9;


    message TPodAgentDeploymentMeta
    {
        // URL to download pod agent binary from.
        optional string url = 1;
        // <scheme>:<hex value>. Supported schemes are "MD5" and "EMPTY".
        optional string checksum = 2;
        // Arguments to be passed to pod agent via command line.
        map<string, string> configuration = 3;
    }

    message TPodAgentPayload
    {
        optional NInfra.NPodAgent.API.TPodAgentSpec spec = 1;
        optional TPodAgentDeploymentMeta meta = 2;
    }

    // Pod agent deployment and its workload specs.
    // COMPAT(babenko): Either this or iss_payload/iss should be present.
    optional TPodAgentPayload pod_agent_payload = 14;

    // Node id this pod must be assigned to.
    // XXX(babenko): WILL BE REMOVED SOON. DON'T USE.
    optional string node_id = 2;

    message TResourceRequests
    {
        optional uint64 vcpu_guarantee = 1;
        optional uint64 vcpu_limit = 2;

        optional uint64 memory_guarantee = 3;
        optional uint64 memory_limit = 4;
        optional uint64 anonymous_memory_limit = 5;
        optional uint64 dirty_memory_limit = 6;
    };
    // CPU and memory resources to allocate and configure for this pod upon assignment.
    optional TResourceRequests resource_requests = 3;

    message TIP6AddressRequest
    {
        // Id of network_project.
        // Could be omitted if manual_address is given.
        optional string network_id = 1;

        // Will be matched against /node/spec/ip6_subnets/*/vlan_id.
        required string vlan_id = 2;

        // These labels get propagated to /pod/status/ip6_address_allocations/*/labels
        optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 3;

        // If given, specifies the exact IP6 address to use thus disabling IP Broker.
        // This feature will only be used for migration and will be deprecated afterwards.
        optional string manual_address = 4;

        // If true, this address is published to DNS.
        optional bool enable_dns = 5;

        // If non-empty, full DNS name is prepended with this string (plus dot).
        optional string dns_prefix = 6;

        // If true, internet tunnels is configured (InternetAddress is allocated and assigned to pod).
        optional bool enable_internet = 7;
    }
    // IP6 addresses to allocate for this pod upon assignment.
    repeated TIP6AddressRequest ip6_address_requests = 5;

    message TIP6SubnetRequest
    {
        // Will be matched against /node/spec/ip6_subnets/*/vlan_id.
        required string vlan_id = 1;

        // These labels get propagated to /node/status/ip6_subnet_allocations/*/labels
        optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 2;
    }
    // IP6 subnets to allocate for this pod upon assignment.
    repeated TIP6SubnetRequest ip6_subnet_requests = 6;

    message TDiskVolumeRequest
    {
        // Pod-wise unique id.
        required string id = 1;

        // These labels get propagated to /pod/status/disk_volume_allocations/*/labels
        optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 2;

        // E.g. ssd, hdd.
        required string storage_class = 3;

        message TQuotaPolicy
        {
            // Quota limit for this volume.
            required uint64 capacity = 1;
        }

        message TExclusivePolicy
        {
            // Minimum capacity the disk must have.
            // The client, however, will be charged for the whole disk capacity.
            required uint64 min_capacity = 1;
        }

        oneof concrete_policy
        {
            TQuotaPolicy quota_policy = 6;
            TExclusivePolicy exclusive_policy = 7;
        }
    }
    // Disk volumes to allocate for this pod upon assignment.
    repeated TDiskVolumeRequest disk_volume_requests = 13;

    // If false then YP will not be scheduling this pod.
    optional bool enable_scheduling = 7;

    // If given, controls which nodes are eligible for this pod.
    // Filter is a query language predicate; it can only refer to node labels, not other attributes.
    optional string node_filter = 8;

    message THostDevice
    {
        // E.g. /dev/kvm
        required string path = 1;

        // E.g. "r", "rw"
        required string mode = 2;
    }
    // Host devices to configure.
    // https://wiki.yandex-team.ru/porto/propertiesanddata/#resursy
    repeated THostDevice host_devices = 10;

    message TSysctlProperty
    {
        required string name = 1;
        required string value = 2;
    }
    // Sysctl properties to configure.
    repeated TSysctlProperty sysctl_properties = 11;

    message TVirtualServiceTunnel
    {
        required string virtual_service_id = 1;
        optional uint32 ip4_mtu = 2;
        optional uint32 ip6_mtu = 3;
        optional string decapsulator_anycast_address = 4;
    }

    optional TVirtualServiceTunnel virtual_service_tunnel = 12;
}

enum EEvictionState
{
    ES_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ES_REQUESTED = 100
    [(NYT.NYson.NProto.enum_value_name) = "requested"];

    ES_ACKNOWLEDGED = 200
    [(NYT.NYson.NProto.enum_value_name) = "acknowledged"];
}

enum EEvictionReason
{
    ER_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    ER_HFSM = 100
    [(NYT.NYson.NProto.enum_value_name) = "hfsm"];

    ER_SCHEDULER = 200
    [(NYT.NYson.NProto.enum_value_name) = "scheduler"];
}

enum ESchedulingState
{
    SS_NONE = 0
    [(NYT.NYson.NProto.enum_value_name) = "none"];

    SS_DISABLED = 100
    [(NYT.NYson.NProto.enum_value_name) = "disabled"];

    SS_PENDING = 200
    [(NYT.NYson.NProto.enum_value_name) = "pending"];

    SS_ASSIGNED = 300
    [(NYT.NYson.NProto.enum_value_name) = "assigned"];
}

message TPodStatus
{
    // Node where this pod currently belongs to.
    optional string node_id = 1;

    message TAgent
    {
        // ISS pod state.
        optional EPodCurrentState state = 1;

        // Raw ISS payload received from agent.
        // COMPAT(babenko): will be deprecated after switching to pod agent.
        optional bytes iss_payload = 3;

        // Structured ISS status.
        // COMPAT(babenko): will be deprecated after switching to pod agent.
        optional NYP.NClient.NApi.NClusterApiProto.HostCurrentState iss = 4;

        message TPodAgentPayload
        {
            optional NInfra.NPodAgent.API.TPodAgentStatus status = 1;
        }

        // Pod agent status.
        // COMPAT(babenko): Either this or iss_payload/iss should be present.
        optional TPodAgentPayload pod_agent_payload = 5;
    }
    optional TAgent agent = 2;

    message TResourceAllocation
    {
        optional string resource_id = 1;
    }
    repeated TResourceAllocation scheduled_resource_allocations = 4;

    message TIP6AddressAllocation
    {
        // IP6 address assigned by YP, in textual form.
        optional string address = 1;

        // Copied from /pod/spec/ip6_addresses/*/vlan_id.
        optional string vlan_id = 2;

        // Copied from /pod/spec/ip6_subnet_requests/*/labels
        optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 3;

        // True if the the address was manually specified via /pod/spec/ip6_address_allocations/*/manual_address.
        optional bool manual = 4;

        // Persistent DNS name assigned to this address (if any) of the form:
        // [<dns_prefix>.]<pod-id>.<suffix>
        // This FQDN never changes.
        optional string persistent_fqdn = 5;

        // Transient DNS name assigned to this address (if any) of the form:
        // [<dns_prefix>.]<node-short-name>-<generation-number>.<pod-id>.<suffix>
        // This FQDN changes each time pod gets reassigned to another node.
        optional string transient_fqdn = 6;

        message TInternetAddress
        {
            required string id = 1;
            required string ip4_address = 2;
        }

        // Internet address assigned to this allocation.
        optional TInternetAddress internet_address = 7;
    }
    repeated TIP6AddressAllocation ip6_address_allocations = 5;

    message TIP6SubnetAllocation
    {
        // IP6 /112-subnet assigned by YP, in textual form.
        optional string subnet = 1;

        // Copied from /pod/spec/ip6_addresses/*/vlan_id.
        optional string vlan_id = 2;

        // Copied from /node/spec/ip6_address_requests/*/labels
        optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 3;
    }
    repeated TIP6SubnetAllocation ip6_subnet_allocations = 6;

    message TDiskVolumeAllocation
    {
        // Copied from /pod/spec/disk_volume_requests/*/id.
        optional string id = 1;

        // Copied from /pod/spec/ip6_subnet_requests/*/labels.
        optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 3;

        // Total volume capacity.
        optional uint64 capacity = 4;

        // Id of disk resource where this volume will reside.
        optional string resource_id = 5;

        // Globally-unique volume id.
        // This is generated each time a "new" volume is assigned to the pod.
        // "New" volumes are recognized based on /pod/spec/disk_volume_allocations/*/id.
        optional string volume_id = 6;

        // Copied from /resource/spec/disk/device.
        optional string device = 7;
    }
    repeated TDiskVolumeAllocation disk_volume_allocations = 14;

    message TDns
    {
        // Persistent FQDN of the form:
        // <pod-id>.<suffix>
        // This FQDN never changes.
        optional string persistent_fqdn = 7;

        // Transient FQDN of the form:
        // <node-short-name>-<generation-number>.<pod-id>.<suffix>
        // This FQDN changes each time pod gets reassigned to another node.
        optional string transient_fqdn = 8;
    }
    optional TDns dns = 7;

    message TEviction
    {
        optional EEvictionState state = 1;
        optional EEvictionReason reason = 2;
        optional uint64 last_updated = 3;
        optional string message = 4;
    }
    optional TEviction eviction = 8;

    message TScheduling
    {
        optional ESchedulingState state = 1;
        optional string node_id = 2;
        optional uint64 last_updated = 3;
        optional string message = 4;
        optional NYtPython.NProto.TError error = 5;
    }
    optional TScheduling scheduling = 9;

    // Increased each time the pod is being assigned to another node.
    optional uint64 generation_number = 10;

    // Timestamp of the last spec update.
    optional uint64 master_spec_timestamp = 11;

    // Timestamp of the spec as reported by agent.
    optional uint64 agent_spec_timestamp = 12;

    message TVirtualService
    {
        // IP6 address, in textual form.
        repeated string ip6_addresses = 1;
        // IP4 address, in textual form.
        repeated string ip4_addresses = 2;
    }

    optional TVirtualService virtual_service = 13;
}

message TPodControl
{
    message TAcknowledgeEviction
    {
        // Comment for the acknowledgement.
        optional string message = 1;
    }

    // Acknowledges eviction of a pod.
    // Pod must have /status/eviction/state == "requested" prior to this call and
    // the latter changes it to "acknowledged".
    optional TAcknowledgeEviction acknowledge_eviction = 1;
}

message TPod
{
    optional TPodMeta meta = 1;
    optional TPodSpec spec = 2;
    optional TPodStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TPodSetMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TPodSetSpec
{
    message TAntiaffinityConstraint
    {
        // Topology zone key.
        // Node zones are specified via /node/labels/topology/key=value labels.
        // and are filled on node's import.
        // Supported zone keys are: node, rack, dc.
        required string key = 1;

        // Maximum number of pods that can be placed in the same zone.
        required int64 max_pods = 2;

        // Describes the pods this constraint applies to.
        // TODO(babenko): this is not currently implemented
        optional string pod_filter = 3;
    }

    // Limits placing pods of this pod set to the same topology zone (e.g. node, rack, DC).
    repeated TAntiaffinityConstraint antiaffinity_constraints = 1;

    // Specifies a node segment where all pods of this pod set must be scheduled to.
    optional string node_segment_id = 2;
}

message TPodSetStatus
{ }

message TPodSet
{
    optional TPodSetMeta meta = 1;
    optional TPodSetSpec spec = 2;
    optional TPodSetStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TEndpointMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    required string endpoint_set_id = 4;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TEndpointSpec
{
    optional string protocol = 1;
    optional string fqdn = 2;
    optional string ip4_address = 3;
    optional string ip6_address = 4;
    optional int32 port = 5;
}

message TEndpointStatus
{ }

message TEndpoint
{
    optional TEndpointMeta meta = 1;
    optional TEndpointSpec spec = 2;
    optional TEndpointStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TEndpointSetMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TEndpointSetSpec
{
    // If given, for each pod matching this filter, an endpoint will be created.
    optional string pod_filter = 1;

    // If given, this value will be propagated to /endpoint/spec/protocol of each created endpoint.
    optional string protocol = 2;

    // If given, this value will be propagated to /endpoint/spec/port of each created endpoint.
    optional int32 port = 3;
}

message TEndpointSetStatus
{ }

message TEndpointSet
{
    optional TEndpointSetMeta meta = 1;
    optional TEndpointSetSpec spec = 2;
    optional TEndpointSetStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TNetworkProjectMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TNetworkProjectSpec
{
    // "Project id" part of IPv6 addresses.
    required uint32 project_id = 1;
}

message TNetworkProjectStatus
{ }

message TNetworkProject
{
    optional TNetworkProjectMeta meta = 1;
    optional TNetworkProjectSpec spec = 2;
    optional TNetworkProjectStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TNodeSegmentMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TNodeSegmentSpec
{
    required string node_filter = 1;
}

message TNodeSegmentStatus
{ }

message TNodeSegment
{
    optional TNodeSegmentMeta meta = 1;
    optional TNodeSegmentSpec spec = 2;
    optional TNodeSegmentStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TVirtualServiceMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TVirtualServiceSpec
{
    // IP6 address, in textual form.
    repeated string ip6_addresses = 1;
    // IP4 address, in textual form.
    repeated string ip4_addresses = 2;
}

message TVirtualServiceStatus
{ }

message TVirtualService
{
    optional TVirtualServiceMeta meta = 1;
    optional TVirtualServiceSpec spec = 2;
    optional TVirtualServiceStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TUserMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TUserSpec
{ }

message TUserStatus
{ }

message TUser
{
    optional TUserMeta meta = 1;
    optional TUserSpec spec = 2;
    optional TUserStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TGroupMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
    optional bool inherit_acl = 10;
    repeated TAccessControlEntry acl = 11;
}

message TGroupSpec
{
    // List of subjects (users and groups) that are members of this group.
    repeated string members = 1;
}

message TGroupStatus
{ }

message TGroup
{
    optional TGroupMeta meta = 1;
    optional TGroupSpec spec = 2;
    optional TGroupStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////

message TInternetAddressMeta
{
    optional string id = 1;
    optional EObjectType type = 2;
    optional uint64 creation_time = 3;
}

message TInternetAddressSpec
{
    required string ip4_address = 1;
    required string network_module_id = 2;
}

message TInternetAddressStatus
{
    optional string pod_id = 1;
}

message TInternetAddress
{
    optional TInternetAddressMeta meta = 1;
    optional TInternetAddressSpec spec = 2;
    optional TInternetAddressStatus status = 3;
    optional NYtPython.NYTree.NProto.TAttributeDictionary labels = 4;
    optional NYtPython.NYTree.NProto.TAttributeDictionary annotations = 5;
}

////////////////////////////////////////////////////////////////////////////////
