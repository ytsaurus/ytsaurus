// Code generated by yt-gen-client. DO NOT EDIT.

package internal

import (
	"go.ytsaurus.tech/library/go/core/log"
	"go.ytsaurus.tech/yt/go/guid"
	"go.ytsaurus.tech/yt/go/ypath"
	"go.ytsaurus.tech/yt/go/yson"
	"go.ytsaurus.tech/yt/go/yt"
)

func writeTransactionOptions(w *yson.Writer, o *yt.TransactionOptions) {
	if o == nil {
		return
	}
	defaultTxID := yt.TxID{}
	if o.TransactionID != defaultTxID {
		w.MapKeyString("transaction_id")
		w.Any(o.TransactionID)
	}
	w.MapKeyString("ping")
	w.Any(o.Ping)
	w.MapKeyString("ping_ancestor_transactions")
	w.Any(o.PingAncestors)
	w.MapKeyString("suppress_transaction_coordinator_sync")
	w.Any(o.SuppressTransactionCoordinatorSync)
	w.MapKeyString("suppress_upstream_sync")
	w.Any(o.SuppressUpstreamSync)
}

func logTransactionOptions(o *yt.TransactionOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	var zero yt.TxID
	if o.TransactionID != zero {
		fields = append(fields, log.Any("transaction_id", o.TransactionID))
	}
	if o.Ping {
		fields = append(fields, log.Any("ping", o.Ping))
	}
	if o.PingAncestors {
		fields = append(fields, log.Any("ping_ancestor_transactions", o.PingAncestors))
	}
	if o.SuppressTransactionCoordinatorSync {
		fields = append(fields, log.Any("suppress_transaction_coordinator_sync", o.SuppressTransactionCoordinatorSync))
	}
	if o.SuppressUpstreamSync {
		fields = append(fields, log.Any("suppress_upstream_sync", o.SuppressUpstreamSync))
	}
	return fields
}

func writeAccessTrackingOptions(w *yson.Writer, o *yt.AccessTrackingOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("suppress_access_tracking")
	w.Any(o.SuppressAccessTracking)
	w.MapKeyString("suppress_modification_tracking")
	w.Any(o.SuppressModificationTracking)
}

func logAccessTrackingOptions(o *yt.AccessTrackingOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.SuppressAccessTracking {
		fields = append(fields, log.Any("suppress_access_tracking", o.SuppressAccessTracking))
	}
	if o.SuppressModificationTracking {
		fields = append(fields, log.Any("suppress_modification_tracking", o.SuppressModificationTracking))
	}
	return fields
}

func writeMutatingOptions(w *yson.Writer, o *yt.MutatingOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("mutation_id")
	w.Any(o.MutationID)
	w.MapKeyString("retry")
	w.Any(o.Retry)
}

func logMutatingOptions(o *yt.MutatingOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	var zero yt.MutationID
	if o.MutationID != zero {
		fields = append(fields, log.Any("mutation_id", o.MutationID))
	}
	if o.Retry {
		fields = append(fields, log.Any("retry", o.Retry))
	}
	return fields
}

func writeReadRetryOptions(w *yson.Writer, o *yt.ReadRetryOptions) {
	if o == nil {
		return
	}
}

func logReadRetryOptions(o *yt.ReadRetryOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeMasterReadOptions(w *yson.Writer, o *yt.MasterReadOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("read_from")
	w.Any(o.ReadFrom)
	if o.DisablePerUserCache != nil {
		w.MapKeyString("disable_per_user_cache")
		w.Any(o.DisablePerUserCache)
	}
	if o.ExpireAfterSuccessfulUpdateTime != nil {
		w.MapKeyString("expire_after_successful_update_time")
		w.Any(o.ExpireAfterSuccessfulUpdateTime)
	}
	if o.ExpireAfterFailedUpdateTime != nil {
		w.MapKeyString("expire_after_failed_update_time")
		w.Any(o.ExpireAfterFailedUpdateTime)
	}
	if o.CacheStickyGroupSize != nil {
		w.MapKeyString("cache_sticky_group_size")
		w.Any(o.CacheStickyGroupSize)
	}
	if o.SuccessStalenessBound != nil {
		w.MapKeyString("success_staleness_bound")
		w.Any(o.SuccessStalenessBound)
	}
}

func logMasterReadOptions(o *yt.MasterReadOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	var zero yt.ReadKind
	if o.ReadFrom != zero {
		fields = append(fields, log.Any("read_from", o.ReadFrom))
	}
	if o.DisablePerUserCache != nil {
		fields = append(fields, log.Any("disable_per_user_cache", o.DisablePerUserCache))
	}
	if o.ExpireAfterSuccessfulUpdateTime != nil {
		fields = append(fields, log.Any("expire_after_successful_update_time", o.ExpireAfterSuccessfulUpdateTime))
	}
	if o.ExpireAfterFailedUpdateTime != nil {
		fields = append(fields, log.Any("expire_after_failed_update_time", o.ExpireAfterFailedUpdateTime))
	}
	if o.CacheStickyGroupSize != nil {
		fields = append(fields, log.Any("cache_sticky_group_size", o.CacheStickyGroupSize))
	}
	if o.SuccessStalenessBound != nil {
		fields = append(fields, log.Any("success_staleness_bound", o.SuccessStalenessBound))
	}
	return fields
}

func writePrerequisiteOptions(w *yson.Writer, o *yt.PrerequisiteOptions) {
	if o == nil {
		return
	}
	if o.TransactionIDs != nil {
		w.MapKeyString("prerequisite_transaction_ids")
		w.Any(o.TransactionIDs)
	}
	if o.Revisions != nil {
		w.MapKeyString("prerequisite_revisions")
		w.Any(o.Revisions)
	}
}

func logPrerequisiteOptions(o *yt.PrerequisiteOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.TransactionIDs != nil {
		fields = append(fields, log.Any("prerequisite_transaction_ids", o.TransactionIDs))
	}
	if o.Revisions != nil {
		fields = append(fields, log.Any("prerequisite_revisions", o.Revisions))
	}
	return fields
}

func writeTimeoutOptions(w *yson.Writer, o *yt.TimeoutOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("timeout")
	w.Any(o.Timeout)
}

func logTimeoutOptions(o *yt.TimeoutOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	var zero yson.Duration
	if o.Timeout != zero {
		fields = append(fields, log.Any("timeout", o.Timeout))
	}
	return fields
}

func writeCreateNodeOptions(w *yson.Writer, o *yt.CreateNodeOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("recursive")
	w.Any(o.Recursive)
	w.MapKeyString("ignore_existing")
	w.Any(o.IgnoreExisting)
	w.MapKeyString("force")
	w.Any(o.Force)
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logCreateNodeOptions(o *yt.CreateNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Recursive {
		fields = append(fields, log.Any("recursive", o.Recursive))
	}
	if o.IgnoreExisting {
		fields = append(fields, log.Any("ignore_existing", o.IgnoreExisting))
	}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeCreateObjectOptions(w *yson.Writer, o *yt.CreateObjectOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("recursive")
	w.Any(o.Recursive)
	w.MapKeyString("ignore_existing")
	w.Any(o.IgnoreExisting)
	w.MapKeyString("force")
	w.Any(o.Force)
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logCreateObjectOptions(o *yt.CreateObjectOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Recursive {
		fields = append(fields, log.Any("recursive", o.Recursive))
	}
	if o.IgnoreExisting {
		fields = append(fields, log.Any("ignore_existing", o.IgnoreExisting))
	}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeNodeExistsOptions(w *yson.Writer, o *yt.NodeExistsOptions) {
	if o == nil {
		return
	}
	writeMasterReadOptions(w, o.MasterReadOptions)
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
	writeReadRetryOptions(w, o.ReadRetryOptions)
}

func logNodeExistsOptions(o *yt.NodeExistsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	fields = append(fields, logReadRetryOptions(o.ReadRetryOptions)...)
	return fields
}

func writeRemoveNodeOptions(w *yson.Writer, o *yt.RemoveNodeOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("recursive")
	w.Any(o.Recursive)
	w.MapKeyString("force")
	w.Any(o.Force)
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logRemoveNodeOptions(o *yt.RemoveNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Recursive {
		fields = append(fields, log.Any("recursive", o.Recursive))
	}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeGetNodeOptions(w *yson.Writer, o *yt.GetNodeOptions) {
	if o == nil {
		return
	}
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	if o.MaxSize != nil {
		w.MapKeyString("max_size")
		w.Any(o.MaxSize)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
	writeMasterReadOptions(w, o.MasterReadOptions)
	writeReadRetryOptions(w, o.ReadRetryOptions)
}

func logGetNodeOptions(o *yt.GetNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	if o.MaxSize != nil {
		fields = append(fields, log.Any("max_size", o.MaxSize))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	fields = append(fields, logReadRetryOptions(o.ReadRetryOptions)...)
	return fields
}

func writeSetNodeOptions(w *yson.Writer, o *yt.SetNodeOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("recursive")
	w.Any(o.Recursive)
	w.MapKeyString("force")
	w.Any(o.Force)
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logSetNodeOptions(o *yt.SetNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Recursive {
		fields = append(fields, log.Any("recursive", o.Recursive))
	}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeMultisetAttributesOptions(w *yson.Writer, o *yt.MultisetAttributesOptions) {
	if o == nil {
		return
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logMultisetAttributesOptions(o *yt.MultisetAttributesOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeListNodeOptions(w *yson.Writer, o *yt.ListNodeOptions) {
	if o == nil {
		return
	}
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	if o.MaxSize != nil {
		w.MapKeyString("max_size")
		w.Any(o.MaxSize)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeMasterReadOptions(w, o.MasterReadOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
	writeReadRetryOptions(w, o.ReadRetryOptions)
}

func logListNodeOptions(o *yt.ListNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	if o.MaxSize != nil {
		fields = append(fields, log.Any("max_size", o.MaxSize))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	fields = append(fields, logReadRetryOptions(o.ReadRetryOptions)...)
	return fields
}

func writeCopyNodeOptions(w *yson.Writer, o *yt.CopyNodeOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("recursive")
	w.Any(o.Recursive)
	w.MapKeyString("ignore_existing")
	w.Any(o.IgnoreExisting)
	w.MapKeyString("force")
	w.Any(o.Force)
	if o.PreserveAccount != nil {
		w.MapKeyString("preserve_account")
		w.Any(o.PreserveAccount)
	}
	if o.PreserveExpirationTime != nil {
		w.MapKeyString("preserve_expiration_time")
		w.Any(o.PreserveExpirationTime)
	}
	if o.PreserveExpirationTimeout != nil {
		w.MapKeyString("preserve_expiration_timeout")
		w.Any(o.PreserveExpirationTimeout)
	}
	if o.PreserveCreationTime != nil {
		w.MapKeyString("preserve_creation_time")
		w.Any(o.PreserveCreationTime)
	}
	if o.PessimisticQuotaCheck != nil {
		w.MapKeyString("pessimistic_quota_check")
		w.Any(o.PessimisticQuotaCheck)
	}
	if o.EnableCrossCellCopying != nil {
		w.MapKeyString("enable_cross_cell_copying")
		w.Any(o.EnableCrossCellCopying)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logCopyNodeOptions(o *yt.CopyNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Recursive {
		fields = append(fields, log.Any("recursive", o.Recursive))
	}
	if o.IgnoreExisting {
		fields = append(fields, log.Any("ignore_existing", o.IgnoreExisting))
	}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	if o.PreserveAccount != nil {
		fields = append(fields, log.Any("preserve_account", o.PreserveAccount))
	}
	if o.PreserveExpirationTime != nil {
		fields = append(fields, log.Any("preserve_expiration_time", o.PreserveExpirationTime))
	}
	if o.PreserveExpirationTimeout != nil {
		fields = append(fields, log.Any("preserve_expiration_timeout", o.PreserveExpirationTimeout))
	}
	if o.PreserveCreationTime != nil {
		fields = append(fields, log.Any("preserve_creation_time", o.PreserveCreationTime))
	}
	if o.PessimisticQuotaCheck != nil {
		fields = append(fields, log.Any("pessimistic_quota_check", o.PessimisticQuotaCheck))
	}
	if o.EnableCrossCellCopying != nil {
		fields = append(fields, log.Any("enable_cross_cell_copying", o.EnableCrossCellCopying))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeMoveNodeOptions(w *yson.Writer, o *yt.MoveNodeOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("recursive")
	w.Any(o.Recursive)
	w.MapKeyString("force")
	w.Any(o.Force)
	if o.PreserveAccount != nil {
		w.MapKeyString("preserve_account")
		w.Any(o.PreserveAccount)
	}
	if o.PreserveExpirationTime != nil {
		w.MapKeyString("preserve_expiration_time")
		w.Any(o.PreserveExpirationTime)
	}
	if o.PreserveExpirationTimeout != nil {
		w.MapKeyString("preserve_expiration_timeout")
		w.Any(o.PreserveExpirationTimeout)
	}
	if o.PessimisticQuotaCheck != nil {
		w.MapKeyString("pessimistic_quota_check")
		w.Any(o.PessimisticQuotaCheck)
	}
	if o.EnableCrossCellCopying != nil {
		w.MapKeyString("enable_cross_cell_copying")
		w.Any(o.EnableCrossCellCopying)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logMoveNodeOptions(o *yt.MoveNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Recursive {
		fields = append(fields, log.Any("recursive", o.Recursive))
	}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	if o.PreserveAccount != nil {
		fields = append(fields, log.Any("preserve_account", o.PreserveAccount))
	}
	if o.PreserveExpirationTime != nil {
		fields = append(fields, log.Any("preserve_expiration_time", o.PreserveExpirationTime))
	}
	if o.PreserveExpirationTimeout != nil {
		fields = append(fields, log.Any("preserve_expiration_timeout", o.PreserveExpirationTimeout))
	}
	if o.PessimisticQuotaCheck != nil {
		fields = append(fields, log.Any("pessimistic_quota_check", o.PessimisticQuotaCheck))
	}
	if o.EnableCrossCellCopying != nil {
		fields = append(fields, log.Any("enable_cross_cell_copying", o.EnableCrossCellCopying))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeLinkNodeOptions(w *yson.Writer, o *yt.LinkNodeOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("recursive")
	w.Any(o.Recursive)
	w.MapKeyString("ignore_existing")
	w.Any(o.IgnoreExisting)
	w.MapKeyString("force")
	w.Any(o.Force)
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logLinkNodeOptions(o *yt.LinkNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Recursive {
		fields = append(fields, log.Any("recursive", o.Recursive))
	}
	if o.IgnoreExisting {
		fields = append(fields, log.Any("ignore_existing", o.IgnoreExisting))
	}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeStartTxOptions(w *yson.Writer, o *yt.StartTxOptions) {
	if o == nil {
		return
	}
	if o.Timeout != nil {
		w.MapKeyString("timeout")
		w.Any(o.Timeout)
	}
	if o.Deadline != nil {
		w.MapKeyString("deadline")
		w.Any(o.Deadline)
	}
	if o.Type != nil {
		w.MapKeyString("type")
		w.Any(o.Type)
	}
	w.MapKeyString("sticky")
	w.Any(o.Sticky)
	if o.PrerequisiteTransactionIDs != nil {
		w.MapKeyString("prerequisite_transaction_ids")
		w.Any(o.PrerequisiteTransactionIDs)
	}
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeReadRetryOptions(w, o.ReadRetryOptions)
}

func logStartTxOptions(o *yt.StartTxOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Timeout != nil {
		fields = append(fields, log.Any("timeout", o.Timeout))
	}
	if o.Deadline != nil {
		fields = append(fields, log.Any("deadline", o.Deadline))
	}
	if o.Type != nil {
		fields = append(fields, log.Any("type", o.Type))
	}
	if o.Sticky {
		fields = append(fields, log.Any("sticky", o.Sticky))
	}
	if o.PrerequisiteTransactionIDs != nil {
		fields = append(fields, log.Any("prerequisite_transaction_ids", o.PrerequisiteTransactionIDs))
	}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logReadRetryOptions(o.ReadRetryOptions)...)
	return fields
}

func writePingTxOptions(w *yson.Writer, o *yt.PingTxOptions) {
	if o == nil {
		return
	}
	writeTransactionOptions(w, o.TransactionOptions)
}

func logPingTxOptions(o *yt.PingTxOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	return fields
}

func writeAbortTxOptions(w *yson.Writer, o *yt.AbortTxOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("sticky")
	w.Any(o.Sticky)
	writeTransactionOptions(w, o.TransactionOptions)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logAbortTxOptions(o *yt.AbortTxOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Sticky {
		fields = append(fields, log.Any("sticky", o.Sticky))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeCommitTxOptions(w *yson.Writer, o *yt.CommitTxOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("sticky")
	w.Any(o.Sticky)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
	writeTransactionOptions(w, o.TransactionOptions)
}

func logCommitTxOptions(o *yt.CommitTxOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Sticky {
		fields = append(fields, log.Any("sticky", o.Sticky))
	}
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	return fields
}

func writeWriteFileOptions(w *yson.Writer, o *yt.WriteFileOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("compute_md5")
	w.Any(o.ComputeMD5)
	w.MapKeyString("file_writer")
	w.Any(o.FileWriter)
	writeTransactionOptions(w, o.TransactionOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logWriteFileOptions(o *yt.WriteFileOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.ComputeMD5 {
		fields = append(fields, log.Any("compute_md5", o.ComputeMD5))
	}
	if o.FileWriter != nil {
		fields = append(fields, log.Any("file_writer", o.FileWriter))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeReadFileOptions(w *yson.Writer, o *yt.ReadFileOptions) {
	if o == nil {
		return
	}
	if o.Offset != nil {
		w.MapKeyString("offset")
		w.Any(o.Offset)
	}
	if o.Length != nil {
		w.MapKeyString("length")
		w.Any(o.Length)
	}
	w.MapKeyString("file_reader")
	w.Any(o.FileReader)
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
}

func logReadFileOptions(o *yt.ReadFileOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Offset != nil {
		fields = append(fields, log.Any("offset", o.Offset))
	}
	if o.Length != nil {
		fields = append(fields, log.Any("length", o.Length))
	}
	if o.FileReader != nil {
		fields = append(fields, log.Any("file_reader", o.FileReader))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	return fields
}

func writePutFileToCacheOptions(w *yson.Writer, o *yt.PutFileToCacheOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("cache_path")
	w.Any(o.CachePath)
	writeMasterReadOptions(w, o.MasterReadOptions)
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logPutFileToCacheOptions(o *yt.PutFileToCacheOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	var zero ypath.YPath
	if o.CachePath != zero {
		fields = append(fields, log.Any("cache_path", o.CachePath))
	}
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeGetFileFromCacheOptions(w *yson.Writer, o *yt.GetFileFromCacheOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("cache_path")
	w.Any(o.CachePath)
	writeMasterReadOptions(w, o.MasterReadOptions)
	writeReadRetryOptions(w, o.ReadRetryOptions)
}

func logGetFileFromCacheOptions(o *yt.GetFileFromCacheOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	var zero ypath.YPath
	if o.CachePath != zero {
		fields = append(fields, log.Any("cache_path", o.CachePath))
	}
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	fields = append(fields, logReadRetryOptions(o.ReadRetryOptions)...)
	return fields
}

func writeWriteTableOptions(w *yson.Writer, o *yt.WriteTableOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("table_writer")
	w.Any(o.TableWriter)
	if o.Format != nil {
		w.MapKeyString("input_format")
		w.Any(o.Format)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
}

func logWriteTableOptions(o *yt.WriteTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.TableWriter != nil {
		fields = append(fields, log.Any("table_writer", o.TableWriter))
	}
	if o.Format != nil {
		fields = append(fields, log.Any("input_format", o.Format))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	return fields
}

func writeReadTableOptions(w *yson.Writer, o *yt.ReadTableOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("unordered")
	w.Any(o.Unordered)
	w.MapKeyString("table_reader")
	w.Any(o.TableReader)
	if o.Format != nil {
		w.MapKeyString("output_format")
		w.Any(o.Format)
	}
	if o.ControlAttributes != nil {
		w.MapKeyString("control_attributes")
		w.Any(o.ControlAttributes)
	}
	if o.StartRowIndexOnly != nil {
		w.MapKeyString("start_row_index_only")
		w.Any(o.StartRowIndexOnly)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeAccessTrackingOptions(w, o.AccessTrackingOptions)
}

func logReadTableOptions(o *yt.ReadTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Unordered {
		fields = append(fields, log.Any("unordered", o.Unordered))
	}
	if o.TableReader != nil {
		fields = append(fields, log.Any("table_reader", o.TableReader))
	}
	if o.Format != nil {
		fields = append(fields, log.Any("output_format", o.Format))
	}
	if o.ControlAttributes != nil {
		fields = append(fields, log.Any("control_attributes", o.ControlAttributes))
	}
	if o.StartRowIndexOnly != nil {
		fields = append(fields, log.Any("start_row_index_only", o.StartRowIndexOnly))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logAccessTrackingOptions(o.AccessTrackingOptions)...)
	return fields
}

func writeStartOperationOptions(w *yson.Writer, o *yt.StartOperationOptions) {
	if o == nil {
		return
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logStartOperationOptions(o *yt.StartOperationOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeAbortOperationOptions(w *yson.Writer, o *yt.AbortOperationOptions) {
	if o == nil {
		return
	}
	if o.AbortMessage != nil {
		w.MapKeyString("abort_message")
		w.Any(o.AbortMessage)
	}
}

func logAbortOperationOptions(o *yt.AbortOperationOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.AbortMessage != nil {
		fields = append(fields, log.Any("abort_message", o.AbortMessage))
	}
	return fields
}

func writeSuspendOperationOptions(w *yson.Writer, o *yt.SuspendOperationOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("abort_running_jobs")
	w.Any(o.AbortRunningJobs)
}

func logSuspendOperationOptions(o *yt.SuspendOperationOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.AbortRunningJobs {
		fields = append(fields, log.Any("abort_running_jobs", o.AbortRunningJobs))
	}
	return fields
}

func writeResumeOperationOptions(w *yson.Writer, o *yt.ResumeOperationOptions) {
	if o == nil {
		return
	}
}

func logResumeOperationOptions(o *yt.ResumeOperationOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeCompleteOperationOptions(w *yson.Writer, o *yt.CompleteOperationOptions) {
	if o == nil {
		return
	}
}

func logCompleteOperationOptions(o *yt.CompleteOperationOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeUpdateOperationParametersOptions(w *yson.Writer, o *yt.UpdateOperationParametersOptions) {
	if o == nil {
		return
	}
}

func logUpdateOperationParametersOptions(o *yt.UpdateOperationParametersOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeTransferAccountResourcesOptions(w *yson.Writer, o *yt.TransferAccountResourcesOptions) {
	if o == nil {
		return
	}
	writeMutatingOptions(w, o.MutatingOptions)
}

func logTransferAccountResourcesOptions(o *yt.TransferAccountResourcesOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeTransferPoolResourcesOptions(w *yson.Writer, o *yt.TransferPoolResourcesOptions) {
	if o == nil {
		return
	}
	writeMutatingOptions(w, o.MutatingOptions)
}

func logTransferPoolResourcesOptions(o *yt.TransferPoolResourcesOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeListOperationsOptions(w *yson.Writer, o *yt.ListOperationsOptions) {
	if o == nil {
		return
	}
	if o.FromTime != nil {
		w.MapKeyString("from_time")
		w.Any(o.FromTime)
	}
	if o.ToTime != nil {
		w.MapKeyString("to_time")
		w.Any(o.ToTime)
	}
	if o.Cursor != nil {
		w.MapKeyString("cursor_time")
		w.Any(o.Cursor)
	}
	if o.User != nil {
		w.MapKeyString("user")
		w.Any(o.User)
	}
	if o.State != nil {
		w.MapKeyString("state")
		w.Any(o.State)
	}
	if o.Type != nil {
		w.MapKeyString("type")
		w.Any(o.Type)
	}
	if o.Filter != nil {
		w.MapKeyString("filter")
		w.Any(o.Filter)
	}
	if o.Limit != nil {
		w.MapKeyString("limit")
		w.Any(o.Limit)
	}
	if o.Pool != nil {
		w.MapKeyString("pool")
		w.Any(o.Pool)
	}
	if o.PoolTree != nil {
		w.MapKeyString("pool_tree")
		w.Any(o.PoolTree)
	}
	if o.IncludeArchive != nil {
		w.MapKeyString("include_archive")
		w.Any(o.IncludeArchive)
	}
	writeMasterReadOptions(w, o.MasterReadOptions)
	writeReadRetryOptions(w, o.ReadRetryOptions)
}

func logListOperationsOptions(o *yt.ListOperationsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.FromTime != nil {
		fields = append(fields, log.Any("from_time", o.FromTime))
	}
	if o.ToTime != nil {
		fields = append(fields, log.Any("to_time", o.ToTime))
	}
	if o.Cursor != nil {
		fields = append(fields, log.Any("cursor_time", o.Cursor))
	}
	if o.User != nil {
		fields = append(fields, log.Any("user", o.User))
	}
	if o.State != nil {
		fields = append(fields, log.Any("state", o.State))
	}
	if o.Type != nil {
		fields = append(fields, log.Any("type", o.Type))
	}
	if o.Filter != nil {
		fields = append(fields, log.Any("filter", o.Filter))
	}
	if o.Limit != nil {
		fields = append(fields, log.Any("limit", o.Limit))
	}
	if o.Pool != nil {
		fields = append(fields, log.Any("pool", o.Pool))
	}
	if o.PoolTree != nil {
		fields = append(fields, log.Any("pool_tree", o.PoolTree))
	}
	if o.IncludeArchive != nil {
		fields = append(fields, log.Any("include_archive", o.IncludeArchive))
	}
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	fields = append(fields, logReadRetryOptions(o.ReadRetryOptions)...)
	return fields
}

func writeListJobsOptions(w *yson.Writer, o *yt.ListJobsOptions) {
	if o == nil {
		return
	}
	if o.JobType != nil {
		w.MapKeyString("job_type")
		w.Any(o.JobType)
	}
	if o.JobState != nil {
		w.MapKeyString("job_state")
		w.Any(o.JobState)
	}
	if o.Address != nil {
		w.MapKeyString("address")
		w.Any(o.Address)
	}
	if o.WithStderr != nil {
		w.MapKeyString("with_stderr")
		w.Any(o.WithStderr)
	}
	if o.WithFailContext != nil {
		w.MapKeyString("with_fail_context")
		w.Any(o.WithFailContext)
	}
	if o.WithMonitoringDescriptor != nil {
		w.MapKeyString("with_monitoring_descriptor")
		w.Any(o.WithMonitoringDescriptor)
	}
	if o.WithInterruptionInfo != nil {
		w.MapKeyString("with_interruption_info")
		w.Any(o.WithInterruptionInfo)
	}
	if o.TaskName != nil {
		w.MapKeyString("task_name")
		w.Any(o.TaskName)
	}
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	if o.SortField != nil {
		w.MapKeyString("sort_field")
		w.Any(o.SortField)
	}
	if o.SortOrder != nil {
		w.MapKeyString("sort_order")
		w.Any(o.SortOrder)
	}
	if o.Limit != nil {
		w.MapKeyString("limit")
		w.Any(o.Limit)
	}
	if o.Offset != nil {
		w.MapKeyString("offset")
		w.Any(o.Offset)
	}
	if o.DataSource != nil {
		w.MapKeyString("data_source")
		w.Any(o.DataSource)
	}
}

func logListJobsOptions(o *yt.ListJobsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.JobType != nil {
		fields = append(fields, log.Any("job_type", o.JobType))
	}
	if o.JobState != nil {
		fields = append(fields, log.Any("job_state", o.JobState))
	}
	if o.Address != nil {
		fields = append(fields, log.Any("address", o.Address))
	}
	if o.WithStderr != nil {
		fields = append(fields, log.Any("with_stderr", o.WithStderr))
	}
	if o.WithFailContext != nil {
		fields = append(fields, log.Any("with_fail_context", o.WithFailContext))
	}
	if o.WithMonitoringDescriptor != nil {
		fields = append(fields, log.Any("with_monitoring_descriptor", o.WithMonitoringDescriptor))
	}
	if o.WithInterruptionInfo != nil {
		fields = append(fields, log.Any("with_interruption_info", o.WithInterruptionInfo))
	}
	if o.TaskName != nil {
		fields = append(fields, log.Any("task_name", o.TaskName))
	}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	if o.SortField != nil {
		fields = append(fields, log.Any("sort_field", o.SortField))
	}
	if o.SortOrder != nil {
		fields = append(fields, log.Any("sort_order", o.SortOrder))
	}
	if o.Limit != nil {
		fields = append(fields, log.Any("limit", o.Limit))
	}
	if o.Offset != nil {
		fields = append(fields, log.Any("offset", o.Offset))
	}
	if o.DataSource != nil {
		fields = append(fields, log.Any("data_source", o.DataSource))
	}
	return fields
}

func writeGetJobOptions(w *yson.Writer, o *yt.GetJobOptions) {
	if o == nil {
		return
	}
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
}

func logGetJobOptions(o *yt.GetJobOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	return fields
}

func writeGetJobStderrOptions(w *yson.Writer, o *yt.GetJobStderrOptions) {
	if o == nil {
		return
	}
}

func logGetJobStderrOptions(o *yt.GetJobStderrOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeGetOperationOptions(w *yson.Writer, o *yt.GetOperationOptions) {
	if o == nil {
		return
	}
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	if o.IncludeRuntime != nil {
		w.MapKeyString("include_runtime")
		w.Any(o.IncludeRuntime)
	}
	writeMasterReadOptions(w, o.MasterReadOptions)
	writeReadRetryOptions(w, o.ReadRetryOptions)
}

func logGetOperationOptions(o *yt.GetOperationOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	if o.IncludeRuntime != nil {
		fields = append(fields, log.Any("include_runtime", o.IncludeRuntime))
	}
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	fields = append(fields, logReadRetryOptions(o.ReadRetryOptions)...)
	return fields
}

func writeAddMemberOptions(w *yson.Writer, o *yt.AddMemberOptions) {
	if o == nil {
		return
	}
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logAddMemberOptions(o *yt.AddMemberOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeBuildMasterSnapshotsOptions(w *yson.Writer, o *yt.BuildMasterSnapshotsOptions) {
	if o == nil {
		return
	}
	if o.SetReadOnly != nil {
		w.MapKeyString("set_read_only")
		w.Any(o.SetReadOnly)
	}
	if o.WaitForSnapshotCompletion != nil {
		w.MapKeyString("wait_for_snapshot_completion")
		w.Any(o.WaitForSnapshotCompletion)
	}
	if o.Retry != nil {
		w.MapKeyString("retry")
		w.Any(o.Retry)
	}
}

func logBuildMasterSnapshotsOptions(o *yt.BuildMasterSnapshotsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.SetReadOnly != nil {
		fields = append(fields, log.Any("set_read_only", o.SetReadOnly))
	}
	if o.WaitForSnapshotCompletion != nil {
		fields = append(fields, log.Any("wait_for_snapshot_completion", o.WaitForSnapshotCompletion))
	}
	if o.Retry != nil {
		fields = append(fields, log.Any("retry", o.Retry))
	}
	return fields
}

func writeBuildSnapshotOptions(w *yson.Writer, o *yt.BuildSnapshotOptions) {
	if o == nil {
		return
	}
	if o.CellID != nil {
		w.MapKeyString("cell_id")
		w.Any(o.CellID)
	}
	if o.SetReadOnly != nil {
		w.MapKeyString("set_read_only")
		w.Any(o.SetReadOnly)
	}
	if o.WaitForSnapshotCompletion != nil {
		w.MapKeyString("wait_for_snapshot_completion")
		w.Any(o.WaitForSnapshotCompletion)
	}
}

func logBuildSnapshotOptions(o *yt.BuildSnapshotOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.CellID != nil {
		fields = append(fields, log.Any("cell_id", o.CellID))
	}
	if o.SetReadOnly != nil {
		fields = append(fields, log.Any("set_read_only", o.SetReadOnly))
	}
	if o.WaitForSnapshotCompletion != nil {
		fields = append(fields, log.Any("wait_for_snapshot_completion", o.WaitForSnapshotCompletion))
	}
	return fields
}

func writeRemoveMemberOptions(w *yson.Writer, o *yt.RemoveMemberOptions) {
	if o == nil {
		return
	}
	writeMutatingOptions(w, o.MutatingOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
}

func logRemoveMemberOptions(o *yt.RemoveMemberOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	return fields
}

func writeSetUserPasswordOptions(w *yson.Writer, o *yt.SetUserPasswordOptions) {
	if o == nil {
		return
	}
}

func logSetUserPasswordOptions(o *yt.SetUserPasswordOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeIssueTokenOptions(w *yson.Writer, o *yt.IssueTokenOptions) {
	if o == nil {
		return
	}
}

func logIssueTokenOptions(o *yt.IssueTokenOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeRevokeTokenOptions(w *yson.Writer, o *yt.RevokeTokenOptions) {
	if o == nil {
		return
	}
}

func logRevokeTokenOptions(o *yt.RevokeTokenOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeListUserTokensOptions(w *yson.Writer, o *yt.ListUserTokensOptions) {
	if o == nil {
		return
	}
}

func logListUserTokensOptions(o *yt.ListUserTokensOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeWhoAmIOptions(w *yson.Writer, o *yt.WhoAmIOptions) {
	if o == nil {
		return
	}
}

func logWhoAmIOptions(o *yt.WhoAmIOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeAddMaintenanceOptions(w *yson.Writer, o *yt.AddMaintenanceOptions) {
	if o == nil {
		return
	}
}

func logAddMaintenanceOptions(o *yt.AddMaintenanceOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeRemoveMaintenanceOptions(w *yson.Writer, o *yt.RemoveMaintenanceOptions) {
	if o == nil {
		return
	}
	if o.Mine != nil {
		w.MapKeyString("mine")
		w.Any(o.Mine)
	}
	if o.All != nil {
		w.MapKeyString("all")
		w.Any(o.All)
	}
	if o.User != nil {
		w.MapKeyString("user")
		w.Any(o.User)
	}
	if o.IDs != nil {
		w.MapKeyString("ids")
		w.Any(o.IDs)
	}
	if o.Type != nil {
		w.MapKeyString("type")
		w.Any(o.Type)
	}
}

func logRemoveMaintenanceOptions(o *yt.RemoveMaintenanceOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Mine != nil {
		fields = append(fields, log.Any("mine", o.Mine))
	}
	if o.All != nil {
		fields = append(fields, log.Any("all", o.All))
	}
	if o.User != nil {
		fields = append(fields, log.Any("user", o.User))
	}
	if o.IDs != nil {
		fields = append(fields, log.Any("ids", o.IDs))
	}
	if o.Type != nil {
		fields = append(fields, log.Any("type", o.Type))
	}
	return fields
}

func writeCheckPermissionOptions(w *yson.Writer, o *yt.CheckPermissionOptions) {
	if o == nil {
		return
	}
	if o.Columns != nil {
		w.MapKeyString("columns")
		w.Any(o.Columns)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
	writeMasterReadOptions(w, o.MasterReadOptions)
}

func logCheckPermissionOptions(o *yt.CheckPermissionOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Columns != nil {
		fields = append(fields, log.Any("columns", o.Columns))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	return fields
}

func writeCheckPermissionByACLOptions(w *yson.Writer, o *yt.CheckPermissionByACLOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("ignore_missing_subjects")
	w.Any(o.IgnoreMissingSubjects)
	writePrerequisiteOptions(w, o.PrerequisiteOptions)
	writeMasterReadOptions(w, o.MasterReadOptions)
}

func logCheckPermissionByACLOptions(o *yt.CheckPermissionByACLOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.IgnoreMissingSubjects {
		fields = append(fields, log.Any("ignore_missing_subjects", o.IgnoreMissingSubjects))
	}
	fields = append(fields, logPrerequisiteOptions(o.PrerequisiteOptions)...)
	fields = append(fields, logMasterReadOptions(o.MasterReadOptions)...)
	return fields
}

func writeDisableChunkLocationsOptions(w *yson.Writer, o *yt.DisableChunkLocationsOptions) {
	if o == nil {
		return
	}
}

func logDisableChunkLocationsOptions(o *yt.DisableChunkLocationsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeDestroyChunkLocationsOptions(w *yson.Writer, o *yt.DestroyChunkLocationsOptions) {
	if o == nil {
		return
	}
}

func logDestroyChunkLocationsOptions(o *yt.DestroyChunkLocationsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeResurrectChunkLocationsOptions(w *yson.Writer, o *yt.ResurrectChunkLocationsOptions) {
	if o == nil {
		return
	}
}

func logResurrectChunkLocationsOptions(o *yt.ResurrectChunkLocationsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeRequestRestartOptions(w *yson.Writer, o *yt.RequestRestartOptions) {
	if o == nil {
		return
	}
}

func logRequestRestartOptions(o *yt.RequestRestartOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeLockNodeOptions(w *yson.Writer, o *yt.LockNodeOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("waitable")
	w.Any(o.Waitable)
	if o.ChildKey != nil {
		w.MapKeyString("child_key")
		w.Any(o.ChildKey)
	}
	if o.AttributeKey != nil {
		w.MapKeyString("attribute_key")
		w.Any(o.AttributeKey)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logLockNodeOptions(o *yt.LockNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Waitable {
		fields = append(fields, log.Any("waitable", o.Waitable))
	}
	if o.ChildKey != nil {
		fields = append(fields, log.Any("child_key", o.ChildKey))
	}
	if o.AttributeKey != nil {
		fields = append(fields, log.Any("attribute_key", o.AttributeKey))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeUnlockNodeOptions(w *yson.Writer, o *yt.UnlockNodeOptions) {
	if o == nil {
		return
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logUnlockNodeOptions(o *yt.UnlockNodeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeTabletRangeOptions(w *yson.Writer, o *yt.TabletRangeOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("first_tablet_index")
	w.Any(o.FirstTabletIndex)
	w.MapKeyString("last_tablet_index")
	w.Any(o.LastTabletIndex)
}

func logTabletRangeOptions(o *yt.TabletRangeOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.FirstTabletIndex != 0 {
		fields = append(fields, log.Any("first_tablet_index", o.FirstTabletIndex))
	}
	if o.LastTabletIndex != 0 {
		fields = append(fields, log.Any("last_tablet_index", o.LastTabletIndex))
	}
	return fields
}

func writeMountTableOptions(w *yson.Writer, o *yt.MountTableOptions) {
	if o == nil {
		return
	}
	if o.CellID != nil {
		w.MapKeyString("cell_id")
		w.Any(o.CellID)
	}
	if o.TargetCellIDs != nil {
		w.MapKeyString("target_cell_ids")
		w.Any(o.TargetCellIDs)
	}
	w.MapKeyString("freeze")
	w.Any(o.Freeze)
	writeTabletRangeOptions(w, o.TabletRangeOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logMountTableOptions(o *yt.MountTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.CellID != nil {
		fields = append(fields, log.Any("cell_id", o.CellID))
	}
	if o.TargetCellIDs != nil {
		fields = append(fields, log.Any("target_cell_ids", o.TargetCellIDs))
	}
	if o.Freeze {
		fields = append(fields, log.Any("freeze", o.Freeze))
	}
	fields = append(fields, logTabletRangeOptions(o.TabletRangeOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeUnmountTableOptions(w *yson.Writer, o *yt.UnmountTableOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("force")
	w.Any(o.Force)
	writeTabletRangeOptions(w, o.TabletRangeOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logUnmountTableOptions(o *yt.UnmountTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	fields = append(fields, logTabletRangeOptions(o.TabletRangeOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeRemountTableOptions(w *yson.Writer, o *yt.RemountTableOptions) {
	if o == nil {
		return
	}
	writeTabletRangeOptions(w, o.TabletRangeOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logRemountTableOptions(o *yt.RemountTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTabletRangeOptions(o.TabletRangeOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeFreezeTableOptions(w *yson.Writer, o *yt.FreezeTableOptions) {
	if o == nil {
		return
	}
	writeTabletRangeOptions(w, o.TabletRangeOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logFreezeTableOptions(o *yt.FreezeTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTabletRangeOptions(o.TabletRangeOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeUnfreezeTableOptions(w *yson.Writer, o *yt.UnfreezeTableOptions) {
	if o == nil {
		return
	}
	writeTabletRangeOptions(w, o.TabletRangeOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logUnfreezeTableOptions(o *yt.UnfreezeTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTabletRangeOptions(o.TabletRangeOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeReshardTableOptions(w *yson.Writer, o *yt.ReshardTableOptions) {
	if o == nil {
		return
	}
	if o.PivotKeys != nil {
		w.MapKeyString("pivot_keys")
		w.Any(o.PivotKeys)
	}
	if o.TabletCount != nil {
		w.MapKeyString("tablet_count")
		w.Any(o.TabletCount)
	}
	writeTabletRangeOptions(w, o.TabletRangeOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logReshardTableOptions(o *yt.ReshardTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.PivotKeys != nil {
		fields = append(fields, log.Any("pivot_keys", o.PivotKeys))
	}
	if o.TabletCount != nil {
		fields = append(fields, log.Any("tablet_count", o.TabletCount))
	}
	fields = append(fields, logTabletRangeOptions(o.TabletRangeOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeAlterTableOptions(w *yson.Writer, o *yt.AlterTableOptions) {
	if o == nil {
		return
	}
	if o.Schema != nil {
		w.MapKeyString("schema")
		w.Any(o.Schema)
	}
	if o.Dynamic != nil {
		w.MapKeyString("dynamic")
		w.Any(o.Dynamic)
	}
	if o.UpstreamReplicaID != nil {
		w.MapKeyString("upstream_replica_id")
		w.Any(o.UpstreamReplicaID)
	}
	writeMutatingOptions(w, o.MutatingOptions)
}

func logAlterTableOptions(o *yt.AlterTableOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Schema != nil {
		fields = append(fields, log.Any("schema", o.Schema))
	}
	if o.Dynamic != nil {
		fields = append(fields, log.Any("dynamic", o.Dynamic))
	}
	if o.UpstreamReplicaID != nil {
		fields = append(fields, log.Any("upstream_replica_id", o.UpstreamReplicaID))
	}
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeAlterTableReplicaOptions(w *yson.Writer, o *yt.AlterTableReplicaOptions) {
	if o == nil {
		return
	}
	if o.Enabled != nil {
		w.MapKeyString("enabled")
		w.Any(o.Enabled)
	}
	if o.Mode != nil {
		w.MapKeyString("mode")
		w.Any(o.Mode)
	}
}

func logAlterTableReplicaOptions(o *yt.AlterTableReplicaOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Enabled != nil {
		fields = append(fields, log.Any("enabled", o.Enabled))
	}
	if o.Mode != nil {
		fields = append(fields, log.Any("mode", o.Mode))
	}
	return fields
}

func writeAttachTxOptions(w *yson.Writer, o *yt.AttachTxOptions) {
	if o == nil {
		return
	}
}

func logAttachTxOptions(o *yt.AttachTxOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeLookupRowsOptions(w *yson.Writer, o *yt.LookupRowsOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("keep_missing_rows")
	w.Any(o.KeepMissingRows)
	if o.Timestamp != nil {
		w.MapKeyString("timestamp")
		w.Any(o.Timestamp)
	}
	if o.Columns != nil {
		w.MapKeyString("column_names")
		w.Any(o.Columns)
	}
	writeTransactionOptions(w, o.TransactionOptions)
}

func logLookupRowsOptions(o *yt.LookupRowsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.KeepMissingRows {
		fields = append(fields, log.Any("keep_missing_rows", o.KeepMissingRows))
	}
	if o.Timestamp != nil {
		fields = append(fields, log.Any("timestamp", o.Timestamp))
	}
	if o.Columns != nil {
		fields = append(fields, log.Any("column_names", o.Columns))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	return fields
}

func writeTabletReadOptions(w *yson.Writer, o *yt.TabletReadOptions) {
	if o == nil {
		return
	}
}

func logTabletReadOptions(o *yt.TabletReadOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeMultiplexingBandOptions(w *yson.Writer, o *yt.MultiplexingBandOptions) {
	if o == nil {
		return
	}
}

func logMultiplexingBandOptions(o *yt.MultiplexingBandOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeMultiLookupRowsOptions(w *yson.Writer, o *yt.MultiLookupRowsOptions) {
	if o == nil {
		return
	}
	writeMultiplexingBandOptions(w, o.MultiplexingBandOptions)
	writeTabletReadOptions(w, o.TabletReadOptions)
	writeTransactionOptions(w, o.TransactionOptions)
}

func logMultiLookupRowsOptions(o *yt.MultiLookupRowsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logMultiplexingBandOptions(o.MultiplexingBandOptions)...)
	fields = append(fields, logTabletReadOptions(o.TabletReadOptions)...)
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	return fields
}

func writeInsertRowsOptions(w *yson.Writer, o *yt.InsertRowsOptions) {
	if o == nil {
		return
	}
	if o.Atomicity != nil {
		w.MapKeyString("atomicity")
		w.Any(o.Atomicity)
	}
	if o.RequireSyncReplica != nil {
		w.MapKeyString("require_sync_replica")
		w.Any(o.RequireSyncReplica)
	}
	if o.Update != nil {
		w.MapKeyString("update")
		w.Any(o.Update)
	}
	if o.Aggregate != nil {
		w.MapKeyString("aggregate")
		w.Any(o.Aggregate)
	}
	writeTransactionOptions(w, o.TransactionOptions)
}

func logInsertRowsOptions(o *yt.InsertRowsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Atomicity != nil {
		fields = append(fields, log.Any("atomicity", o.Atomicity))
	}
	if o.RequireSyncReplica != nil {
		fields = append(fields, log.Any("require_sync_replica", o.RequireSyncReplica))
	}
	if o.Update != nil {
		fields = append(fields, log.Any("update", o.Update))
	}
	if o.Aggregate != nil {
		fields = append(fields, log.Any("aggregate", o.Aggregate))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	return fields
}

func writePushQueueProducerOptions(w *yson.Writer, o *yt.PushQueueProducerOptions) {
	if o == nil {
		return
	}
	if o.UserMeta != nil {
		w.MapKeyString("user_meta")
		w.Any(o.UserMeta)
	}
	if o.SequenceNumber != nil {
		w.MapKeyString("sequence_number")
		w.Any(o.SequenceNumber)
	}
	writeTransactionOptions(w, o.TransactionOptions)
}

func logPushQueueProducerOptions(o *yt.PushQueueProducerOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.UserMeta != nil {
		fields = append(fields, log.Any("user_meta", o.UserMeta))
	}
	if o.SequenceNumber != nil {
		fields = append(fields, log.Any("sequence_number", o.SequenceNumber))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	return fields
}

func writeLockRowsOptions(w *yson.Writer, o *yt.LockRowsOptions) {
	if o == nil {
		return
	}
	writeTransactionOptions(w, o.TransactionOptions)
}

func logLockRowsOptions(o *yt.LockRowsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	return fields
}

func writeDeleteRowsOptions(w *yson.Writer, o *yt.DeleteRowsOptions) {
	if o == nil {
		return
	}
	if o.RequireSyncReplica != nil {
		w.MapKeyString("require_sync_replica")
		w.Any(o.RequireSyncReplica)
	}
	writeTransactionOptions(w, o.TransactionOptions)
}

func logDeleteRowsOptions(o *yt.DeleteRowsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.RequireSyncReplica != nil {
		fields = append(fields, log.Any("require_sync_replica", o.RequireSyncReplica))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	return fields
}

func writeSelectRowsOptions(w *yson.Writer, o *yt.SelectRowsOptions) {
	if o == nil {
		return
	}
	if o.FailOnIncompleteResult != nil {
		w.MapKeyString("fail_on_incomplete_result")
		w.Any(o.FailOnIncompleteResult)
	}
	if o.InputRowLimit != nil {
		w.MapKeyString("input_row_limit")
		w.Any(o.InputRowLimit)
	}
	if o.OutputRowLimit != nil {
		w.MapKeyString("output_row_limit")
		w.Any(o.OutputRowLimit)
	}
	if o.UseCanonicalNullRelations != nil {
		w.MapKeyString("use_canonical_null_relations")
		w.Any(o.UseCanonicalNullRelations)
	}
	if o.Timestamp != nil {
		w.MapKeyString("timestamp")
		w.Any(o.Timestamp)
	}
	if o.PlaceholderValues != nil {
		w.MapKeyString("placeholder_values")
		w.Any(o.PlaceholderValues)
	}
	writeTransactionOptions(w, o.TransactionOptions)
	writeTimeoutOptions(w, o.TimeoutOptions)
}

func logSelectRowsOptions(o *yt.SelectRowsOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.FailOnIncompleteResult != nil {
		fields = append(fields, log.Any("fail_on_incomplete_result", o.FailOnIncompleteResult))
	}
	if o.InputRowLimit != nil {
		fields = append(fields, log.Any("input_row_limit", o.InputRowLimit))
	}
	if o.OutputRowLimit != nil {
		fields = append(fields, log.Any("output_row_limit", o.OutputRowLimit))
	}
	if o.UseCanonicalNullRelations != nil {
		fields = append(fields, log.Any("use_canonical_null_relations", o.UseCanonicalNullRelations))
	}
	if o.Timestamp != nil {
		fields = append(fields, log.Any("timestamp", o.Timestamp))
	}
	if o.PlaceholderValues != nil {
		fields = append(fields, log.Any("placeholder_values", o.PlaceholderValues))
	}
	fields = append(fields, logTransactionOptions(o.TransactionOptions)...)
	fields = append(fields, logTimeoutOptions(o.TimeoutOptions)...)
	return fields
}

func writeStartTabletTxOptions(w *yson.Writer, o *yt.StartTabletTxOptions) {
	if o == nil {
		return
	}
	if o.Atomicity != nil {
		w.MapKeyString("atomicity")
		w.Any(o.Atomicity)
	}
	if o.Timeout != nil {
		w.MapKeyString("timeout")
		w.Any(o.Timeout)
	}
	w.MapKeyString("type")
	w.Any(o.Type)
	w.MapKeyString("sticky")
	w.Any(o.Sticky)
}

func logStartTabletTxOptions(o *yt.StartTabletTxOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Atomicity != nil {
		fields = append(fields, log.Any("atomicity", o.Atomicity))
	}
	if o.Timeout != nil {
		fields = append(fields, log.Any("timeout", o.Timeout))
	}
	var zero yt.TxType
	if o.Type != zero {
		fields = append(fields, log.Any("type", o.Type))
	}
	if o.Sticky {
		fields = append(fields, log.Any("sticky", o.Sticky))
	}
	return fields
}

func writeCreateQueueProducerSessionOptions(w *yson.Writer, o *yt.CreateQueueProducerSessionOptions) {
	if o == nil {
		return
	}
	if o.UserMeta != nil {
		w.MapKeyString("user_meta")
		w.Any(o.UserMeta)
	}
	writeTimeoutOptions(w, o.TimeoutOptions)
	writeMutatingOptions(w, o.MutatingOptions)
}

func logCreateQueueProducerSessionOptions(o *yt.CreateQueueProducerSessionOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.UserMeta != nil {
		fields = append(fields, log.Any("user_meta", o.UserMeta))
	}
	fields = append(fields, logTimeoutOptions(o.TimeoutOptions)...)
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

func writeRemoveQueueProducerSessionOptions(w *yson.Writer, o *yt.RemoveQueueProducerSessionOptions) {
	if o == nil {
		return
	}
	writeTimeoutOptions(w, o.TimeoutOptions)
}

func logRemoveQueueProducerSessionOptions(o *yt.RemoveQueueProducerSessionOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logTimeoutOptions(o.TimeoutOptions)...)
	return fields
}

func writeCreateTableBackupOptions(w *yson.Writer, o *yt.CreateTableBackupOptions) {
	if o == nil {
		return
	}
	if o.CheckpointTimestampDelay != nil {
		w.MapKeyString("checkpoint_timestamp_delay")
		w.Any(o.CheckpointTimestampDelay)
	}
	if o.CheckpointCheckPeriod != nil {
		w.MapKeyString("checkpoint_check_period")
		w.Any(o.CheckpointCheckPeriod)
	}
	if o.CheckpointCheckTimeout != nil {
		w.MapKeyString("checkpoint_check_timeout")
		w.Any(o.CheckpointCheckTimeout)
	}
	w.MapKeyString("force")
	w.Any(o.Force)
	writeTimeoutOptions(w, o.TimeoutOptions)
}

func logCreateTableBackupOptions(o *yt.CreateTableBackupOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.CheckpointTimestampDelay != nil {
		fields = append(fields, log.Any("checkpoint_timestamp_delay", o.CheckpointTimestampDelay))
	}
	if o.CheckpointCheckPeriod != nil {
		fields = append(fields, log.Any("checkpoint_check_period", o.CheckpointCheckPeriod))
	}
	if o.CheckpointCheckTimeout != nil {
		fields = append(fields, log.Any("checkpoint_check_timeout", o.CheckpointCheckTimeout))
	}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	fields = append(fields, logTimeoutOptions(o.TimeoutOptions)...)
	return fields
}

func writeRestoreTableBackupOptions(w *yson.Writer, o *yt.RestoreTableBackupOptions) {
	if o == nil {
		return
	}
	w.MapKeyString("force")
	w.Any(o.Force)
	w.MapKeyString("mount")
	w.Any(o.Mount)
	w.MapKeyString("enable_replicas")
	w.Any(o.EnableReplicas)
	writeTimeoutOptions(w, o.TimeoutOptions)
}

func logRestoreTableBackupOptions(o *yt.RestoreTableBackupOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Force {
		fields = append(fields, log.Any("force", o.Force))
	}
	if o.Mount {
		fields = append(fields, log.Any("mount", o.Mount))
	}
	if o.EnableReplicas {
		fields = append(fields, log.Any("enable_replicas", o.EnableReplicas))
	}
	fields = append(fields, logTimeoutOptions(o.TimeoutOptions)...)
	return fields
}

func writeQueryTrackerOptions(w *yson.Writer, o *yt.QueryTrackerOptions) {
	if o == nil {
		return
	}
	if o.Stage != nil {
		w.MapKeyString("stage")
		w.Any(o.Stage)
	}
}

func logQueryTrackerOptions(o *yt.QueryTrackerOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Stage != nil {
		fields = append(fields, log.Any("stage", o.Stage))
	}
	return fields
}

func writeStartQueryOptions(w *yson.Writer, o *yt.StartQueryOptions) {
	if o == nil {
		return
	}
	if o.Settings != nil {
		w.MapKeyString("settings")
		w.Any(o.Settings)
	}
	if o.Draft != nil {
		w.MapKeyString("draft")
		w.Any(o.Draft)
	}
	if o.Annotations != nil {
		w.MapKeyString("annotations")
		w.Any(o.Annotations)
	}
	if o.AccessControlObjects != nil {
		w.MapKeyString("access_control_objects")
		w.Any(o.AccessControlObjects)
	}
	if o.AccessControlObject != nil {
		w.MapKeyString("access_control_object")
		w.Any(o.AccessControlObject)
	}
	if o.Secrets != nil {
		w.MapKeyString("secrets")
		w.Any(o.Secrets)
	}
	writeQueryTrackerOptions(w, o.QueryTrackerOptions)
}

func logStartQueryOptions(o *yt.StartQueryOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Settings != nil {
		fields = append(fields, log.Any("settings", o.Settings))
	}
	if o.Draft != nil {
		fields = append(fields, log.Any("draft", o.Draft))
	}
	if o.Annotations != nil {
		fields = append(fields, log.Any("annotations", o.Annotations))
	}
	if o.AccessControlObjects != nil {
		fields = append(fields, log.Any("access_control_objects", o.AccessControlObjects))
	}
	if o.AccessControlObject != nil {
		fields = append(fields, log.Any("access_control_object", o.AccessControlObject))
	}
	if o.Secrets != nil {
		fields = append(fields, log.Any("secrets", o.Secrets))
	}
	fields = append(fields, logQueryTrackerOptions(o.QueryTrackerOptions)...)
	return fields
}

func writeAbortQueryOptions(w *yson.Writer, o *yt.AbortQueryOptions) {
	if o == nil {
		return
	}
	if o.AbortMessage != nil {
		w.MapKeyString("abort_message")
		w.Any(o.AbortMessage)
	}
	writeQueryTrackerOptions(w, o.QueryTrackerOptions)
}

func logAbortQueryOptions(o *yt.AbortQueryOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.AbortMessage != nil {
		fields = append(fields, log.Any("abort_message", o.AbortMessage))
	}
	fields = append(fields, logQueryTrackerOptions(o.QueryTrackerOptions)...)
	return fields
}

func writeGetQueryOptions(w *yson.Writer, o *yt.GetQueryOptions) {
	if o == nil {
		return
	}
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	if o.Timestamp != nil {
		w.MapKeyString("timestamp")
		w.Any(o.Timestamp)
	}
	writeQueryTrackerOptions(w, o.QueryTrackerOptions)
}

func logGetQueryOptions(o *yt.GetQueryOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	if o.Timestamp != nil {
		fields = append(fields, log.Any("timestamp", o.Timestamp))
	}
	fields = append(fields, logQueryTrackerOptions(o.QueryTrackerOptions)...)
	return fields
}

func writeListQueriesOptions(w *yson.Writer, o *yt.ListQueriesOptions) {
	if o == nil {
		return
	}
	if o.FromTime != nil {
		w.MapKeyString("from_time")
		w.Any(o.FromTime)
	}
	if o.ToTime != nil {
		w.MapKeyString("to_time")
		w.Any(o.ToTime)
	}
	if o.CursorTime != nil {
		w.MapKeyString("cursor_time")
		w.Any(o.CursorTime)
	}
	if o.CursorDirection != nil {
		w.MapKeyString("cursor_direction")
		w.Any(o.CursorDirection)
	}
	if o.UserFilter != nil {
		w.MapKeyString("user_filter")
		w.Any(o.UserFilter)
	}
	if o.StateFilter != nil {
		w.MapKeyString("state_filter")
		w.Any(o.StateFilter)
	}
	if o.EngineFilter != nil {
		w.MapKeyString("engine_filter")
		w.Any(o.EngineFilter)
	}
	if o.SubstrFilter != nil {
		w.MapKeyString("substr_filter")
		w.Any(o.SubstrFilter)
	}
	if o.Limit != nil {
		w.MapKeyString("limit")
		w.Any(o.Limit)
	}
	if o.Attributes != nil {
		w.MapKeyString("attributes")
		w.Any(o.Attributes)
	}
	writeQueryTrackerOptions(w, o.QueryTrackerOptions)
}

func logListQueriesOptions(o *yt.ListQueriesOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.FromTime != nil {
		fields = append(fields, log.Any("from_time", o.FromTime))
	}
	if o.ToTime != nil {
		fields = append(fields, log.Any("to_time", o.ToTime))
	}
	if o.CursorTime != nil {
		fields = append(fields, log.Any("cursor_time", o.CursorTime))
	}
	if o.CursorDirection != nil {
		fields = append(fields, log.Any("cursor_direction", o.CursorDirection))
	}
	if o.UserFilter != nil {
		fields = append(fields, log.Any("user_filter", o.UserFilter))
	}
	if o.StateFilter != nil {
		fields = append(fields, log.Any("state_filter", o.StateFilter))
	}
	if o.EngineFilter != nil {
		fields = append(fields, log.Any("engine_filter", o.EngineFilter))
	}
	if o.SubstrFilter != nil {
		fields = append(fields, log.Any("substr_filter", o.SubstrFilter))
	}
	if o.Limit != nil {
		fields = append(fields, log.Any("limit", o.Limit))
	}
	if o.Attributes != nil {
		fields = append(fields, log.Any("attributes", o.Attributes))
	}
	fields = append(fields, logQueryTrackerOptions(o.QueryTrackerOptions)...)
	return fields
}

func writeGetQueryResultOptions(w *yson.Writer, o *yt.GetQueryResultOptions) {
	if o == nil {
		return
	}
	writeQueryTrackerOptions(w, o.QueryTrackerOptions)
}

func logGetQueryResultOptions(o *yt.GetQueryResultOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	fields = append(fields, logQueryTrackerOptions(o.QueryTrackerOptions)...)
	return fields
}

func writeReadQueryResultOptions(w *yson.Writer, o *yt.ReadQueryResultOptions) {
	if o == nil {
		return
	}
	if o.Columns != nil {
		w.MapKeyString("columns")
		w.Any(o.Columns)
	}
	if o.LowerRowIndex != nil {
		w.MapKeyString("lower_row_index")
		w.Any(o.LowerRowIndex)
	}
	if o.UpperRowIndex != nil {
		w.MapKeyString("upper_row_index")
		w.Any(o.UpperRowIndex)
	}
	writeQueryTrackerOptions(w, o.QueryTrackerOptions)
}

func logReadQueryResultOptions(o *yt.ReadQueryResultOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Columns != nil {
		fields = append(fields, log.Any("columns", o.Columns))
	}
	if o.LowerRowIndex != nil {
		fields = append(fields, log.Any("lower_row_index", o.LowerRowIndex))
	}
	if o.UpperRowIndex != nil {
		fields = append(fields, log.Any("upper_row_index", o.UpperRowIndex))
	}
	fields = append(fields, logQueryTrackerOptions(o.QueryTrackerOptions)...)
	return fields
}

func writeAlterQueryOptions(w *yson.Writer, o *yt.AlterQueryOptions) {
	if o == nil {
		return
	}
	if o.Annotations != nil {
		w.MapKeyString("annotations")
		w.Any(o.Annotations)
	}
	if o.AccessControlObjects != nil {
		w.MapKeyString("access_control_objects")
		w.Any(o.AccessControlObjects)
	}
	if o.AccessControlObject != nil {
		w.MapKeyString("access_control_object")
		w.Any(o.AccessControlObject)
	}
	writeQueryTrackerOptions(w, o.QueryTrackerOptions)
}

func logAlterQueryOptions(o *yt.AlterQueryOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Annotations != nil {
		fields = append(fields, log.Any("annotations", o.Annotations))
	}
	if o.AccessControlObjects != nil {
		fields = append(fields, log.Any("access_control_objects", o.AccessControlObjects))
	}
	if o.AccessControlObject != nil {
		fields = append(fields, log.Any("access_control_object", o.AccessControlObject))
	}
	fields = append(fields, logQueryTrackerOptions(o.QueryTrackerOptions)...)
	return fields
}

func writeLocateSkynetShareOptions(w *yson.Writer, o *yt.LocateSkynetShareOptions) {
	if o == nil {
		return
	}
}

func logLocateSkynetShareOptions(o *yt.LocateSkynetShareOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeGenerateTimestampOptions(w *yson.Writer, o *yt.GenerateTimestampOptions) {
	if o == nil {
		return
	}
}

func logGenerateTimestampOptions(o *yt.GenerateTimestampOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

func writeGetInSyncReplicasOptions(w *yson.Writer, o *yt.GetInSyncReplicasOptions) {
	if o == nil {
		return
	}
}

func logGetInSyncReplicasOptions(o *yt.GetInSyncReplicasOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	return fields
}

type CreateNodeParams struct {
	verb    Verb
	path    ypath.YPath
	typ     yt.NodeType
	options *yt.CreateNodeOptions
}

func NewCreateNodeParams(
	path ypath.YPath,
	typ yt.NodeType,
	options *yt.CreateNodeOptions,
) *CreateNodeParams {
	if options == nil {
		options = &yt.CreateNodeOptions{}
	}
	optionsCopy := *options
	return &CreateNodeParams{
		Verb("create"),
		path,
		typ,
		&optionsCopy,
	}
}

func (p *CreateNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CreateNodeParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *CreateNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
		log.Any("typ", p.typ),
	}
	fields = append(fields, logCreateNodeOptions(p.options)...)
	return fields
}

func (p *CreateNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	w.MapKeyString("type")
	w.Any(p.typ)
	writeCreateNodeOptions(w, p.options)
}

func (p *CreateNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *CreateNodeParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

func (p *CreateNodeParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *CreateNodeParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type CreateObjectParams struct {
	verb    Verb
	typ     yt.NodeType
	options *yt.CreateObjectOptions
}

func NewCreateObjectParams(
	typ yt.NodeType,
	options *yt.CreateObjectOptions,
) *CreateObjectParams {
	if options == nil {
		options = &yt.CreateObjectOptions{}
	}
	optionsCopy := *options
	return &CreateObjectParams{
		Verb("create"),
		typ,
		&optionsCopy,
	}
}

func (p *CreateObjectParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CreateObjectParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *CreateObjectParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("typ", p.typ),
	}
	fields = append(fields, logCreateObjectOptions(p.options)...)
	return fields
}

func (p *CreateObjectParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("type")
	w.Any(p.typ)
	writeCreateObjectOptions(w, p.options)
}

func (p *CreateObjectParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

func (p *CreateObjectParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

func (p *CreateObjectParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type NodeExistsParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.NodeExistsOptions
}

func NewNodeExistsParams(
	path ypath.YPath,
	options *yt.NodeExistsOptions,
) *NodeExistsParams {
	if options == nil {
		options = &yt.NodeExistsOptions{}
	}
	optionsCopy := *options
	return &NodeExistsParams{
		Verb("exists"),
		path,
		&optionsCopy,
	}
}

func (p *NodeExistsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *NodeExistsParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *NodeExistsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logNodeExistsOptions(p.options)...)
	return fields
}

func (p *NodeExistsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeNodeExistsOptions(w, p.options)
}

func (p *NodeExistsParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

func (p *NodeExistsParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *NodeExistsParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

func (p *NodeExistsParams) ReadRetryOptions() **yt.ReadRetryOptions {
	return &p.options.ReadRetryOptions
}

type RemoveNodeParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.RemoveNodeOptions
}

func NewRemoveNodeParams(
	path ypath.YPath,
	options *yt.RemoveNodeOptions,
) *RemoveNodeParams {
	if options == nil {
		options = &yt.RemoveNodeOptions{}
	}
	optionsCopy := *options
	return &RemoveNodeParams{
		Verb("remove"),
		path,
		&optionsCopy,
	}
}

func (p *RemoveNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *RemoveNodeParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *RemoveNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logRemoveNodeOptions(p.options)...)
	return fields
}

func (p *RemoveNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeRemoveNodeOptions(w, p.options)
}

func (p *RemoveNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *RemoveNodeParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

func (p *RemoveNodeParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

func (p *RemoveNodeParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type GetNodeParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.GetNodeOptions
}

func NewGetNodeParams(
	path ypath.YPath,
	options *yt.GetNodeOptions,
) *GetNodeParams {
	if options == nil {
		options = &yt.GetNodeOptions{}
	}
	optionsCopy := *options
	return &GetNodeParams{
		Verb("get"),
		path,
		&optionsCopy,
	}
}

func (p *GetNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetNodeParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *GetNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logGetNodeOptions(p.options)...)
	return fields
}

func (p *GetNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeGetNodeOptions(w, p.options)
}

func (p *GetNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *GetNodeParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

func (p *GetNodeParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

func (p *GetNodeParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

func (p *GetNodeParams) ReadRetryOptions() **yt.ReadRetryOptions {
	return &p.options.ReadRetryOptions
}

type SetNodeParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.SetNodeOptions
}

func NewSetNodeParams(
	path ypath.YPath,
	options *yt.SetNodeOptions,
) *SetNodeParams {
	if options == nil {
		options = &yt.SetNodeOptions{}
	}
	optionsCopy := *options
	return &SetNodeParams{
		Verb("set"),
		path,
		&optionsCopy,
	}
}

func (p *SetNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *SetNodeParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *SetNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logSetNodeOptions(p.options)...)
	return fields
}

func (p *SetNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeSetNodeOptions(w, p.options)
}

func (p *SetNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *SetNodeParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

func (p *SetNodeParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *SetNodeParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type MultisetAttributesParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.MultisetAttributesOptions
}

func NewMultisetAttributesParams(
	path ypath.YPath,
	options *yt.MultisetAttributesOptions,
) *MultisetAttributesParams {
	if options == nil {
		options = &yt.MultisetAttributesOptions{}
	}
	optionsCopy := *options
	return &MultisetAttributesParams{
		Verb("multiset_attributes"),
		path,
		&optionsCopy,
	}
}

func (p *MultisetAttributesParams) HTTPVerb() Verb {
	return p.verb
}
func (p *MultisetAttributesParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *MultisetAttributesParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logMultisetAttributesOptions(p.options)...)
	return fields
}

func (p *MultisetAttributesParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeMultisetAttributesOptions(w, p.options)
}

func (p *MultisetAttributesParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *MultisetAttributesParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

func (p *MultisetAttributesParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *MultisetAttributesParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type ListNodeParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.ListNodeOptions
}

func NewListNodeParams(
	path ypath.YPath,
	options *yt.ListNodeOptions,
) *ListNodeParams {
	if options == nil {
		options = &yt.ListNodeOptions{}
	}
	optionsCopy := *options
	return &ListNodeParams{
		Verb("list"),
		path,
		&optionsCopy,
	}
}

func (p *ListNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ListNodeParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *ListNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logListNodeOptions(p.options)...)
	return fields
}

func (p *ListNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeListNodeOptions(w, p.options)
}

func (p *ListNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *ListNodeParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

func (p *ListNodeParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

func (p *ListNodeParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

func (p *ListNodeParams) ReadRetryOptions() **yt.ReadRetryOptions {
	return &p.options.ReadRetryOptions
}

type CopyNodeParams struct {
	verb    Verb
	src     ypath.YPath
	dst     ypath.YPath
	options *yt.CopyNodeOptions
}

func NewCopyNodeParams(
	src ypath.YPath,
	dst ypath.YPath,
	options *yt.CopyNodeOptions,
) *CopyNodeParams {
	if options == nil {
		options = &yt.CopyNodeOptions{}
	}
	optionsCopy := *options
	return &CopyNodeParams{
		Verb("copy"),
		src,
		dst,
		&optionsCopy,
	}
}

func (p *CopyNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CopyNodeParams) YPath() (ypath.YPath, bool) {
	return p.src, true
}
func (p *CopyNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("src", p.src),
		log.Any("dst", p.dst),
	}
	fields = append(fields, logCopyNodeOptions(p.options)...)
	return fields
}

func (p *CopyNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("source_path")
	w.Any(p.src)
	w.MapKeyString("destination_path")
	w.Any(p.dst)
	writeCopyNodeOptions(w, p.options)
}

func (p *CopyNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *CopyNodeParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *CopyNodeParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type MoveNodeParams struct {
	verb    Verb
	src     ypath.YPath
	dst     ypath.YPath
	options *yt.MoveNodeOptions
}

func NewMoveNodeParams(
	src ypath.YPath,
	dst ypath.YPath,
	options *yt.MoveNodeOptions,
) *MoveNodeParams {
	if options == nil {
		options = &yt.MoveNodeOptions{}
	}
	optionsCopy := *options
	return &MoveNodeParams{
		Verb("move"),
		src,
		dst,
		&optionsCopy,
	}
}

func (p *MoveNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *MoveNodeParams) YPath() (ypath.YPath, bool) {
	return p.src, true
}
func (p *MoveNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("src", p.src),
		log.Any("dst", p.dst),
	}
	fields = append(fields, logMoveNodeOptions(p.options)...)
	return fields
}

func (p *MoveNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("source_path")
	w.Any(p.src)
	w.MapKeyString("destination_path")
	w.Any(p.dst)
	writeMoveNodeOptions(w, p.options)
}

func (p *MoveNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *MoveNodeParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *MoveNodeParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type LinkNodeParams struct {
	verb    Verb
	target  ypath.YPath
	link    ypath.YPath
	options *yt.LinkNodeOptions
}

func NewLinkNodeParams(
	target ypath.YPath,
	link ypath.YPath,
	options *yt.LinkNodeOptions,
) *LinkNodeParams {
	if options == nil {
		options = &yt.LinkNodeOptions{}
	}
	optionsCopy := *options
	return &LinkNodeParams{
		Verb("link"),
		target,
		link,
		&optionsCopy,
	}
}

func (p *LinkNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *LinkNodeParams) YPath() (ypath.YPath, bool) {
	return p.target, true
}
func (p *LinkNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("target", p.target),
		log.Any("link", p.link),
	}
	fields = append(fields, logLinkNodeOptions(p.options)...)
	return fields
}

func (p *LinkNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("target_path")
	w.Any(p.target)
	w.MapKeyString("link_path")
	w.Any(p.link)
	writeLinkNodeOptions(w, p.options)
}

func (p *LinkNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *LinkNodeParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *LinkNodeParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type StartTxParams struct {
	verb    Verb
	options *yt.StartTxOptions
}

func NewStartTxParams(
	options *yt.StartTxOptions,
) *StartTxParams {
	if options == nil {
		options = &yt.StartTxOptions{}
	}
	optionsCopy := *options
	return &StartTxParams{
		Verb("start_transaction"),
		&optionsCopy,
	}
}

func (p *StartTxParams) HTTPVerb() Verb {
	return p.verb
}
func (p *StartTxParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *StartTxParams) Log() []log.Field {
	fields := []log.Field{}
	fields = append(fields, logStartTxOptions(p.options)...)
	return fields
}

func (p *StartTxParams) MarshalHTTP(w *yson.Writer) {
	writeStartTxOptions(w, p.options)
}

func (p *StartTxParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *StartTxParams) ReadRetryOptions() **yt.ReadRetryOptions {
	return &p.options.ReadRetryOptions
}

type StartTabletTxParams struct {
	verb    Verb
	options *yt.StartTabletTxOptions
}

func NewStartTabletTxParams(
	options *yt.StartTabletTxOptions,
) *StartTabletTxParams {
	if options == nil {
		options = &yt.StartTabletTxOptions{}
	}
	optionsCopy := *options
	return &StartTabletTxParams{
		Verb("start_transaction"),
		&optionsCopy,
	}
}

func (p *StartTabletTxParams) HTTPVerb() Verb {
	return p.verb
}
func (p *StartTabletTxParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *StartTabletTxParams) Log() []log.Field {
	fields := []log.Field{}
	fields = append(fields, logStartTabletTxOptions(p.options)...)
	return fields
}

func (p *StartTabletTxParams) MarshalHTTP(w *yson.Writer) {
	writeStartTabletTxOptions(w, p.options)
}

type PingTxParams struct {
	verb    Verb
	id      yt.TxID
	options *yt.PingTxOptions
}

func NewPingTxParams(
	id yt.TxID,
	options *yt.PingTxOptions,
) *PingTxParams {
	if options == nil {
		options = &yt.PingTxOptions{}
	}
	optionsCopy := *options
	return &PingTxParams{
		Verb("ping_transaction"),
		id,
		&optionsCopy,
	}
}

func (p *PingTxParams) HTTPVerb() Verb {
	return p.verb
}
func (p *PingTxParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *PingTxParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
	}
	fields = append(fields, logPingTxOptions(p.options)...)
	return fields
}

func (p *PingTxParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("transaction_id")
	w.Any(p.id)
	writePingTxOptions(w, p.options)
}

func (p *PingTxParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

type AbortTxParams struct {
	verb    Verb
	id      yt.TxID
	options *yt.AbortTxOptions
}

func NewAbortTxParams(
	id yt.TxID,
	options *yt.AbortTxOptions,
) *AbortTxParams {
	if options == nil {
		options = &yt.AbortTxOptions{}
	}
	optionsCopy := *options
	return &AbortTxParams{
		Verb("abort_transaction"),
		id,
		&optionsCopy,
	}
}

func (p *AbortTxParams) HTTPVerb() Verb {
	return p.verb
}
func (p *AbortTxParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *AbortTxParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
	}
	fields = append(fields, logAbortTxOptions(p.options)...)
	return fields
}

func (p *AbortTxParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("transaction_id")
	w.Any(p.id)
	writeAbortTxOptions(w, p.options)
}

func (p *AbortTxParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *AbortTxParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *AbortTxParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type CommitTxParams struct {
	verb    Verb
	id      yt.TxID
	options *yt.CommitTxOptions
}

func NewCommitTxParams(
	id yt.TxID,
	options *yt.CommitTxOptions,
) *CommitTxParams {
	if options == nil {
		options = &yt.CommitTxOptions{}
	}
	optionsCopy := *options
	return &CommitTxParams{
		Verb("commit_transaction"),
		id,
		&optionsCopy,
	}
}

func (p *CommitTxParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CommitTxParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *CommitTxParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
	}
	fields = append(fields, logCommitTxOptions(p.options)...)
	return fields
}

func (p *CommitTxParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("transaction_id")
	w.Any(p.id)
	writeCommitTxOptions(w, p.options)
}

func (p *CommitTxParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *CommitTxParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

func (p *CommitTxParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

type WriteFileParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.WriteFileOptions
}

func NewWriteFileParams(
	path ypath.YPath,
	options *yt.WriteFileOptions,
) *WriteFileParams {
	if options == nil {
		options = &yt.WriteFileOptions{}
	}
	optionsCopy := *options
	return &WriteFileParams{
		Verb("write_file"),
		path,
		&optionsCopy,
	}
}

func (p *WriteFileParams) HTTPVerb() Verb {
	return p.verb
}
func (p *WriteFileParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *WriteFileParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logWriteFileOptions(p.options)...)
	return fields
}

func (p *WriteFileParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeWriteFileOptions(w, p.options)
}

func (p *WriteFileParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *WriteFileParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type ReadFileParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.ReadFileOptions
}

func NewReadFileParams(
	path ypath.YPath,
	options *yt.ReadFileOptions,
) *ReadFileParams {
	if options == nil {
		options = &yt.ReadFileOptions{}
	}
	optionsCopy := *options
	return &ReadFileParams{
		Verb("read_file"),
		path,
		&optionsCopy,
	}
}

func (p *ReadFileParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ReadFileParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *ReadFileParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logReadFileOptions(p.options)...)
	return fields
}

func (p *ReadFileParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeReadFileOptions(w, p.options)
}

func (p *ReadFileParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *ReadFileParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

type PutFileToCacheParams struct {
	verb    Verb
	path    ypath.YPath
	md5     string
	options *yt.PutFileToCacheOptions
}

func NewPutFileToCacheParams(
	path ypath.YPath,
	md5 string,
	options *yt.PutFileToCacheOptions,
) *PutFileToCacheParams {
	if options == nil {
		options = &yt.PutFileToCacheOptions{}
	}
	optionsCopy := *options
	return &PutFileToCacheParams{
		Verb("put_file_to_cache"),
		path,
		md5,
		&optionsCopy,
	}
}

func (p *PutFileToCacheParams) HTTPVerb() Verb {
	return p.verb
}
func (p *PutFileToCacheParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *PutFileToCacheParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
		log.Any("md5", p.md5),
	}
	fields = append(fields, logPutFileToCacheOptions(p.options)...)
	return fields
}

func (p *PutFileToCacheParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	w.MapKeyString("md5")
	w.Any(p.md5)
	writePutFileToCacheOptions(w, p.options)
}

func (p *PutFileToCacheParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

func (p *PutFileToCacheParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *PutFileToCacheParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type GetFileFromCacheParams struct {
	verb    Verb
	md5     string
	options *yt.GetFileFromCacheOptions
}

func NewGetFileFromCacheParams(
	md5 string,
	options *yt.GetFileFromCacheOptions,
) *GetFileFromCacheParams {
	if options == nil {
		options = &yt.GetFileFromCacheOptions{}
	}
	optionsCopy := *options
	return &GetFileFromCacheParams{
		Verb("get_file_from_cache"),
		md5,
		&optionsCopy,
	}
}

func (p *GetFileFromCacheParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetFileFromCacheParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *GetFileFromCacheParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("md5", p.md5),
	}
	fields = append(fields, logGetFileFromCacheOptions(p.options)...)
	return fields
}

func (p *GetFileFromCacheParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("md5")
	w.Any(p.md5)
	writeGetFileFromCacheOptions(w, p.options)
}

func (p *GetFileFromCacheParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

func (p *GetFileFromCacheParams) ReadRetryOptions() **yt.ReadRetryOptions {
	return &p.options.ReadRetryOptions
}

type WriteTableParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.WriteTableOptions
}

func NewWriteTableParams(
	path ypath.YPath,
	options *yt.WriteTableOptions,
) *WriteTableParams {
	if options == nil {
		options = &yt.WriteTableOptions{}
	}
	optionsCopy := *options
	return &WriteTableParams{
		Verb("write_table"),
		path,
		&optionsCopy,
	}
}

func (p *WriteTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *WriteTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *WriteTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logWriteTableOptions(p.options)...)
	return fields
}

func (p *WriteTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeWriteTableOptions(w, p.options)
}

func (p *WriteTableParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *WriteTableParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

type ReadTableParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.ReadTableOptions
}

func NewReadTableParams(
	path ypath.YPath,
	options *yt.ReadTableOptions,
) *ReadTableParams {
	if options == nil {
		options = &yt.ReadTableOptions{}
	}
	optionsCopy := *options
	return &ReadTableParams{
		Verb("read_table"),
		path,
		&optionsCopy,
	}
}

func (p *ReadTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ReadTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *ReadTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logReadTableOptions(p.options)...)
	return fields
}

func (p *ReadTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeReadTableOptions(w, p.options)
}

func (p *ReadTableParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *ReadTableParams) AccessTrackingOptions() **yt.AccessTrackingOptions {
	return &p.options.AccessTrackingOptions
}

type StartOperationParams struct {
	verb    Verb
	opType  yt.OperationType
	spec    any
	options *yt.StartOperationOptions
}

func NewStartOperationParams(
	opType yt.OperationType,
	spec any,
	options *yt.StartOperationOptions,
) *StartOperationParams {
	if options == nil {
		options = &yt.StartOperationOptions{}
	}
	optionsCopy := *options
	return &StartOperationParams{
		Verb("start_operation"),
		opType,
		spec,
		&optionsCopy,
	}
}

func (p *StartOperationParams) HTTPVerb() Verb {
	return p.verb
}
func (p *StartOperationParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *StartOperationParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opType", p.opType),
	}
	fields = append(fields, logStartOperationOptions(p.options)...)
	return fields
}

func (p *StartOperationParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_type")
	w.Any(p.opType)
	w.MapKeyString("spec")
	w.Any(p.spec)
	writeStartOperationOptions(w, p.options)
}

func (p *StartOperationParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *StartOperationParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type AbortOperationParams struct {
	verb    Verb
	opID    yt.OperationID
	options *yt.AbortOperationOptions
}

func NewAbortOperationParams(
	opID yt.OperationID,
	options *yt.AbortOperationOptions,
) *AbortOperationParams {
	if options == nil {
		options = &yt.AbortOperationOptions{}
	}
	optionsCopy := *options
	return &AbortOperationParams{
		Verb("abort_operation"),
		opID,
		&optionsCopy,
	}
}

func (p *AbortOperationParams) HTTPVerb() Verb {
	return p.verb
}
func (p *AbortOperationParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *AbortOperationParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
	}
	fields = append(fields, logAbortOperationOptions(p.options)...)
	return fields
}

func (p *AbortOperationParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	writeAbortOperationOptions(w, p.options)
}

type SuspendOperationParams struct {
	verb    Verb
	opID    yt.OperationID
	options *yt.SuspendOperationOptions
}

func NewSuspendOperationParams(
	opID yt.OperationID,
	options *yt.SuspendOperationOptions,
) *SuspendOperationParams {
	if options == nil {
		options = &yt.SuspendOperationOptions{}
	}
	optionsCopy := *options
	return &SuspendOperationParams{
		Verb("suspend_operation"),
		opID,
		&optionsCopy,
	}
}

func (p *SuspendOperationParams) HTTPVerb() Verb {
	return p.verb
}
func (p *SuspendOperationParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *SuspendOperationParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
	}
	fields = append(fields, logSuspendOperationOptions(p.options)...)
	return fields
}

func (p *SuspendOperationParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	writeSuspendOperationOptions(w, p.options)
}

type ResumeOperationParams struct {
	verb    Verb
	opID    yt.OperationID
	options *yt.ResumeOperationOptions
}

func NewResumeOperationParams(
	opID yt.OperationID,
	options *yt.ResumeOperationOptions,
) *ResumeOperationParams {
	if options == nil {
		options = &yt.ResumeOperationOptions{}
	}
	optionsCopy := *options
	return &ResumeOperationParams{
		Verb("resume_operation"),
		opID,
		&optionsCopy,
	}
}

func (p *ResumeOperationParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ResumeOperationParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *ResumeOperationParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
	}
	fields = append(fields, logResumeOperationOptions(p.options)...)
	return fields
}

func (p *ResumeOperationParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	writeResumeOperationOptions(w, p.options)
}

type CompleteOperationParams struct {
	verb    Verb
	opID    yt.OperationID
	options *yt.CompleteOperationOptions
}

func NewCompleteOperationParams(
	opID yt.OperationID,
	options *yt.CompleteOperationOptions,
) *CompleteOperationParams {
	if options == nil {
		options = &yt.CompleteOperationOptions{}
	}
	optionsCopy := *options
	return &CompleteOperationParams{
		Verb("complete_operation"),
		opID,
		&optionsCopy,
	}
}

func (p *CompleteOperationParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CompleteOperationParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *CompleteOperationParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
	}
	fields = append(fields, logCompleteOperationOptions(p.options)...)
	return fields
}

func (p *CompleteOperationParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	writeCompleteOperationOptions(w, p.options)
}

type UpdateOperationParametersParams struct {
	verb    Verb
	opID    yt.OperationID
	params  any
	options *yt.UpdateOperationParametersOptions
}

func NewUpdateOperationParametersParams(
	opID yt.OperationID,
	params any,
	options *yt.UpdateOperationParametersOptions,
) *UpdateOperationParametersParams {
	if options == nil {
		options = &yt.UpdateOperationParametersOptions{}
	}
	optionsCopy := *options
	return &UpdateOperationParametersParams{
		Verb("update_operation_parameters"),
		opID,
		params,
		&optionsCopy,
	}
}

func (p *UpdateOperationParametersParams) HTTPVerb() Verb {
	return p.verb
}
func (p *UpdateOperationParametersParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *UpdateOperationParametersParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
		log.Any("params", p.params),
	}
	fields = append(fields, logUpdateOperationParametersOptions(p.options)...)
	return fields
}

func (p *UpdateOperationParametersParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	w.MapKeyString("parameters")
	w.Any(p.params)
	writeUpdateOperationParametersOptions(w, p.options)
}

type GetOperationParams struct {
	verb    Verb
	opID    yt.OperationID
	options *yt.GetOperationOptions
}

func NewGetOperationParams(
	opID yt.OperationID,
	options *yt.GetOperationOptions,
) *GetOperationParams {
	if options == nil {
		options = &yt.GetOperationOptions{}
	}
	optionsCopy := *options
	return &GetOperationParams{
		Verb("get_operation"),
		opID,
		&optionsCopy,
	}
}

func (p *GetOperationParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetOperationParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *GetOperationParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
	}
	fields = append(fields, logGetOperationOptions(p.options)...)
	return fields
}

func (p *GetOperationParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	writeGetOperationOptions(w, p.options)
}

func (p *GetOperationParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

func (p *GetOperationParams) ReadRetryOptions() **yt.ReadRetryOptions {
	return &p.options.ReadRetryOptions
}

type GetOperationByAliasParams struct {
	verb    Verb
	alias   string
	options *yt.GetOperationOptions
}

func NewGetOperationByAliasParams(
	alias string,
	options *yt.GetOperationOptions,
) *GetOperationByAliasParams {
	if options == nil {
		options = &yt.GetOperationOptions{}
	}
	optionsCopy := *options
	return &GetOperationByAliasParams{
		Verb("get_operation"),
		alias,
		&optionsCopy,
	}
}

func (p *GetOperationByAliasParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetOperationByAliasParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *GetOperationByAliasParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("alias", p.alias),
	}
	fields = append(fields, logGetOperationOptions(p.options)...)
	return fields
}

func (p *GetOperationByAliasParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_alias")
	w.Any(p.alias)
	writeGetOperationOptions(w, p.options)
}

type ListOperationsParams struct {
	verb    Verb
	options *yt.ListOperationsOptions
}

func NewListOperationsParams(
	options *yt.ListOperationsOptions,
) *ListOperationsParams {
	if options == nil {
		options = &yt.ListOperationsOptions{}
	}
	optionsCopy := *options
	return &ListOperationsParams{
		Verb("list_operations"),
		&optionsCopy,
	}
}

func (p *ListOperationsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ListOperationsParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *ListOperationsParams) Log() []log.Field {
	fields := []log.Field{}
	fields = append(fields, logListOperationsOptions(p.options)...)
	return fields
}

func (p *ListOperationsParams) MarshalHTTP(w *yson.Writer) {
	writeListOperationsOptions(w, p.options)
}

func (p *ListOperationsParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

func (p *ListOperationsParams) ReadRetryOptions() **yt.ReadRetryOptions {
	return &p.options.ReadRetryOptions
}

type ListJobsParams struct {
	verb    Verb
	opID    yt.OperationID
	options *yt.ListJobsOptions
}

func NewListJobsParams(
	opID yt.OperationID,
	options *yt.ListJobsOptions,
) *ListJobsParams {
	if options == nil {
		options = &yt.ListJobsOptions{}
	}
	optionsCopy := *options
	return &ListJobsParams{
		Verb("list_jobs"),
		opID,
		&optionsCopy,
	}
}

func (p *ListJobsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ListJobsParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *ListJobsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
	}
	fields = append(fields, logListJobsOptions(p.options)...)
	return fields
}

func (p *ListJobsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	writeListJobsOptions(w, p.options)
}

type GetJobParams struct {
	verb    Verb
	opID    yt.OperationID
	jobID   yt.JobID
	options *yt.GetJobOptions
}

func NewGetJobParams(
	opID yt.OperationID,
	jobID yt.JobID,
	options *yt.GetJobOptions,
) *GetJobParams {
	if options == nil {
		options = &yt.GetJobOptions{}
	}
	optionsCopy := *options
	return &GetJobParams{
		Verb("get_job"),
		opID,
		jobID,
		&optionsCopy,
	}
}

func (p *GetJobParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetJobParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *GetJobParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
		log.Any("jobID", p.jobID),
	}
	fields = append(fields, logGetJobOptions(p.options)...)
	return fields
}

func (p *GetJobParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	w.MapKeyString("job_id")
	w.Any(p.jobID)
	writeGetJobOptions(w, p.options)
}

type GetJobStderrParams struct {
	verb    Verb
	opID    yt.OperationID
	jobID   yt.JobID
	options *yt.GetJobStderrOptions
}

func NewGetJobStderrParams(
	opID yt.OperationID,
	jobID yt.JobID,
	options *yt.GetJobStderrOptions,
) *GetJobStderrParams {
	if options == nil {
		options = &yt.GetJobStderrOptions{}
	}
	optionsCopy := *options
	return &GetJobStderrParams{
		Verb("get_job_stderr"),
		opID,
		jobID,
		&optionsCopy,
	}
}

func (p *GetJobStderrParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetJobStderrParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *GetJobStderrParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("opID", p.opID),
		log.Any("jobID", p.jobID),
	}
	fields = append(fields, logGetJobStderrOptions(p.options)...)
	return fields
}

func (p *GetJobStderrParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("operation_id")
	w.Any(p.opID)
	w.MapKeyString("job_id")
	w.Any(p.jobID)
	writeGetJobStderrOptions(w, p.options)
}

type AddMemberParams struct {
	verb    Verb
	group   string
	member  string
	options *yt.AddMemberOptions
}

func NewAddMemberParams(
	group string,
	member string,
	options *yt.AddMemberOptions,
) *AddMemberParams {
	if options == nil {
		options = &yt.AddMemberOptions{}
	}
	optionsCopy := *options
	return &AddMemberParams{
		Verb("add_member"),
		group,
		member,
		&optionsCopy,
	}
}

func (p *AddMemberParams) HTTPVerb() Verb {
	return p.verb
}
func (p *AddMemberParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *AddMemberParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("group", p.group),
		log.Any("member", p.member),
	}
	fields = append(fields, logAddMemberOptions(p.options)...)
	return fields
}

func (p *AddMemberParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("group")
	w.Any(p.group)
	w.MapKeyString("member")
	w.Any(p.member)
	writeAddMemberOptions(w, p.options)
}

func (p *AddMemberParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *AddMemberParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type BuildMasterSnapshotsParams struct {
	verb    Verb
	options *yt.BuildMasterSnapshotsOptions
}

func NewBuildMasterSnapshotsParams(
	options *yt.BuildMasterSnapshotsOptions,
) *BuildMasterSnapshotsParams {
	if options == nil {
		options = &yt.BuildMasterSnapshotsOptions{}
	}
	optionsCopy := *options
	return &BuildMasterSnapshotsParams{
		Verb("build_master_snapshots"),
		&optionsCopy,
	}
}

func (p *BuildMasterSnapshotsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *BuildMasterSnapshotsParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *BuildMasterSnapshotsParams) Log() []log.Field {
	fields := []log.Field{}
	fields = append(fields, logBuildMasterSnapshotsOptions(p.options)...)
	return fields
}

func (p *BuildMasterSnapshotsParams) MarshalHTTP(w *yson.Writer) {
	writeBuildMasterSnapshotsOptions(w, p.options)
}

type BuildSnapshotParams struct {
	verb    Verb
	options *yt.BuildSnapshotOptions
}

func NewBuildSnapshotParams(
	options *yt.BuildSnapshotOptions,
) *BuildSnapshotParams {
	if options == nil {
		options = &yt.BuildSnapshotOptions{}
	}
	optionsCopy := *options
	return &BuildSnapshotParams{
		Verb("build_snapshot"),
		&optionsCopy,
	}
}

func (p *BuildSnapshotParams) HTTPVerb() Verb {
	return p.verb
}
func (p *BuildSnapshotParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *BuildSnapshotParams) Log() []log.Field {
	fields := []log.Field{}
	fields = append(fields, logBuildSnapshotOptions(p.options)...)
	return fields
}

func (p *BuildSnapshotParams) MarshalHTTP(w *yson.Writer) {
	writeBuildSnapshotOptions(w, p.options)
}

type RemoveMemberParams struct {
	verb    Verb
	group   string
	member  string
	options *yt.RemoveMemberOptions
}

func NewRemoveMemberParams(
	group string,
	member string,
	options *yt.RemoveMemberOptions,
) *RemoveMemberParams {
	if options == nil {
		options = &yt.RemoveMemberOptions{}
	}
	optionsCopy := *options
	return &RemoveMemberParams{
		Verb("remove_member"),
		group,
		member,
		&optionsCopy,
	}
}

func (p *RemoveMemberParams) HTTPVerb() Verb {
	return p.verb
}
func (p *RemoveMemberParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *RemoveMemberParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("group", p.group),
		log.Any("member", p.member),
	}
	fields = append(fields, logRemoveMemberOptions(p.options)...)
	return fields
}

func (p *RemoveMemberParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("group")
	w.Any(p.group)
	w.MapKeyString("member")
	w.Any(p.member)
	writeRemoveMemberOptions(w, p.options)
}

func (p *RemoveMemberParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

func (p *RemoveMemberParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

type AddMaintenanceParams struct {
	verb            Verb
	component       yt.MaintenanceComponent
	address         string
	maintenanceType yt.MaintenanceType
	comment         string
	options         *yt.AddMaintenanceOptions
}

func NewAddMaintenanceParams(
	component yt.MaintenanceComponent,
	address string,
	maintenanceType yt.MaintenanceType,
	comment string,
	options *yt.AddMaintenanceOptions,
) *AddMaintenanceParams {
	if options == nil {
		options = &yt.AddMaintenanceOptions{}
	}
	optionsCopy := *options
	return &AddMaintenanceParams{
		Verb("add_maintenance"),
		component,
		address,
		maintenanceType,
		comment,
		&optionsCopy,
	}
}

func (p *AddMaintenanceParams) HTTPVerb() Verb {
	return p.verb
}
func (p *AddMaintenanceParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *AddMaintenanceParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("component", p.component),
		log.Any("address", p.address),
		log.Any("maintenanceType", p.maintenanceType),
		log.Any("comment", p.comment),
	}
	fields = append(fields, logAddMaintenanceOptions(p.options)...)
	return fields
}

func (p *AddMaintenanceParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("component")
	w.Any(p.component)
	w.MapKeyString("address")
	w.Any(p.address)
	w.MapKeyString("type")
	w.Any(p.maintenanceType)
	w.MapKeyString("comment")
	w.Any(p.comment)
	writeAddMaintenanceOptions(w, p.options)
}

type RemoveMaintenanceParams struct {
	verb      Verb
	component yt.MaintenanceComponent
	address   string
	options   *yt.RemoveMaintenanceOptions
}

func NewRemoveMaintenanceParams(
	component yt.MaintenanceComponent,
	address string,
	options *yt.RemoveMaintenanceOptions,
) *RemoveMaintenanceParams {
	if options == nil {
		options = &yt.RemoveMaintenanceOptions{}
	}
	optionsCopy := *options
	return &RemoveMaintenanceParams{
		Verb("remove_maintenance"),
		component,
		address,
		&optionsCopy,
	}
}

func (p *RemoveMaintenanceParams) HTTPVerb() Verb {
	return p.verb
}
func (p *RemoveMaintenanceParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *RemoveMaintenanceParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("component", p.component),
		log.Any("address", p.address),
	}
	fields = append(fields, logRemoveMaintenanceOptions(p.options)...)
	return fields
}

func (p *RemoveMaintenanceParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("component")
	w.Any(p.component)
	w.MapKeyString("address")
	w.Any(p.address)
	writeRemoveMaintenanceOptions(w, p.options)
}

type TransferAccountResourcesParams struct {
	verb          Verb
	srcAccount    string
	dstAccount    string
	resourceDelta any
	options       *yt.TransferAccountResourcesOptions
}

func NewTransferAccountResourcesParams(
	srcAccount string,
	dstAccount string,
	resourceDelta any,
	options *yt.TransferAccountResourcesOptions,
) *TransferAccountResourcesParams {
	if options == nil {
		options = &yt.TransferAccountResourcesOptions{}
	}
	optionsCopy := *options
	return &TransferAccountResourcesParams{
		Verb("transfer_account_resources"),
		srcAccount,
		dstAccount,
		resourceDelta,
		&optionsCopy,
	}
}

func (p *TransferAccountResourcesParams) HTTPVerb() Verb {
	return p.verb
}
func (p *TransferAccountResourcesParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *TransferAccountResourcesParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("srcAccount", p.srcAccount),
		log.Any("dstAccount", p.dstAccount),
		log.Any("resourceDelta", p.resourceDelta),
	}
	fields = append(fields, logTransferAccountResourcesOptions(p.options)...)
	return fields
}

func (p *TransferAccountResourcesParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("source_account")
	w.Any(p.srcAccount)
	w.MapKeyString("destination_account")
	w.Any(p.dstAccount)
	w.MapKeyString("resource_delta")
	w.Any(p.resourceDelta)
	writeTransferAccountResourcesOptions(w, p.options)
}

func (p *TransferAccountResourcesParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type TransferPoolResourcesParams struct {
	verb          Verb
	srcPool       string
	dstPool       string
	poolTree      string
	resourceDelta any
	options       *yt.TransferPoolResourcesOptions
}

func NewTransferPoolResourcesParams(
	srcPool string,
	dstPool string,
	poolTree string,
	resourceDelta any,
	options *yt.TransferPoolResourcesOptions,
) *TransferPoolResourcesParams {
	if options == nil {
		options = &yt.TransferPoolResourcesOptions{}
	}
	optionsCopy := *options
	return &TransferPoolResourcesParams{
		Verb("transfer_pool_resources"),
		srcPool,
		dstPool,
		poolTree,
		resourceDelta,
		&optionsCopy,
	}
}

func (p *TransferPoolResourcesParams) HTTPVerb() Verb {
	return p.verb
}
func (p *TransferPoolResourcesParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *TransferPoolResourcesParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("srcPool", p.srcPool),
		log.Any("dstPool", p.dstPool),
		log.Any("poolTree", p.poolTree),
		log.Any("resourceDelta", p.resourceDelta),
	}
	fields = append(fields, logTransferPoolResourcesOptions(p.options)...)
	return fields
}

func (p *TransferPoolResourcesParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("source_pool")
	w.Any(p.srcPool)
	w.MapKeyString("destination_pool")
	w.Any(p.dstPool)
	w.MapKeyString("pool_tree")
	w.Any(p.poolTree)
	w.MapKeyString("resource_delta")
	w.Any(p.resourceDelta)
	writeTransferPoolResourcesOptions(w, p.options)
}

func (p *TransferPoolResourcesParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type CheckPermissionParams struct {
	verb       Verb
	user       string
	permission yt.Permission
	path       ypath.YPath
	options    *yt.CheckPermissionOptions
}

func NewCheckPermissionParams(
	user string,
	permission yt.Permission,
	path ypath.YPath,
	options *yt.CheckPermissionOptions,
) *CheckPermissionParams {
	if options == nil {
		options = &yt.CheckPermissionOptions{}
	}
	optionsCopy := *options
	return &CheckPermissionParams{
		Verb("check_permission"),
		user,
		permission,
		path,
		&optionsCopy,
	}
}

func (p *CheckPermissionParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CheckPermissionParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *CheckPermissionParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("user", p.user),
		log.Any("permission", p.permission),
		log.Any("path", p.path),
	}
	fields = append(fields, logCheckPermissionOptions(p.options)...)
	return fields
}

func (p *CheckPermissionParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("user")
	w.Any(p.user)
	w.MapKeyString("permission")
	w.Any(p.permission)
	w.MapKeyString("path")
	w.Any(p.path)
	writeCheckPermissionOptions(w, p.options)
}

func (p *CheckPermissionParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *CheckPermissionParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

func (p *CheckPermissionParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

type CheckPermissionByACLParams struct {
	verb       Verb
	user       string
	permission yt.Permission
	ACL        []yt.ACE
	options    *yt.CheckPermissionByACLOptions
}

func NewCheckPermissionByACLParams(
	user string,
	permission yt.Permission,
	ACL []yt.ACE,
	options *yt.CheckPermissionByACLOptions,
) *CheckPermissionByACLParams {
	if options == nil {
		options = &yt.CheckPermissionByACLOptions{}
	}
	optionsCopy := *options
	return &CheckPermissionByACLParams{
		Verb("check_permission_by_acl"),
		user,
		permission,
		ACL,
		&optionsCopy,
	}
}

func (p *CheckPermissionByACLParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CheckPermissionByACLParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *CheckPermissionByACLParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("user", p.user),
		log.Any("permission", p.permission),
		log.Any("ACL", p.ACL),
	}
	fields = append(fields, logCheckPermissionByACLOptions(p.options)...)
	return fields
}

func (p *CheckPermissionByACLParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("user")
	w.Any(p.user)
	w.MapKeyString("permission")
	w.Any(p.permission)
	w.MapKeyString("acl")
	w.Any(p.ACL)
	writeCheckPermissionByACLOptions(w, p.options)
}

func (p *CheckPermissionByACLParams) PrerequisiteOptions() **yt.PrerequisiteOptions {
	return &p.options.PrerequisiteOptions
}

func (p *CheckPermissionByACLParams) MasterReadOptions() **yt.MasterReadOptions {
	return &p.options.MasterReadOptions
}

type DisableChunkLocationsParams struct {
	verb          Verb
	nodeAddress   string
	locationUUIDs []guid.GUID
	options       *yt.DisableChunkLocationsOptions
}

func NewDisableChunkLocationsParams(
	nodeAddress string,
	locationUUIDs []guid.GUID,
	options *yt.DisableChunkLocationsOptions,
) *DisableChunkLocationsParams {
	if options == nil {
		options = &yt.DisableChunkLocationsOptions{}
	}
	optionsCopy := *options
	return &DisableChunkLocationsParams{
		Verb("disable_chunk_locations"),
		nodeAddress,
		locationUUIDs,
		&optionsCopy,
	}
}

func (p *DisableChunkLocationsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *DisableChunkLocationsParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *DisableChunkLocationsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("nodeAddress", p.nodeAddress),
		log.Any("locationUUIDs", p.locationUUIDs),
	}
	fields = append(fields, logDisableChunkLocationsOptions(p.options)...)
	return fields
}

func (p *DisableChunkLocationsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("node_address")
	w.Any(p.nodeAddress)
	w.MapKeyString("location_uuids")
	w.Any(p.locationUUIDs)
	writeDisableChunkLocationsOptions(w, p.options)
}

type DestroyChunkLocationsParams struct {
	verb                 Verb
	nodeAddress          string
	recoverUnlinkedDisks bool
	locationUUIDs        []guid.GUID
	options              *yt.DestroyChunkLocationsOptions
}

func NewDestroyChunkLocationsParams(
	nodeAddress string,
	recoverUnlinkedDisks bool,
	locationUUIDs []guid.GUID,
	options *yt.DestroyChunkLocationsOptions,
) *DestroyChunkLocationsParams {
	if options == nil {
		options = &yt.DestroyChunkLocationsOptions{}
	}
	optionsCopy := *options
	return &DestroyChunkLocationsParams{
		Verb("destroy_chunk_locations"),
		nodeAddress,
		recoverUnlinkedDisks,
		locationUUIDs,
		&optionsCopy,
	}
}

func (p *DestroyChunkLocationsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *DestroyChunkLocationsParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *DestroyChunkLocationsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("nodeAddress", p.nodeAddress),
		log.Any("recoverUnlinkedDisks", p.recoverUnlinkedDisks),
		log.Any("locationUUIDs", p.locationUUIDs),
	}
	fields = append(fields, logDestroyChunkLocationsOptions(p.options)...)
	return fields
}

func (p *DestroyChunkLocationsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("node_address")
	w.Any(p.nodeAddress)
	w.MapKeyString("recover_unlinked_disks")
	w.Any(p.recoverUnlinkedDisks)
	w.MapKeyString("location_uuids")
	w.Any(p.locationUUIDs)
	writeDestroyChunkLocationsOptions(w, p.options)
}

type ResurrectChunkLocationsParams struct {
	verb          Verb
	nodeAddress   string
	locationUUIDs []guid.GUID
	options       *yt.ResurrectChunkLocationsOptions
}

func NewResurrectChunkLocationsParams(
	nodeAddress string,
	locationUUIDs []guid.GUID,
	options *yt.ResurrectChunkLocationsOptions,
) *ResurrectChunkLocationsParams {
	if options == nil {
		options = &yt.ResurrectChunkLocationsOptions{}
	}
	optionsCopy := *options
	return &ResurrectChunkLocationsParams{
		Verb("resurrect_chunk_locations"),
		nodeAddress,
		locationUUIDs,
		&optionsCopy,
	}
}

func (p *ResurrectChunkLocationsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ResurrectChunkLocationsParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *ResurrectChunkLocationsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("nodeAddress", p.nodeAddress),
		log.Any("locationUUIDs", p.locationUUIDs),
	}
	fields = append(fields, logResurrectChunkLocationsOptions(p.options)...)
	return fields
}

func (p *ResurrectChunkLocationsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("node_address")
	w.Any(p.nodeAddress)
	w.MapKeyString("location_uuids")
	w.Any(p.locationUUIDs)
	writeResurrectChunkLocationsOptions(w, p.options)
}

type RequestRestartParams struct {
	verb        Verb
	nodeAddress string
	options     *yt.RequestRestartOptions
}

func NewRequestRestartParams(
	nodeAddress string,
	options *yt.RequestRestartOptions,
) *RequestRestartParams {
	if options == nil {
		options = &yt.RequestRestartOptions{}
	}
	optionsCopy := *options
	return &RequestRestartParams{
		Verb("request_restart"),
		nodeAddress,
		&optionsCopy,
	}
}

func (p *RequestRestartParams) HTTPVerb() Verb {
	return p.verb
}
func (p *RequestRestartParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *RequestRestartParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("nodeAddress", p.nodeAddress),
	}
	fields = append(fields, logRequestRestartOptions(p.options)...)
	return fields
}

func (p *RequestRestartParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("node_address")
	w.Any(p.nodeAddress)
	writeRequestRestartOptions(w, p.options)
}

type LockNodeParams struct {
	verb    Verb
	path    ypath.YPath
	mode    yt.LockMode
	options *yt.LockNodeOptions
}

func NewLockNodeParams(
	path ypath.YPath,
	mode yt.LockMode,
	options *yt.LockNodeOptions,
) *LockNodeParams {
	if options == nil {
		options = &yt.LockNodeOptions{}
	}
	optionsCopy := *options
	return &LockNodeParams{
		Verb("lock"),
		path,
		mode,
		&optionsCopy,
	}
}

func (p *LockNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *LockNodeParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *LockNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
		log.Any("mode", p.mode),
	}
	fields = append(fields, logLockNodeOptions(p.options)...)
	return fields
}

func (p *LockNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	w.MapKeyString("mode")
	w.Any(p.mode)
	writeLockNodeOptions(w, p.options)
}

func (p *LockNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *LockNodeParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type UnlockNodeParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.UnlockNodeOptions
}

func NewUnlockNodeParams(
	path ypath.YPath,
	options *yt.UnlockNodeOptions,
) *UnlockNodeParams {
	if options == nil {
		options = &yt.UnlockNodeOptions{}
	}
	optionsCopy := *options
	return &UnlockNodeParams{
		Verb("unlock"),
		path,
		&optionsCopy,
	}
}

func (p *UnlockNodeParams) HTTPVerb() Verb {
	return p.verb
}
func (p *UnlockNodeParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *UnlockNodeParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logUnlockNodeOptions(p.options)...)
	return fields
}

func (p *UnlockNodeParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeUnlockNodeOptions(w, p.options)
}

func (p *UnlockNodeParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *UnlockNodeParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type SelectRowsParams struct {
	verb    Verb
	query   string
	options *yt.SelectRowsOptions
}

func NewSelectRowsParams(
	query string,
	options *yt.SelectRowsOptions,
) *SelectRowsParams {
	if options == nil {
		options = &yt.SelectRowsOptions{}
	}
	optionsCopy := *options
	return &SelectRowsParams{
		Verb("select_rows"),
		query,
		&optionsCopy,
	}
}

func (p *SelectRowsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *SelectRowsParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *SelectRowsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("query", p.query),
	}
	fields = append(fields, logSelectRowsOptions(p.options)...)
	return fields
}

func (p *SelectRowsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("query")
	w.Any(p.query)
	writeSelectRowsOptions(w, p.options)
}

func (p *SelectRowsParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

func (p *SelectRowsParams) TimeoutOptions() **yt.TimeoutOptions {
	return &p.options.TimeoutOptions
}

type LookupRowsParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.LookupRowsOptions
}

func NewLookupRowsParams(
	path ypath.Path,
	options *yt.LookupRowsOptions,
) *LookupRowsParams {
	if options == nil {
		options = &yt.LookupRowsOptions{}
	}
	optionsCopy := *options
	return &LookupRowsParams{
		Verb("lookup_rows"),
		path,
		&optionsCopy,
	}
}

func (p *LookupRowsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *LookupRowsParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *LookupRowsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logLookupRowsOptions(p.options)...)
	return fields
}

func (p *LookupRowsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeLookupRowsOptions(w, p.options)
}

func (p *LookupRowsParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

type LockRowsParams struct {
	verb     Verb
	path     ypath.Path
	locks    []string
	lockType yt.LockType
	options  *yt.LockRowsOptions
}

func NewLockRowsParams(
	path ypath.Path,
	locks []string,
	lockType yt.LockType,
	options *yt.LockRowsOptions,
) *LockRowsParams {
	if options == nil {
		options = &yt.LockRowsOptions{}
	}
	optionsCopy := *options
	return &LockRowsParams{
		Verb("lock_rows"),
		path,
		locks,
		lockType,
		&optionsCopy,
	}
}

func (p *LockRowsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *LockRowsParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *LockRowsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
		log.Any("locks", p.locks),
		log.Any("lockType", p.lockType),
	}
	fields = append(fields, logLockRowsOptions(p.options)...)
	return fields
}

func (p *LockRowsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	w.MapKeyString("locks")
	w.Any(p.locks)
	w.MapKeyString("lock_type")
	w.Any(p.lockType)
	writeLockRowsOptions(w, p.options)
}

func (p *LockRowsParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

type InsertRowsParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.InsertRowsOptions
}

func NewInsertRowsParams(
	path ypath.Path,
	options *yt.InsertRowsOptions,
) *InsertRowsParams {
	if options == nil {
		options = &yt.InsertRowsOptions{}
	}
	optionsCopy := *options
	return &InsertRowsParams{
		Verb("insert_rows"),
		path,
		&optionsCopy,
	}
}

func (p *InsertRowsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *InsertRowsParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *InsertRowsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logInsertRowsOptions(p.options)...)
	return fields
}

func (p *InsertRowsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeInsertRowsOptions(w, p.options)
}

func (p *InsertRowsParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

type DeleteRowsParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.DeleteRowsOptions
}

func NewDeleteRowsParams(
	path ypath.Path,
	options *yt.DeleteRowsOptions,
) *DeleteRowsParams {
	if options == nil {
		options = &yt.DeleteRowsOptions{}
	}
	optionsCopy := *options
	return &DeleteRowsParams{
		Verb("delete_rows"),
		path,
		&optionsCopy,
	}
}

func (p *DeleteRowsParams) HTTPVerb() Verb {
	return p.verb
}
func (p *DeleteRowsParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *DeleteRowsParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logDeleteRowsOptions(p.options)...)
	return fields
}

func (p *DeleteRowsParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeDeleteRowsOptions(w, p.options)
}

func (p *DeleteRowsParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

type PushQueueProducerParams struct {
	verb         Verb
	producerPath ypath.Path
	queuePath    ypath.Path
	sessionID    string
	epoch        int64
	options      *yt.PushQueueProducerOptions
}

func NewPushQueueProducerParams(
	producerPath ypath.Path,
	queuePath ypath.Path,
	sessionID string,
	epoch int64,
	options *yt.PushQueueProducerOptions,
) *PushQueueProducerParams {
	if options == nil {
		options = &yt.PushQueueProducerOptions{}
	}
	optionsCopy := *options
	return &PushQueueProducerParams{
		Verb("push_queue_producer"),
		producerPath,
		queuePath,
		sessionID,
		epoch,
		&optionsCopy,
	}
}

func (p *PushQueueProducerParams) HTTPVerb() Verb {
	return p.verb
}
func (p *PushQueueProducerParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *PushQueueProducerParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("producerPath", p.producerPath),
		log.Any("queuePath", p.queuePath),
		log.Any("sessionID", p.sessionID),
		log.Any("epoch", p.epoch),
	}
	fields = append(fields, logPushQueueProducerOptions(p.options)...)
	return fields
}

func (p *PushQueueProducerParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("producer_path")
	w.Any(p.producerPath)
	w.MapKeyString("queue_path")
	w.Any(p.queuePath)
	w.MapKeyString("session_id")
	w.Any(p.sessionID)
	w.MapKeyString("epoch")
	w.Any(p.epoch)
	writePushQueueProducerOptions(w, p.options)
}

func (p *PushQueueProducerParams) TransactionOptions() **yt.TransactionOptions {
	return &p.options.TransactionOptions
}

type CreateQueueProducerSessionParams struct {
	verb         Verb
	producerPath ypath.Path
	queuePath    ypath.Path
	sessionID    string
	options      *yt.CreateQueueProducerSessionOptions
}

func NewCreateQueueProducerSessionParams(
	producerPath ypath.Path,
	queuePath ypath.Path,
	sessionID string,
	options *yt.CreateQueueProducerSessionOptions,
) *CreateQueueProducerSessionParams {
	if options == nil {
		options = &yt.CreateQueueProducerSessionOptions{}
	}
	optionsCopy := *options
	return &CreateQueueProducerSessionParams{
		Verb("create_queue_producer_session"),
		producerPath,
		queuePath,
		sessionID,
		&optionsCopy,
	}
}

func (p *CreateQueueProducerSessionParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CreateQueueProducerSessionParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *CreateQueueProducerSessionParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("producerPath", p.producerPath),
		log.Any("queuePath", p.queuePath),
		log.Any("sessionID", p.sessionID),
	}
	fields = append(fields, logCreateQueueProducerSessionOptions(p.options)...)
	return fields
}

func (p *CreateQueueProducerSessionParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("producer_path")
	w.Any(p.producerPath)
	w.MapKeyString("queue_path")
	w.Any(p.queuePath)
	w.MapKeyString("session_id")
	w.Any(p.sessionID)
	writeCreateQueueProducerSessionOptions(w, p.options)
}

func (p *CreateQueueProducerSessionParams) TimeoutOptions() **yt.TimeoutOptions {
	return &p.options.TimeoutOptions
}

func (p *CreateQueueProducerSessionParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type RemoveQueueProducerSessionParams struct {
	verb         Verb
	producerPath ypath.Path
	queuePath    ypath.Path
	sessionID    string
	options      *yt.RemoveQueueProducerSessionOptions
}

func NewRemoveQueueProducerSessionParams(
	producerPath ypath.Path,
	queuePath ypath.Path,
	sessionID string,
	options *yt.RemoveQueueProducerSessionOptions,
) *RemoveQueueProducerSessionParams {
	if options == nil {
		options = &yt.RemoveQueueProducerSessionOptions{}
	}
	optionsCopy := *options
	return &RemoveQueueProducerSessionParams{
		Verb("remove_queue_producer_session"),
		producerPath,
		queuePath,
		sessionID,
		&optionsCopy,
	}
}

func (p *RemoveQueueProducerSessionParams) HTTPVerb() Verb {
	return p.verb
}
func (p *RemoveQueueProducerSessionParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *RemoveQueueProducerSessionParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("producerPath", p.producerPath),
		log.Any("queuePath", p.queuePath),
		log.Any("sessionID", p.sessionID),
	}
	fields = append(fields, logRemoveQueueProducerSessionOptions(p.options)...)
	return fields
}

func (p *RemoveQueueProducerSessionParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("producer_path")
	w.Any(p.producerPath)
	w.MapKeyString("queue_path")
	w.Any(p.queuePath)
	w.MapKeyString("session_id")
	w.Any(p.sessionID)
	writeRemoveQueueProducerSessionOptions(w, p.options)
}

func (p *RemoveQueueProducerSessionParams) TimeoutOptions() **yt.TimeoutOptions {
	return &p.options.TimeoutOptions
}

type MountTableParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.MountTableOptions
}

func NewMountTableParams(
	path ypath.Path,
	options *yt.MountTableOptions,
) *MountTableParams {
	if options == nil {
		options = &yt.MountTableOptions{}
	}
	optionsCopy := *options
	return &MountTableParams{
		Verb("mount_table"),
		path,
		&optionsCopy,
	}
}

func (p *MountTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *MountTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *MountTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logMountTableOptions(p.options)...)
	return fields
}

func (p *MountTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeMountTableOptions(w, p.options)
}

func (p *MountTableParams) TabletRangeOptions() **yt.TabletRangeOptions {
	return &p.options.TabletRangeOptions
}

func (p *MountTableParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type UnmountTableParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.UnmountTableOptions
}

func NewUnmountTableParams(
	path ypath.Path,
	options *yt.UnmountTableOptions,
) *UnmountTableParams {
	if options == nil {
		options = &yt.UnmountTableOptions{}
	}
	optionsCopy := *options
	return &UnmountTableParams{
		Verb("unmount_table"),
		path,
		&optionsCopy,
	}
}

func (p *UnmountTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *UnmountTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *UnmountTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logUnmountTableOptions(p.options)...)
	return fields
}

func (p *UnmountTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeUnmountTableOptions(w, p.options)
}

func (p *UnmountTableParams) TabletRangeOptions() **yt.TabletRangeOptions {
	return &p.options.TabletRangeOptions
}

func (p *UnmountTableParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type RemountTableParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.RemountTableOptions
}

func NewRemountTableParams(
	path ypath.Path,
	options *yt.RemountTableOptions,
) *RemountTableParams {
	if options == nil {
		options = &yt.RemountTableOptions{}
	}
	optionsCopy := *options
	return &RemountTableParams{
		Verb("remount_table"),
		path,
		&optionsCopy,
	}
}

func (p *RemountTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *RemountTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *RemountTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logRemountTableOptions(p.options)...)
	return fields
}

func (p *RemountTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeRemountTableOptions(w, p.options)
}

func (p *RemountTableParams) TabletRangeOptions() **yt.TabletRangeOptions {
	return &p.options.TabletRangeOptions
}

func (p *RemountTableParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type ReshardTableParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.ReshardTableOptions
}

func NewReshardTableParams(
	path ypath.Path,
	options *yt.ReshardTableOptions,
) *ReshardTableParams {
	if options == nil {
		options = &yt.ReshardTableOptions{}
	}
	optionsCopy := *options
	return &ReshardTableParams{
		Verb("reshard_table"),
		path,
		&optionsCopy,
	}
}

func (p *ReshardTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ReshardTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *ReshardTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logReshardTableOptions(p.options)...)
	return fields
}

func (p *ReshardTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeReshardTableOptions(w, p.options)
}

func (p *ReshardTableParams) TabletRangeOptions() **yt.TabletRangeOptions {
	return &p.options.TabletRangeOptions
}

func (p *ReshardTableParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type AlterTableParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.AlterTableOptions
}

func NewAlterTableParams(
	path ypath.Path,
	options *yt.AlterTableOptions,
) *AlterTableParams {
	if options == nil {
		options = &yt.AlterTableOptions{}
	}
	optionsCopy := *options
	return &AlterTableParams{
		Verb("alter_table"),
		path,
		&optionsCopy,
	}
}

func (p *AlterTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *AlterTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *AlterTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logAlterTableOptions(p.options)...)
	return fields
}

func (p *AlterTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeAlterTableOptions(w, p.options)
}

func (p *AlterTableParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type FreezeTableParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.FreezeTableOptions
}

func NewFreezeTableParams(
	path ypath.Path,
	options *yt.FreezeTableOptions,
) *FreezeTableParams {
	if options == nil {
		options = &yt.FreezeTableOptions{}
	}
	optionsCopy := *options
	return &FreezeTableParams{
		Verb("freeze_table"),
		path,
		&optionsCopy,
	}
}

func (p *FreezeTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *FreezeTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *FreezeTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logFreezeTableOptions(p.options)...)
	return fields
}

func (p *FreezeTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeFreezeTableOptions(w, p.options)
}

func (p *FreezeTableParams) TabletRangeOptions() **yt.TabletRangeOptions {
	return &p.options.TabletRangeOptions
}

func (p *FreezeTableParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type UnfreezeTableParams struct {
	verb    Verb
	path    ypath.Path
	options *yt.UnfreezeTableOptions
}

func NewUnfreezeTableParams(
	path ypath.Path,
	options *yt.UnfreezeTableOptions,
) *UnfreezeTableParams {
	if options == nil {
		options = &yt.UnfreezeTableOptions{}
	}
	optionsCopy := *options
	return &UnfreezeTableParams{
		Verb("unfreeze_table"),
		path,
		&optionsCopy,
	}
}

func (p *UnfreezeTableParams) HTTPVerb() Verb {
	return p.verb
}
func (p *UnfreezeTableParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *UnfreezeTableParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logUnfreezeTableOptions(p.options)...)
	return fields
}

func (p *UnfreezeTableParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeUnfreezeTableOptions(w, p.options)
}

func (p *UnfreezeTableParams) TabletRangeOptions() **yt.TabletRangeOptions {
	return &p.options.TabletRangeOptions
}

func (p *UnfreezeTableParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}

type AlterTableReplicaParams struct {
	verb    Verb
	id      yt.NodeID
	options *yt.AlterTableReplicaOptions
}

func NewAlterTableReplicaParams(
	id yt.NodeID,
	options *yt.AlterTableReplicaOptions,
) *AlterTableReplicaParams {
	if options == nil {
		options = &yt.AlterTableReplicaOptions{}
	}
	optionsCopy := *options
	return &AlterTableReplicaParams{
		Verb("alter_table_replica"),
		id,
		&optionsCopy,
	}
}

func (p *AlterTableReplicaParams) HTTPVerb() Verb {
	return p.verb
}
func (p *AlterTableReplicaParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *AlterTableReplicaParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
	}
	fields = append(fields, logAlterTableReplicaOptions(p.options)...)
	return fields
}

func (p *AlterTableReplicaParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("replica_id")
	w.Any(p.id)
	writeAlterTableReplicaOptions(w, p.options)
}

type CreateTableBackupParams struct {
	verb     Verb
	manifest yt.BackupManifest
	options  *yt.CreateTableBackupOptions
}

func NewCreateTableBackupParams(
	manifest yt.BackupManifest,
	options *yt.CreateTableBackupOptions,
) *CreateTableBackupParams {
	if options == nil {
		options = &yt.CreateTableBackupOptions{}
	}
	optionsCopy := *options
	return &CreateTableBackupParams{
		Verb("create_table_backup"),
		manifest,
		&optionsCopy,
	}
}

func (p *CreateTableBackupParams) HTTPVerb() Verb {
	return p.verb
}
func (p *CreateTableBackupParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *CreateTableBackupParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("manifest", p.manifest),
	}
	fields = append(fields, logCreateTableBackupOptions(p.options)...)
	return fields
}

func (p *CreateTableBackupParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("manifest")
	w.Any(p.manifest)
	writeCreateTableBackupOptions(w, p.options)
}

func (p *CreateTableBackupParams) TimeoutOptions() **yt.TimeoutOptions {
	return &p.options.TimeoutOptions
}

type RestoreTableBackupParams struct {
	verb     Verb
	manifest yt.BackupManifest
	options  *yt.RestoreTableBackupOptions
}

func NewRestoreTableBackupParams(
	manifest yt.BackupManifest,
	options *yt.RestoreTableBackupOptions,
) *RestoreTableBackupParams {
	if options == nil {
		options = &yt.RestoreTableBackupOptions{}
	}
	optionsCopy := *options
	return &RestoreTableBackupParams{
		Verb("restore_table_backup"),
		manifest,
		&optionsCopy,
	}
}

func (p *RestoreTableBackupParams) HTTPVerb() Verb {
	return p.verb
}
func (p *RestoreTableBackupParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *RestoreTableBackupParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("manifest", p.manifest),
	}
	fields = append(fields, logRestoreTableBackupOptions(p.options)...)
	return fields
}

func (p *RestoreTableBackupParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("manifest")
	w.Any(p.manifest)
	writeRestoreTableBackupOptions(w, p.options)
}

func (p *RestoreTableBackupParams) TimeoutOptions() **yt.TimeoutOptions {
	return &p.options.TimeoutOptions
}

type StartQueryParams struct {
	verb    Verb
	engine  yt.QueryEngine
	query   string
	options *yt.StartQueryOptions
}

func NewStartQueryParams(
	engine yt.QueryEngine,
	query string,
	options *yt.StartQueryOptions,
) *StartQueryParams {
	if options == nil {
		options = &yt.StartQueryOptions{}
	}
	optionsCopy := *options
	return &StartQueryParams{
		Verb("start_query"),
		engine,
		query,
		&optionsCopy,
	}
}

func (p *StartQueryParams) HTTPVerb() Verb {
	return p.verb
}
func (p *StartQueryParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *StartQueryParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("engine", p.engine),
		log.Any("query", p.query),
	}
	fields = append(fields, logStartQueryOptions(p.options)...)
	return fields
}

func (p *StartQueryParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("engine")
	w.Any(p.engine)
	w.MapKeyString("query")
	w.Any(p.query)
	writeStartQueryOptions(w, p.options)
}

func (p *StartQueryParams) QueryTrackerOptions() **yt.QueryTrackerOptions {
	return &p.options.QueryTrackerOptions
}

type AbortQueryParams struct {
	verb    Verb
	id      yt.QueryID
	options *yt.AbortQueryOptions
}

func NewAbortQueryParams(
	id yt.QueryID,
	options *yt.AbortQueryOptions,
) *AbortQueryParams {
	if options == nil {
		options = &yt.AbortQueryOptions{}
	}
	optionsCopy := *options
	return &AbortQueryParams{
		Verb("abort_query"),
		id,
		&optionsCopy,
	}
}

func (p *AbortQueryParams) HTTPVerb() Verb {
	return p.verb
}
func (p *AbortQueryParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *AbortQueryParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
	}
	fields = append(fields, logAbortQueryOptions(p.options)...)
	return fields
}

func (p *AbortQueryParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("query_id")
	w.Any(p.id)
	writeAbortQueryOptions(w, p.options)
}

func (p *AbortQueryParams) QueryTrackerOptions() **yt.QueryTrackerOptions {
	return &p.options.QueryTrackerOptions
}

type GetQueryParams struct {
	verb    Verb
	id      yt.QueryID
	options *yt.GetQueryOptions
}

func NewGetQueryParams(
	id yt.QueryID,
	options *yt.GetQueryOptions,
) *GetQueryParams {
	if options == nil {
		options = &yt.GetQueryOptions{}
	}
	optionsCopy := *options
	return &GetQueryParams{
		Verb("get_query"),
		id,
		&optionsCopy,
	}
}

func (p *GetQueryParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetQueryParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *GetQueryParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
	}
	fields = append(fields, logGetQueryOptions(p.options)...)
	return fields
}

func (p *GetQueryParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("query_id")
	w.Any(p.id)
	writeGetQueryOptions(w, p.options)
}

func (p *GetQueryParams) QueryTrackerOptions() **yt.QueryTrackerOptions {
	return &p.options.QueryTrackerOptions
}

type ListQueriesParams struct {
	verb    Verb
	options *yt.ListQueriesOptions
}

func NewListQueriesParams(
	options *yt.ListQueriesOptions,
) *ListQueriesParams {
	if options == nil {
		options = &yt.ListQueriesOptions{}
	}
	optionsCopy := *options
	return &ListQueriesParams{
		Verb("list_queries"),
		&optionsCopy,
	}
}

func (p *ListQueriesParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ListQueriesParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *ListQueriesParams) Log() []log.Field {
	fields := []log.Field{}
	fields = append(fields, logListQueriesOptions(p.options)...)
	return fields
}

func (p *ListQueriesParams) MarshalHTTP(w *yson.Writer) {
	writeListQueriesOptions(w, p.options)
}

func (p *ListQueriesParams) QueryTrackerOptions() **yt.QueryTrackerOptions {
	return &p.options.QueryTrackerOptions
}

type GetQueryResultParams struct {
	verb        Verb
	id          yt.QueryID
	resultIndex int64
	options     *yt.GetQueryResultOptions
}

func NewGetQueryResultParams(
	id yt.QueryID,
	resultIndex int64,
	options *yt.GetQueryResultOptions,
) *GetQueryResultParams {
	if options == nil {
		options = &yt.GetQueryResultOptions{}
	}
	optionsCopy := *options
	return &GetQueryResultParams{
		Verb("get_query_result"),
		id,
		resultIndex,
		&optionsCopy,
	}
}

func (p *GetQueryResultParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetQueryResultParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *GetQueryResultParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
		log.Any("resultIndex", p.resultIndex),
	}
	fields = append(fields, logGetQueryResultOptions(p.options)...)
	return fields
}

func (p *GetQueryResultParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("query_id")
	w.Any(p.id)
	w.MapKeyString("result_index")
	w.Any(p.resultIndex)
	writeGetQueryResultOptions(w, p.options)
}

func (p *GetQueryResultParams) QueryTrackerOptions() **yt.QueryTrackerOptions {
	return &p.options.QueryTrackerOptions
}

type ReadQueryResultParams struct {
	verb        Verb
	id          yt.QueryID
	resultIndex int64
	options     *yt.ReadQueryResultOptions
}

func NewReadQueryResultParams(
	id yt.QueryID,
	resultIndex int64,
	options *yt.ReadQueryResultOptions,
) *ReadQueryResultParams {
	if options == nil {
		options = &yt.ReadQueryResultOptions{}
	}
	optionsCopy := *options
	return &ReadQueryResultParams{
		Verb("read_query_result"),
		id,
		resultIndex,
		&optionsCopy,
	}
}

func (p *ReadQueryResultParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ReadQueryResultParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *ReadQueryResultParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
		log.Any("resultIndex", p.resultIndex),
	}
	fields = append(fields, logReadQueryResultOptions(p.options)...)
	return fields
}

func (p *ReadQueryResultParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("query_id")
	w.Any(p.id)
	w.MapKeyString("result_index")
	w.Any(p.resultIndex)
	writeReadQueryResultOptions(w, p.options)
}

func (p *ReadQueryResultParams) QueryTrackerOptions() **yt.QueryTrackerOptions {
	return &p.options.QueryTrackerOptions
}

type AlterQueryParams struct {
	verb    Verb
	id      yt.QueryID
	options *yt.AlterQueryOptions
}

func NewAlterQueryParams(
	id yt.QueryID,
	options *yt.AlterQueryOptions,
) *AlterQueryParams {
	if options == nil {
		options = &yt.AlterQueryOptions{}
	}
	optionsCopy := *options
	return &AlterQueryParams{
		Verb("alter_query"),
		id,
		&optionsCopy,
	}
}

func (p *AlterQueryParams) HTTPVerb() Verb {
	return p.verb
}
func (p *AlterQueryParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *AlterQueryParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("id", p.id),
	}
	fields = append(fields, logAlterQueryOptions(p.options)...)
	return fields
}

func (p *AlterQueryParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("query_id")
	w.Any(p.id)
	writeAlterQueryOptions(w, p.options)
}

func (p *AlterQueryParams) QueryTrackerOptions() **yt.QueryTrackerOptions {
	return &p.options.QueryTrackerOptions
}

type SetUserPasswordParams struct {
	verb            Verb
	user            string
	newPassword     string
	currentPassword string
	options         *yt.SetUserPasswordOptions
}

func NewSetUserPasswordParams(
	user string,
	newPassword string,
	currentPassword string,
	options *yt.SetUserPasswordOptions,
) *SetUserPasswordParams {
	if options == nil {
		options = &yt.SetUserPasswordOptions{}
	}
	optionsCopy := *options
	return &SetUserPasswordParams{
		Verb("set_user_password"),
		user,
		newPassword,
		currentPassword,
		&optionsCopy,
	}
}

func (p *SetUserPasswordParams) HTTPVerb() Verb {
	return p.verb
}
func (p *SetUserPasswordParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *SetUserPasswordParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("user", p.user),
		log.Any("newPassword", p.newPassword),
		log.Any("currentPassword", p.currentPassword),
	}
	fields = append(fields, logSetUserPasswordOptions(p.options)...)
	return fields
}

func (p *SetUserPasswordParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("user")
	w.Any(p.user)
	w.MapKeyString("new_password_sha256")
	w.Any(p.newPassword)
	w.MapKeyString("current_password_sha256")
	w.Any(p.currentPassword)
	writeSetUserPasswordOptions(w, p.options)
}

type IssueTokenParams struct {
	verb     Verb
	user     string
	password string
	options  *yt.IssueTokenOptions
}

func NewIssueTokenParams(
	user string,
	password string,
	options *yt.IssueTokenOptions,
) *IssueTokenParams {
	if options == nil {
		options = &yt.IssueTokenOptions{}
	}
	optionsCopy := *options
	return &IssueTokenParams{
		Verb("issue_token"),
		user,
		password,
		&optionsCopy,
	}
}

func (p *IssueTokenParams) HTTPVerb() Verb {
	return p.verb
}
func (p *IssueTokenParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *IssueTokenParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("user", p.user),
		log.Any("password", p.password),
	}
	fields = append(fields, logIssueTokenOptions(p.options)...)
	return fields
}

func (p *IssueTokenParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("user")
	w.Any(p.user)
	w.MapKeyString("password_sha256")
	w.Any(p.password)
	writeIssueTokenOptions(w, p.options)
}

type RevokeTokenParams struct {
	verb     Verb
	user     string
	password string
	token    string
	options  *yt.RevokeTokenOptions
}

func NewRevokeTokenParams(
	user string,
	password string,
	token string,
	options *yt.RevokeTokenOptions,
) *RevokeTokenParams {
	if options == nil {
		options = &yt.RevokeTokenOptions{}
	}
	optionsCopy := *options
	return &RevokeTokenParams{
		Verb("revoke_token"),
		user,
		password,
		token,
		&optionsCopy,
	}
}

func (p *RevokeTokenParams) HTTPVerb() Verb {
	return p.verb
}
func (p *RevokeTokenParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *RevokeTokenParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("user", p.user),
		log.Any("password", p.password),
		log.Any("token", p.token),
	}
	fields = append(fields, logRevokeTokenOptions(p.options)...)
	return fields
}

func (p *RevokeTokenParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("user")
	w.Any(p.user)
	w.MapKeyString("password_sha256")
	w.Any(p.password)
	w.MapKeyString("token_sha256")
	w.Any(p.token)
	writeRevokeTokenOptions(w, p.options)
}

type ListUserTokensParams struct {
	verb     Verb
	user     string
	password string
	options  *yt.ListUserTokensOptions
}

func NewListUserTokensParams(
	user string,
	password string,
	options *yt.ListUserTokensOptions,
) *ListUserTokensParams {
	if options == nil {
		options = &yt.ListUserTokensOptions{}
	}
	optionsCopy := *options
	return &ListUserTokensParams{
		Verb("list_user_tokens"),
		user,
		password,
		&optionsCopy,
	}
}

func (p *ListUserTokensParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ListUserTokensParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *ListUserTokensParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("user", p.user),
		log.Any("password", p.password),
	}
	fields = append(fields, logListUserTokensOptions(p.options)...)
	return fields
}

func (p *ListUserTokensParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("user")
	w.Any(p.user)
	w.MapKeyString("password_sha256")
	w.Any(p.password)
	writeListUserTokensOptions(w, p.options)
}

type WhoAmIParams struct {
	verb    Verb
	options *yt.WhoAmIOptions
}

func NewWhoAmIParams(
	options *yt.WhoAmIOptions,
) *WhoAmIParams {
	if options == nil {
		options = &yt.WhoAmIOptions{}
	}
	optionsCopy := *options
	return &WhoAmIParams{
		Verb("whoami"),
		&optionsCopy,
	}
}

func (p *WhoAmIParams) HTTPVerb() Verb {
	return p.verb
}
func (p *WhoAmIParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *WhoAmIParams) Log() []log.Field {
	fields := []log.Field{}
	fields = append(fields, logWhoAmIOptions(p.options)...)
	return fields
}

func (p *WhoAmIParams) MarshalHTTP(w *yson.Writer) {
	writeWhoAmIOptions(w, p.options)
}

type GenerateTimestampParams struct {
	verb    Verb
	options *yt.GenerateTimestampOptions
}

func NewGenerateTimestampParams(
	options *yt.GenerateTimestampOptions,
) *GenerateTimestampParams {
	if options == nil {
		options = &yt.GenerateTimestampOptions{}
	}
	optionsCopy := *options
	return &GenerateTimestampParams{
		Verb("generate_timestamp"),
		&optionsCopy,
	}
}

func (p *GenerateTimestampParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GenerateTimestampParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *GenerateTimestampParams) Log() []log.Field {
	fields := []log.Field{}
	fields = append(fields, logGenerateTimestampOptions(p.options)...)
	return fields
}

func (p *GenerateTimestampParams) MarshalHTTP(w *yson.Writer) {
	writeGenerateTimestampOptions(w, p.options)
}

type LocateSkynetShareParams struct {
	verb    Verb
	path    ypath.YPath
	options *yt.LocateSkynetShareOptions
}

func NewLocateSkynetShareParams(
	path ypath.YPath,
	options *yt.LocateSkynetShareOptions,
) *LocateSkynetShareParams {
	if options == nil {
		options = &yt.LocateSkynetShareOptions{}
	}
	optionsCopy := *options
	return &LocateSkynetShareParams{
		Verb("locate_skynet_share"),
		path,
		&optionsCopy,
	}
}

func (p *LocateSkynetShareParams) HTTPVerb() Verb {
	return p.verb
}
func (p *LocateSkynetShareParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *LocateSkynetShareParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
	}
	fields = append(fields, logLocateSkynetShareOptions(p.options)...)
	return fields
}

func (p *LocateSkynetShareParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	writeLocateSkynetShareOptions(w, p.options)
}

type GetInSyncReplicasParams struct {
	verb    Verb
	path    ypath.Path
	ts      yt.Timestamp
	options *yt.GetInSyncReplicasOptions
}

func NewGetInSyncReplicasParams(
	path ypath.Path,
	ts yt.Timestamp,
	options *yt.GetInSyncReplicasOptions,
) *GetInSyncReplicasParams {
	if options == nil {
		options = &yt.GetInSyncReplicasOptions{}
	}
	optionsCopy := *options
	return &GetInSyncReplicasParams{
		Verb("get_in_sync_replicas"),
		path,
		ts,
		&optionsCopy,
	}
}

func (p *GetInSyncReplicasParams) HTTPVerb() Verb {
	return p.verb
}
func (p *GetInSyncReplicasParams) YPath() (ypath.YPath, bool) {
	return p.path, true
}
func (p *GetInSyncReplicasParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("path", p.path),
		log.Any("ts", p.ts),
	}
	fields = append(fields, logGetInSyncReplicasOptions(p.options)...)
	return fields
}

func (p *GetInSyncReplicasParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("path")
	w.Any(p.path)
	w.MapKeyString("timestamp")
	w.Any(p.ts)
	writeGetInSyncReplicasOptions(w, p.options)
}

func writeExecuteBatchOptions(w *yson.Writer, o *ExecuteBatchOptions) {
	if o == nil {
		return
	}
	if o.Concurrency != nil {
		w.MapKeyString("concurrency")
		w.Any(o.Concurrency)
	}
	writeMutatingOptions(w, o.MutatingOptions)
}

func logExecuteBatchOptions(o *ExecuteBatchOptions) []log.Field {
	if o == nil {
		return nil
	}
	fields := []log.Field{}
	if o.Concurrency != nil {
		fields = append(fields, log.Any("concurrency", o.Concurrency))
	}
	fields = append(fields, logMutatingOptions(o.MutatingOptions)...)
	return fields
}

type ExecuteBatchParams struct {
	verb     Verb
	requests []BatchSubrequest
	options  *ExecuteBatchOptions
}

func NewExecuteBatchParams(
	requests []BatchSubrequest,
	options *ExecuteBatchOptions,
) *ExecuteBatchParams {
	if options == nil {
		options = &ExecuteBatchOptions{}
	}
	optionsCopy := *options
	return &ExecuteBatchParams{
		Verb("execute_batch"),
		requests,
		&optionsCopy,
	}
}

func (p *ExecuteBatchParams) HTTPVerb() Verb {
	return p.verb
}
func (p *ExecuteBatchParams) YPath() (ypath.YPath, bool) {
	return nil, false
}
func (p *ExecuteBatchParams) Log() []log.Field {
	fields := []log.Field{
		log.Any("requests", p.requests),
	}
	fields = append(fields, logExecuteBatchOptions(p.options)...)
	return fields
}

func (p *ExecuteBatchParams) MarshalHTTP(w *yson.Writer) {
	w.MapKeyString("requests")
	w.Any(p.requests)
	writeExecuteBatchOptions(w, p.options)
}

func (p *ExecuteBatchParams) MutatingOptions() **yt.MutatingOptions {
	return &p.options.MutatingOptions
}
