#pragma once

#include "private.h"

#include "data_flow_graph.h"
#include "extended_job_resources.h"

#include <yt/yt/server/controller_agent/controller_agent.h>

#include <yt/yt/server/lib/chunk_pools/chunk_pool.h>

#include <yt/yt/server/lib/scheduler/job_metrics.h>
#include <yt/yt/server/lib/scheduler/exec_node_descriptor.h>

#include <yt/yt/client/job_tracker_client/public.h>

#include <yt/yt/ytlib/controller_agent/serialize.h>

#include <yt/yt/core/misc/statistics.h>

namespace NYT::NControllerAgent::NControllers {

////////////////////////////////////////////////////////////////////////////////

//! A reduced version of TExecNodeDescriptor, which is associated with jobs.
struct TJobNodeDescriptor
{
    TJobNodeDescriptor() = default;
    TJobNodeDescriptor(const TJobNodeDescriptor& other) = default;
    TJobNodeDescriptor& operator=(const TJobNodeDescriptor& other) = default;
    TJobNodeDescriptor(const NScheduler::TExecNodeDescriptorPtr& other);

    NNodeTrackerClient::TNodeId Id = NNodeTrackerClient::InvalidNodeId;
    std::string Address;
    NNodeTrackerClient::TAddressMap Addresses;
    double IOWeight = 0.0;

    PHOENIX_DECLARE_TYPE(TJobNodeDescriptor, 0xca71c8d6);
};

////////////////////////////////////////////////////////////////////////////////

struct TAllocation
{
    TAllocationId Id;

    TJobletPtr Joblet;

    NScheduler::TJobResourcesWithQuota Resources;
    TString TreeId;
    std::optional<TString> PoolPath;
    TJobNodeDescriptor NodeDescriptor;

    TTask* Task = nullptr;

    struct TLastJobInfo
        : public IPersistent
    {
        TJobId JobId;
        std::optional<EJobCompetitionType> CompetitionType;

        PHOENIX_DECLARE_POLYMORPHIC_TYPE(TLastJobInfo, 0x2201c8d6);
    };

    std::unique_ptr<TLastJobInfo> LastJobInfo;

    std::optional<EScheduleFailReason> NewJobsForbiddenReason;

    PHOENIX_DECLARE_TYPE(TAllocation, 0x2101c8d6);
};

////////////////////////////////////////////////////////////////////////////////

struct TJoblet
    : public TRefCounted
    , public IPersistent
{
    NJobTrackerClient::TJobId JobId;
    NJobTrackerClient::EJobType JobType;

    bool JobInterruptible;

    TJobNodeDescriptor NodeDescriptor;

    TInstant StartTime;
    TInstant FinishTime;
    TInstant LastUpdateTime;
    TInstant LastStatisticsUpdateTime;
    TInstant NodeJobStartTime;

    std::optional<TDuration> WaitingForResourcesDuration;

    // There are no joblets for finished jobs, JobState may not contain finished states.
    std::optional<EJobState> JobState;

    EInterruptionReason InterruptionReason = EInterruptionReason::None;

    std::string DebugArtifactsAccount;
    bool Suspicious = false;
    TInstant LastActivityTime;
    TBriefJobStatisticsPtr BriefStatistics;
    double Progress = 0.0;
    i64 StderrSize = 0;

    // Shared pointers from two following fields must be accessed (read, written) only from
    // controller invoker which is serialized. Pointees (i.e. statistics objects) may be accessed
    // in thread-safe read-only manner.

    //! Statistics obtained from job heartbeat. Always non-nullptr. This field may be heavy, so
    //! we must not copy or traverse them in the controller invoker for running job events.
    //! Traversing this field for finished job events or for job attribute retrieval
    //! events is fine as it happens occasionally.
    std::shared_ptr<const TStatistics> JobStatistics = std::make_shared<const TStatistics>();

    //! Statistics generated by controller. Always non-nullptr. This field is of constant size, so
    //! we are rebuilding them from scratch for running job events and for finished job events.
    std::shared_ptr<const TStatistics> ControllerStatistics = std::make_shared<const TStatistics>();

    EJobPhase Phase = EJobPhase::Missing;
    TEnumIndexedArray<EJobCompetitionType, TJobId> CompetitionIds;
    TEnumIndexedArray<EJobCompetitionType, bool> HasCompetitors;
    TString TaskName;

    // Controller encapsulates lifetime of both, tasks and joblets.
    TTask* Task;
    int JobIndex = -1;
    int TaskJobIndex = 0;
    i64 StartRowIndex = -1;
    bool Restarted = false;
    bool Revived = false;
    std::optional<EJobCompetitionType> CompetitionType;

    // It is necessary to store tree id here since it is required to
    // create job metrics updater after revive.
    TString TreeId;
    // Is the tree marked as tentative in the spec?
    bool TreeIsTentative = false;

    TFuture<TSharedRef> JobSpecProtoFuture;

    TExtendedJobResources EstimatedResourceUsage;
    std::optional<double> JobProxyMemoryReserveFactor;
    std::optional<double> UserJobMemoryReserveFactor;
    // TODO(ignat): use TJobResourcesWithQuota.
    TJobResources ResourceLimits;
    NScheduler::TDiskQuota DiskQuota;

    i64 UserJobMemoryReserve = 0;

    EPredecessorType PredecessorType = EPredecessorType::None;
    TJobId PredecessorJobId;

    std::optional<std::string> DiskRequestAccount;

    NChunkPools::TChunkStripeListPtr InputStripeList;
    NChunkPools::IChunkPoolOutput::TCookie OutputCookie = -1;

    //! All chunk lists allocated for this job.
    /*!
     *  For jobs with intermediate output this list typically contains one element.
     *  For jobs with final output this list typically contains one element per each output table.
     */
    std::vector<NChunkClient::TChunkListId> ChunkListIds;

    NChunkClient::TChunkListId StderrTableChunkListId;
    NChunkClient::TChunkListId CoreTableChunkListId;

    NScheduler::TJobMetrics JobMetrics;
    bool HasLoggedJobMetricsMonotonicityViolation = false;

    std::optional<TDuration> JobSpeculationTimeout;

    std::vector<TOutputStreamDescriptorPtr> OutputStreamDescriptors;
    std::vector<TInputStreamDescriptorPtr> InputStreamDescriptors;

    std::optional<TJobMonitoringDescriptor> UserJobMonitoringDescriptor;

    // These fields are used only to build job spec and thus transient.
    std::optional<TString> PoolPath;

    NScheduler::TJobProfilerSpecPtr EnabledJobProfiler;

    std::optional<TDuration> ArchiveTtl;

    // Used only for persistence.
    TJoblet() = default;

    TJoblet(
        TTask* task,
        int jobIndex,
        int taskJobIndex,
        const TString& treeId,
        bool treeIsTentative);

    NScheduler::TJobMetrics UpdateJobMetrics(
        const TJobSummary& jobSummary,
        bool isJobFinished);

    //! Put controller statistics over job statistics (preferring controller summaries for
    //! common paths) and return result.
    //! This method traverses both statistics fields, so do not call it often.
    TStatistics BuildCombinedStatistics() const;

    TJobStatisticsTags GetAggregationTags(EJobState state);

    bool ShouldLogFinishedEvent() const;
    bool IsStarted() const noexcept;
    bool IsJobStartedOnNode() const noexcept;

    PHOENIX_DECLARE_POLYMORPHIC_TYPE(TJoblet, 0x2301c8d6);
};

DEFINE_REFCOUNTED_TYPE(TJoblet)

////////////////////////////////////////////////////////////////////////////////

struct TCompletedJob
    : public TRefCounted
{
    bool Suspended = false;

    std::set<NChunkClient::TChunkId> UnavailableChunks;

    TJobId JobId;

    TTaskPtr SourceTask;
    NChunkPools::IChunkPoolOutput::TCookie OutputCookie;
    i64 DataWeight;

    NChunkPools::IPersistentChunkPoolInputPtr DestinationPool;
    NChunkPools::IChunkPoolInput::TCookie InputCookie;
    NChunkPools::TChunkStripePtr InputStripe;
    bool Restartable;

    TJobNodeDescriptor NodeDescriptor;

    void Persist(const TPersistenceContext& context);
};

DEFINE_REFCOUNTED_TYPE(TCompletedJob)

////////////////////////////////////////////////////////////////////////////////

} // namespace NYT::NControllerAgent::NControllers
