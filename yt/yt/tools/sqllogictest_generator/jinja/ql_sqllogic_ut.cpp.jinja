{%- raw -%}
// This file is generated by sqllogictest_generator tool.
// Please do not edit this file by hand. Make changes in yt/yt/tools/sqllogictest_generator and run generation.
#include <yt/yt/library/query/unittests/evaluate/test_evaluate.h>

#include <library/cpp/testing/common/env.h>
#include <library/cpp/yson/node/node_io.h>

namespace NYT::NQueryClient {
namespace {

////////////////////////////////////////////////////////////////////////////////

struct TTestParameters
{
    std::string Name;
    std::string Query;
    THashMap<std::string, std::string> SourceTableSchemaMap;
    THashMap<std::string, std::vector<std::string>> SourceTableRowsMap;
    std::vector<std::string> ExpectedRows;
    std::optional<bool> SortResult;
    bool Skip;
    std::optional<std::string> SkipReason;

    friend std::ostream& operator<<(std::ostream& out, const TTestParameters& params)
    {
        out << "(Query: " << params.Query << ")";
        return out;
    }
};

std::string PrintToStringParamName(const testing::TestParamInfo<TTestParameters>& info)
{
    return info.param.Name;
}

std::vector<TTestParameters> GetTestsFromYson(const std::string& filename)
{
    std::vector<TTestParameters> testData;

    auto absoluteFilePath = TString::Join(ArcadiaSourceRoot(), filename);
    TFileInput fd{absoluteFilePath};
    std::string content = fd.ReadAll();

    const auto node = NodeFromYsonString(content);
    auto data = node.AsMap();

    const auto sourceTableSchemaMapNode = data["table_schema"].AsMap();
    auto sourceTableSchemaMap = THashMap<std::string, std::string>();

    for (const auto& [tableName, tableSchema] : sourceTableSchemaMapNode) {
        sourceTableSchemaMap[tableName] = tableSchema.AsString();
    }

    const auto sourceTableRowsMapNode = data["source_rows"].AsMap();
    auto sourceTableRowsMap = THashMap<std::string, std::vector<std::string>>();

    for (const auto& [tableName, sourceRowNodesYson] : sourceTableRowsMapNode) {
        const auto& sourceRowNodes = sourceRowNodesYson.AsList();
        auto sourceRows = std::vector<std::string>();
        sourceRows.reserve(sourceRowNodes.size());
        for (auto sourceRowNode : sourceRowNodes) {
            sourceRows.push_back(sourceRowNode.AsString());
        }
        sourceTableRowsMap[tableName] = sourceRows;
    }

    const auto queries = data["queries"].AsList();
    for (const auto& queryEntryNode : queries) {
        auto queryEntry = queryEntryNode.AsMap();

        auto exprectedRowsNode = queryEntry["expected_rows"].AsList();
        auto exprectedRows = std::vector<std::string>();
        exprectedRows.reserve(exprectedRowsNode.size());
        for (auto expectedRowNode : exprectedRowsNode) {
            exprectedRows.push_back(expectedRowNode.AsString());
        }

        std::optional<std::string> skipReason;
        if (queryEntry.contains("skip_reason")) {
            skipReason = queryEntry["skip_reason"].AsString();
        }

        std::optional<bool> sortResult;
        if (queryEntry.contains("sort_result")) {
            sortResult = queryEntry["sort_result"].AsBool();
        }

        auto parameters = TTestParameters(
            queryEntry["name"].AsString(),
            queryEntry["query"].AsString(),
            sourceTableSchemaMap,
            sourceTableRowsMap,
            exprectedRows,
            sortResult,
            skipReason.has_value(),
            skipReason);

        testData.push_back(parameters);
    }

    return testData;
}

std::vector<TOwningRow> YsonToSchemalessRows(TRange<std::string> rowsData)
{
    std::vector<TOwningRow> result;
    result.reserve(std::ssize(rowsData));

    for (auto row : rowsData) {
        result.push_back(YsonToSchemalessRow(row));
    }

    return result;
}

class TQueryEvaluateSQLLogicTest
    : public TQueryEvaluateTest
    , public ::testing::WithParamInterface<TTestParameters>
{ };

TEST_P(TQueryEvaluateSQLLogicTest, QueryEvaluateSQLLogicTest)
{
    const auto& args = GetParam();

    if (args.Skip) {
        auto skipReason = args.SkipReason.value_or("Temporary skipping");
        GTEST_SKIP() << skipReason;
    }

    TSplitMap dataSplits;
    std::vector<TSource> sources;

    for (auto schemaItem : args.SourceTableSchemaMap) {
        auto tableName = schemaItem.first;

        TTableSchema sourceTableSchema;
        Deserialize(sourceTableSchema, NYTree::ConvertToNode(NYson::TYsonString(TString(schemaItem.second))));
        auto split = MakeSplit(sourceTableSchema.Columns());
        auto source = GetOrCrash(args.SourceTableRowsMap, tableName);

        dataSplits.emplace(tableName, split);
        sources.push_back(source);
    }

    auto result = YsonToSchemalessRows(args.ExpectedRows);
    TResultMatcher resultMatcher;

    if (args.SortResult.has_value() && !result.empty()) {
        std::vector<int> indexes(result[0].GetCount());
        std::iota(indexes.begin(), indexes.end(), 0);

        resultMatcher = OrderedResultMatcher(result, indexes);
    } else {
        resultMatcher = ResultMatcher(result);
    }

    EvaluateOnlyViaNativeExecutionBackend(
        args.Query,
        dataSplits,
        sources,
        resultMatcher,
        {.SyntaxVersion = 3, .UseCanonicalNullRelations = true});
}
{% endraw -%}
{%- for suite in suites %}
INSTANTIATE_TEST_SUITE_P(
    {{ suite[0] }},
    TQueryEvaluateSQLLogicTest,
    testing::ValuesIn(GetTestsFromYson("{{ suite[1] }}")),
    PrintToStringParamName);
{% endfor -%}
{%- raw %}
////////////////////////////////////////////////////////////////////////////////

} // namespace
} // namespace NYT::NQueryClient
{% endraw -%}
