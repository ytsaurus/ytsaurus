// Autogenerated, do not edit!

#include <record.h>

#include <yt/yt/client/table_client/record_codegen_cpp.h>

namespace NYT::NTableClient::NTest::NRecords {

using namespace NTableClient;
using namespace NTableClient::NDetail;

////////////////////////////////////////////////////////////////////////////////

TSimpleMappingIdMapping::TSimpleMappingIdMapping(const TNameTablePtr& nameTable)
    : KeyA(nameTable->GetIdOrThrow("key_a"))
    , KeyB(nameTable->GetIdOrThrow("key_b"))
    , KeyC(nameTable->GetIdOrThrow("key_c"))
    , ValueA(nameTable->GetIdOrThrow("value_a"))
    , ValueB(nameTable->GetIdOrThrow("value_b"))
    , ValueC(nameTable->GetIdOrThrow("value_c"))
{ }

////////////////////////////////////////////////////////////////////////////////

TSimpleMappingPartialIdMapping::TSimpleMappingPartialIdMapping(const TNameTablePtr& nameTable)
    : KeyA(nameTable->FindId("key_a"))
    , KeyB(nameTable->FindId("key_b"))
    , KeyC(nameTable->FindId("key_c"))
    , ValueA(nameTable->FindId("value_a"))
    , ValueB(nameTable->FindId("value_b"))
    , ValueC(nameTable->FindId("value_c"))
{ }

////////////////////////////////////////////////////////////////////////////////

const TSimpleMappingDescriptor* TSimpleMappingDescriptor::Get()
{
    return LeakySingleton<TSimpleMappingDescriptor>();
}

const TTableSchemaPtr& TSimpleMappingDescriptor::GetSchema() const
{
    return Schema_;
}

const TNameTablePtr& TSimpleMappingDescriptor::GetNameTable() const
{
    return NameTable_;
}

const TSimpleMappingIdMapping& TSimpleMappingDescriptor::GetIdMapping() const
{
    return IdMapping_;
}

const TSimpleMappingPartialIdMapping& TSimpleMappingDescriptor::GetPartialIdMapping() const
{
    return PartialIdMapping_;
}

const TTableSchemaPtr& TSimpleMappingDescriptor::GetPrimaryTableSchema() const
{
    return PrimaryTableSchema_;
}

TSimpleMappingDescriptor::TSimpleMappingDescriptor()
    : Schema_(New<TTableSchema>(
        std::vector{
            TColumnSchema(
                "key_a",
                ESimpleLogicalValueType::String)
                .SetSortOrder(ESortOrder::Ascending)
                .SetRequired(true)
            ,
            TColumnSchema(
                "key_b",
                ESimpleLogicalValueType::String)
                .SetSortOrder(ESortOrder::Ascending)
            ,
            TColumnSchema(
                "key_c",
                FromRecordCodegenTypeV3("{\"type_name\": \"list\", \"item\": \"string\"}"))
                .SetSortOrder(ESortOrder::Ascending)
            ,
            TColumnSchema(
                "value_a",
                ESimpleLogicalValueType::String)
                .SetRequired(true)
            ,
            TColumnSchema(
                "value_b",
                ESimpleLogicalValueType::String)
            ,
            TColumnSchema(
                "value_c",
                FromRecordCodegenTypeV3("{\"type_name\": \"yson\"}"))
            ,
        },
        /*strict*/ true,
        /*uniqueKeys*/ true))
    , NameTable_(TNameTable::FromSchema(*Schema_))
    , IdMapping_(NameTable_)
    , PartialIdMapping_(NameTable_)
    , PrimaryTableSchema_(New<TTableSchema>(
        std::vector{
            TColumnSchema(
                "key_a",
                ESimpleLogicalValueType::String)
                .SetSortOrder(ESortOrder::Ascending)
                .SetRequired(true),
            TColumnSchema(
                "key_b",
                ESimpleLogicalValueType::String)
                .SetSortOrder(ESortOrder::Ascending),
            TColumnSchema(
                "key_c",
                FromRecordCodegenTypeV3("{\"type_name\": \"list\", \"item\": \"string\"}"))
                .SetSortOrder(ESortOrder::Ascending),
            TColumnSchema(
                "value_a",
                ESimpleLogicalValueType::String)
                .SetRequired(true),
            TColumnSchema(
                "value_b",
                ESimpleLogicalValueType::String),
            TColumnSchema(
                "value_c",
                FromRecordCodegenTypeV3("{\"type_name\": \"yson\"}")),
        })
            ->SetUniqueKeys(true))
{ }

////////////////////////////////////////////////////////////////////////////////

TLegacyKey TSimpleMappingKey::ToKey(const TRowBufferPtr& rowBuffer) const
{
    std::array values{
        ToUnversionedValue(KeyA, rowBuffer, 0),
        ToUnversionedValue(KeyB, rowBuffer, 1),
        ToUnversionedCompositeValue(KeyC, rowBuffer, 2),
    };
    return rowBuffer->CaptureRow(TRange(values), /*captureValues*/ false);
}

TSimpleMappingKey TSimpleMappingKey::FromKey(TLegacyKey key)
{
    YT_VERIFY(key);
    ValidateKeyValueCount(key, TSimpleMappingDescriptor::Get()->GetSchema()->GetKeyColumnCount());
    TSimpleMappingKey result;
    FromUnversionedValue(&result.KeyA, key[0]);
    FromUnversionedValue(&result.KeyB, key[1]);
    FromUnversionedValue(&result.KeyC, key[2]);
    return result;
}

////////////////////////////////////////////////////////////////////////////////

TUnversionedRow TSimpleMapping::ToUnversionedRow(
    const TRowBufferPtr& rowBuffer,
    const TSimpleMappingPartialIdMapping& idMapping,
    EValueFlags flags) const
{
    std::array values{
        ToUnversionedValue(
            Key.KeyA,
            rowBuffer,
            GetColumnIdOrThrow(
                idMapping.KeyA,
                TStringBuf("key_a"))),
        ToUnversionedValue(
            Key.KeyB,
            rowBuffer,
            GetColumnIdOrThrow(
                idMapping.KeyB,
                TStringBuf("key_b"))),
        ToUnversionedCompositeValue(
            Key.KeyC,
            rowBuffer,
            GetColumnIdOrThrow(
                idMapping.KeyC,
                TStringBuf("key_c"))),
        ToUnversionedValue(
            ValueA,
            rowBuffer,
            GetColumnIdOrThrow(idMapping.ValueA, TStringBuf("value_a")),
            flags & NYT::NTableClient::EValueFlags::None),
        ToUnversionedValue(
            ValueB,
            rowBuffer,
            GetColumnIdOrThrow(idMapping.ValueB, TStringBuf("value_b")),
            flags & NYT::NTableClient::EValueFlags::None),
        ToUnversionedCompositeValue(
            ValueC,
            rowBuffer,
            GetColumnIdOrThrow(idMapping.ValueC, TStringBuf("value_c")),
            flags & NYT::NTableClient::EValueFlags::None),
    };
    return rowBuffer->CaptureRow(TRange(values), /*captureValues*/ false);
}

TSimpleMapping TSimpleMapping::FromUnversionedRow(
    TUnversionedRow row,
    const TSimpleMappingPartialIdMapping& idMapping)
{
    TSimpleMapping result;

    if (idMapping.KeyA) {
        auto id = *idMapping.KeyA;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.Key.KeyA, row[*idMapping.KeyA]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "key_a")
                << ex;
        }
    } else {
        THROW_ERROR_EXCEPTION("No such column %Qv", "key_a");
    }

    if (idMapping.KeyB) {
        auto id = *idMapping.KeyB;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.Key.KeyB, row[*idMapping.KeyB]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "key_b")
                << ex;
        }
    }

    if (idMapping.KeyC) {
        auto id = *idMapping.KeyC;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.Key.KeyC, row[*idMapping.KeyC]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "key_c")
                << ex;
        }
    }

    if (idMapping.ValueA) {
        auto id = *idMapping.ValueA;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.ValueA, row[*idMapping.ValueA]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "value_a")
                << ex;
        }
    } else {
        THROW_ERROR_EXCEPTION("No such column %Qv", "value_a");
    }

    if (idMapping.ValueB) {
        auto id = *idMapping.ValueB;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.ValueB, row[*idMapping.ValueB]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "value_b")
                << ex;
        }
    }

    if (idMapping.ValueC) {
        auto id = *idMapping.ValueC;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.ValueC, row[*idMapping.ValueC]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "value_c")
                << ex;
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////

TUnversionedRow TSimpleMappingPartial::ToUnversionedRow(
    const TRowBufferPtr& rowBuffer,
    const TSimpleMappingPartialIdMapping& idMapping,
    EValueFlags flags) const
{
    TUnversionedRowBuilder builder;

    builder.AddValue(
        ToUnversionedValue(
            Key.KeyA,
            rowBuffer,
            GetColumnIdOrThrow(idMapping.KeyA, TStringBuf("key_a"))));
    builder.AddValue(
        ToUnversionedValue(
            Key.KeyB,
            rowBuffer,
            GetColumnIdOrThrow(idMapping.KeyB, TStringBuf("key_b"))));
    builder.AddValue(
        ToUnversionedCompositeValue(
            Key.KeyC,
            rowBuffer,
            GetColumnIdOrThrow(idMapping.KeyC, TStringBuf("key_c"))));
    if (idMapping.ValueA && ValueA) {
        builder.AddValue(
            ToUnversionedValue(
                *ValueA,
                rowBuffer,
                *idMapping.ValueA,
                flags & NYT::NTableClient::EValueFlags::None));
    }
    if (idMapping.ValueB && ValueB) {
        builder.AddValue(
            ToUnversionedValue(
                *ValueB,
                rowBuffer,
                *idMapping.ValueB,
                flags & NYT::NTableClient::EValueFlags::None));
    }
    if (idMapping.ValueC && ValueC) {
        builder.AddValue(
            ToUnversionedCompositeValue(
                *ValueC,
                rowBuffer,
                *idMapping.ValueC,
                flags & NYT::NTableClient::EValueFlags::None));
    }
    return rowBuffer->CaptureRow(builder.GetRow(), /*captureValues*/ false);
}

TSimpleMappingPartial TSimpleMappingPartial::FromUnversionedRow(
    TUnversionedRow row,
    const TSimpleMappingPartialIdMapping& idMapping)
{
    TSimpleMappingPartial result;

    if (idMapping.KeyA) {
        auto id = *idMapping.KeyA;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.Key.KeyA, row[id]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "key_a")
                << ex;
        }
    }

    if (idMapping.KeyB) {
        auto id = *idMapping.KeyB;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.Key.KeyB, row[id]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "key_b")
                << ex;
        }
    }

    if (idMapping.KeyC) {
        auto id = *idMapping.KeyC;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.Key.KeyC, row[id]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "key_c")
                << ex;
        }
    }

    if (idMapping.ValueA) {
        auto id = *idMapping.ValueA;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.ValueA, row[id]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "value_a")
                << ex;
        }
    }

    if (idMapping.ValueB) {
        auto id = *idMapping.ValueB;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.ValueB, row[id]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "value_b")
                << ex;
        }
    }

    if (idMapping.ValueC) {
        auto id = *idMapping.ValueC;
        ValidateRowValueCount(row, id);
        try {
            FromUnversionedValue(&result.ValueC, row[id]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "value_c")
                << ex;
        }
    }

    return result;
}

////////////////////////////////////////////////////////////////////////////////

} // namespace NYT::NTableClient::NTest::NRecords
