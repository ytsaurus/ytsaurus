// Autogenerated, do not edit!

#pragma once

#include <yt/yt/client/table_client/record_codegen_h.h>
#include <yt/yt/client/table_client/row_base.h>

#include <library/cpp/yt/memory/leaky_singleton.h>
{%- if includes %}
{% for include in includes %}
#include <{{include}}>
{%- endfor -%}
{%- endif %}
{%- if h_verbatim %}
{{h_verbatim}}
{%- endif %}

namespace {{namespace}} {

////////////////////////////////////////////////////////////////////////////////
{%- for type in types %}

struct {{type.type_name}};
struct {{type.type_name}}Partial;
{% if type.sorted -%}
struct {{type.type_name}}Key;
{% endif -%}
struct {{type.type_name}}IdMapping;
struct {{type.type_name}}PartialIdMapping;
class {{type.type_name}}Descriptor;

struct {{type.type_name}}IdMapping
{
{%- for field in type.fields if field.expression is none %}
    const int {{field.cpp_name}};
{%- endfor %}

    explicit {{type.type_name}}IdMapping(const NYT::NTableClient::TNameTablePtr& nameTable);
};

struct {{type.type_name}}PartialIdMapping
{
{%- if not type.sorted %}
    const std::optional<int> TabletIndex;
    const std::optional<int> RowIndex;
{%- endif %}
{%- for field in type.fields if field.expression is none %}
    const std::optional<int> {{field.cpp_name}};
{%- endfor %}

    explicit {{type.type_name}}PartialIdMapping(const NYT::NTableClient::TNameTablePtr& nameTable);
};

class {{type.type_name}}Descriptor
    : public NYT::NTableClient::IRecordDescriptor
{
public:
    using TRecord = {{type.type_name}};
    using TRecordPartial = {{type.type_name}}Partial;
    {% if type.sorted -%}
    using TKey = {{type.type_name}}Key;
    {% endif -%}
    using TIdMapping = {{type.type_name}}IdMapping;
    using TPartialIdMapping = {{type.type_name}}PartialIdMapping;
    static constexpr int FieldCount = {{type.fields | length}};
{%- if type.verbatim %}
{{type.verbatim}}
{%- endif %}
{%- if type.descriptor_verbatim %}
{{type.descriptor_verbatim}}
{%- endif %}

    static const {{type.type_name}}Descriptor* Get();

    const NTableClient::TTableSchemaPtr& GetSchema() const override;
    const NTableClient::TNameTablePtr& GetNameTable() const override;
    const {{type.type_name}}IdMapping& GetIdMapping() const;
    const {{type.type_name}}PartialIdMapping& GetPartialIdMapping() const;
    const NTableClient::TTableSchemaPtr& GetPrimaryTableSchema() const;

private:
    const NTableClient::TTableSchemaPtr Schema_;
    const NTableClient::TNameTablePtr NameTable_;
    const {{type.type_name}}IdMapping IdMapping_;
    const {{type.type_name}}PartialIdMapping PartialIdMapping_;
    const NTableClient::TTableSchemaPtr PrimaryTableSchema_;

private:
    DECLARE_LEAKY_SINGLETON_FRIEND()

    {{type.type_name}}Descriptor();
};

{% if type.sorted -%}
struct {{type.type_name}}Key
{
    using TRecordDescriptor = {{type.type_name}}Descriptor;
{%- if type.verbatim %}
{{type.verbatim}}
{%- endif %}
{%- if type.key_verbatim %}
{{type.key_verbatim}}
{%- endif %}
{% for field in type.fields if field.sort_order and field.expression is none %}
    {{field.cpp_type}} {{field.cpp_name}}{};
{%- endfor %}
{%- if type.add_equality_operator %}

    bool operator==(const {{type.type_name}}Key& rhs) const = default;
{%- endif %}

    NYT::NTableClient::TLegacyKey ToKey(const NYT::NTableClient::TRowBufferPtr& rowBuffer) const;
    static {{type.type_name}}Key FromKey(NYT::NTableClient::TLegacyKey key);
};
{%- endif %}

struct {{type.type_name}}
{
    using TRecordDescriptor = {{type.type_name}}Descriptor;
{%- if type.verbatim %}
{{type.verbatim}}
{%- endif %}
{%- if type.record_verbatim %}
{{type.record_verbatim}}
{%- endif %}
{% if type.sorted %}
    {{type.type_name}}Key Key;
{%- else %}
    i64 TabletIndex = -1;
    i64 RowIndex = -1;
{%- endif %}
{%- for field in type.fields if not field.sort_order and field.expression is none %}
    {{field.cpp_type}} {{field.cpp_name}}{};
{%- endfor %}
{%- if type.add_equality_operator %}

    bool operator==(const {{type.type_name}}& rhs) const = default;
{%- endif %}

    NYT::NTableClient::TUnversionedRow ToUnversionedRow(
        const NYT::NTableClient::TRowBufferPtr& rowBuffer,
        const {{type.type_name}}PartialIdMapping& idMapping,
        NYT::NTableClient::EValueFlags flags = NYT::NTableClient::EValueFlags::None) const;
    static {{type.type_name}} FromUnversionedRow(
        NYT::NTableClient::TUnversionedRow row,
        const {{type.type_name}}PartialIdMapping& idMapping);
};

struct {{type.type_name}}Partial
{
    using TRecordDescriptor = {{type.type_name}}Descriptor;
{%- if type.verbatim %}
{{type.verbatim}}
{%- endif %}
{%- if type.record_verbatim %}
{{type.record_verbatim}}
{%- endif %}
{% if type.sorted %}
    {{type.type_name}}Key Key;
{%- else %}
    i64 TabletIndex = -1;
    i64 RowIndex = -1;
{%- endif %}
{%- for field in type.fields if not field.sort_order and field.expression is none %}
    std::optional<{{field.cpp_type}}> {{field.cpp_name}}{};
{%- endfor %}
{%- if type.add_equality_operator %}

    bool operator==(const {{type.type_name}}Partial& rhs) const = default;
{%- endif %}

    NYT::NTableClient::TUnversionedRow ToUnversionedRow(
        const NYT::NTableClient::TRowBufferPtr& rowBuffer,
        const {{type.type_name}}PartialIdMapping& idMapping,
        NYT::NTableClient::EValueFlags flags = NYT::NTableClient::EValueFlags::None) const;
    static {{type.type_name}}Partial FromUnversionedRow(
        NYT::NTableClient::TUnversionedRow row,
        const {{type.type_name}}PartialIdMapping& idMapping);
};
{%- endfor %}

////////////////////////////////////////////////////////////////////////////////

} // namespace {{namespace}}
