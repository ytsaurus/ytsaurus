// Autogenerated, do not edit!

#include <{{h_path}}>

#include <yt/yt/client/table_client/record_codegen_cpp.h>

{% if cpp_verbatim %}
{{cpp_verbatim}}
{% endif %}

namespace {{namespace}} {

using namespace NTableClient;
using namespace NTableClient::NDetail;


////////////////////////////////////////////////////////////////////////////////

{% for type in types %}
{{type.type_name}}IdMapping::{{type.type_name}}IdMapping(const TNameTablePtr& nameTable)
{%- if not type.sorted %}
    : TabletIndex(nameTable->FindId(TabletIndexColumnName))
    , RowIndex(nameTable->FindId(RowIndexColumnName))
{%- endif -%}
{%- for field in type.fields if field.expression is none %}
    {{":" if loop.index0 == 0 and type.sorted else ","}} {{field.cpp_name}}(nameTable->FindId("{{field.column_name}}"))
{%- endfor %}
{ }

////////////////////////////////////////////////////////////////////////////////

const {{type.type_name}}Descriptor* {{type.type_name}}Descriptor::Get()
{
    return LeakySingleton<{{type.type_name}}Descriptor>();
}

const TTableSchemaPtr& {{type.type_name}}Descriptor::GetSchema() const
{
    return Schema_;
}

const TNameTablePtr& {{type.type_name}}Descriptor::GetNameTable() const
{
    return NameTable_;
}

const {{type.type_name}}IdMapping& {{type.type_name}}Descriptor::GetIdMapping() const
{
    return IdMapping_;
}

const TTableSchemaPtr& {{type.type_name}}Descriptor::GetPrimaryTableSchema() const
{
    return PrimaryTableSchema_;
}

{{type.type_name}}Descriptor::{{type.type_name}}Descriptor()
    : Schema_(New<TTableSchema>(
        std::vector{
{%- if not type.sorted %}
            TColumnSchema(TabletIndexColumnName, ESimpleLogicalValueType::Int64)
                .SetSortOrder(ESortOrder::Ascending),
{%- endif %}
{%- for field in type.fields if field.expression is none %}
            TColumnSchema("{{field.column_name}}", ESimpleLogicalValueType::{{field.column_type}})
{%- if field.sort_order %}
                .SetSortOrder(ESortOrder::{{field.sort_order}})
{%- endif %}
{%- if field.lock %}
                .SetLock("{{field.lock}}")
{%- endif %}
{%- if field.required is not none %}
                .SetRequired({{"true" if field.required else "false"}})
{%- endif %}
            ,
{%- endfor %}
        }))
    , NameTable_(TNameTable::FromSchema(*Schema_))
    , IdMapping_(NameTable_)
    , PrimaryTableSchema_(New<TTableSchema>(std::vector{
{% for field in type.fields -%}
        TColumnSchema("{{field.column_name}}", ESimpleLogicalValueType::{{field.column_type}})
{%- if field.sort_order %}
            .SetSortOrder(ESortOrder::{{field.sort_order}})
{%- endif %}
{%- if field.lock %}
            .SetLock("{{field.lock}}")
{%- endif %}
{%- if field.required is not none %}
            .SetRequired({{"true" if field.required else "false"}})
{%- endif %}
{%- if field.aggregate is not none %}
            .SetAggregate("{{field.aggregate}}")
{%- endif %}
{%- if field.expression is not none %}
            .SetExpression("{{field.expression}}")
{%- endif -%}
,
{%- endfor %}
        })
{% if type.sorted -%}
            ->SetUniqueKeys(true)
{%- endif %})
{ }

////////////////////////////////////////////////////////////////////////////////

{%- if type.sorted %}

TLegacyKey {{type.type_name}}Key::ToKey(const TRowBufferPtr& rowBuffer) const
{
    std::array values{
{%- for field in type.fields if field.sort_order and field.expression is none %}
        ToUnversionedValue({{field.cpp_name}}, rowBuffer, {{loop.index0}}),
{%- endfor %}
    };
    return rowBuffer->CaptureRow(TRange(values), /*captureValues*/ false);
}

{{type.type_name}}Key {{type.type_name}}Key::FromKey(TLegacyKey key)
{
    YT_VERIFY(key);
    ValidateKeyValueCount(key, {{type.type_name}}Descriptor::Get()->GetSchema()->GetKeyColumnCount());
    {{type.type_name}}Key result;
{%- for field in type.fields if field.sort_order and field.expression is none %}
    FromUnversionedValue(&result.{{field.cpp_name}}, key[{{loop.index0}}]);
{%- endfor %}
    return result;
}

////////////////////////////////////////////////////////////////////////////////

{%- endif %}

TUnversionedRow {{type.type_name}}::ToUnversionedRow(
    const TRowBufferPtr& rowBuffer,
    const {{type.type_name}}IdMapping& idMapping,
    EValueFlags flags) const
{
    std::array values{
{% if not type.sorted -%}
        ToUnversionedValue(
            TabletIndex,
            rowBuffer,
            GetColumnIdOrThrow(idMapping.TabletIndex, TabletIndexColumnName)),
{%- endif %}
{% for field in type.fields if field.sort_order and field.expression is none -%}
        ToUnversionedValue(
            Key.{{field.cpp_name}},
            rowBuffer,
            GetColumnIdOrThrow(idMapping.{{field.cpp_name}}, TStringBuf("{{field.column_name}}"))),
{%- endfor %}
{%- for field in type.fields if not field.sort_order and field.expression is none %}
        ToUnversionedValue(
            {{field.cpp_name}},
            rowBuffer,
            GetColumnIdOrThrow(idMapping.{{field.cpp_name}},
            TStringBuf("{{field.column_name}}")),
            {% if field.aggregate %}
                flags & NYT::NTableClient::EValueFlags::Aggregate
            {% else %}
                flags & NYT::NTableClient::EValueFlags::None
            {% endif %}
            ),
{%- endfor %}
    };
    return rowBuffer->CaptureRow(TRange(values), /*captureValues*/ false);
}

{{type.type_name}} {{type.type_name}}::FromUnversionedRow(
    TUnversionedRow row,
    const {{type.type_name}}IdMapping& idMapping)
{
    {{type.type_name}} result;

{% if not type.sorted %}
    if (auto id = idMapping.TabletIndex) {
        ValidateRowValueCount(row, *id);
        FromUnversionedValue(&result.TabletIndex, row[*id]);
    }
    if (auto id = idMapping.RowIndex) {
        ValidateRowValueCount(row, *id);
        FromUnversionedValue(&result.RowIndex, row[*id]);
    }
{% endif %}

{%- for field in type.fields if field.expression is none %}
    if (idMapping.{{field.cpp_name}}) {
        auto id = *idMapping.{{field.cpp_name}};
        ValidateRowValueCount(row, id);
        try {
{% if field.sort_order %}
            FromUnversionedValue(&result.Key.{{field.cpp_name}}, row[*idMapping.{{field.cpp_name}}]);
{% else %}
            FromUnversionedValue(&result.{{field.cpp_name}}, row[*idMapping.{{field.cpp_name}}]);
{% endif %}
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "{{field.column_name}}")
                << ex;
        }
    }
    {%- if field.required -%}
    else {
        THROW_ERROR_EXCEPTION("No such column %Qv", "{{field.column_name}}");
    }
    {% endif %}
{%- endfor %}

    return result;
}

////////////////////////////////////////////////////////////////////////////////

TUnversionedRow {{type.type_name}}Partial::ToUnversionedRow(
    const TRowBufferPtr& rowBuffer,
    const {{type.type_name}}IdMapping& idMapping,
    EValueFlags flags) const
{
    TUnversionedRowBuilder builder;
{% if not type.sorted -%}
    builder.AddValue(
        ToUnversionedValue(
            TabletIndex,
            rowBuffer,
            GetColumnIdOrThrow(idMapping.TabletIndex, TabletIndexColumnName)));
{%- endif %}
{%- for field in type.fields if field.sort_order and field.expression is none %}
    builder.AddValue(
        ToUnversionedValue(
            Key.{{field.cpp_name}},
            rowBuffer,
            GetColumnIdOrThrow(idMapping.{{field.cpp_name}}, TStringBuf("{{field.column_name}}"))));
{%- endfor %}
{%- for field in type.fields if not field.sort_order and not field.expression %}
    if (idMapping.{{field.cpp_name}} && {{field.cpp_name}}) {
        builder.AddValue(
            ToUnversionedValue
            (*{{field.cpp_name}},
            rowBuffer,
            *idMapping.{{field.cpp_name}},
            {% if field.aggregate %}
                flags & NYT::NTableClient::EValueFlags::Aggregate
            {% else %}
                flags & NYT::NTableClient::EValueFlags::None
            {% endif %}
        ));
    }
{%- endfor %}

    return rowBuffer->CaptureRow(builder.GetRow(), /*captureValues*/ false);
}

{{type.type_name}}Partial {{type.type_name}}Partial::FromUnversionedRow(
    TUnversionedRow row,
    const {{type.type_name}}IdMapping& idMapping)
{
    {{type.type_name}}Partial result;
{% if not type.sorted -%}
    if (auto id = idMapping.TabletIndex) {
        ValidateRowValueCount(row, *id);
        try {
            FromUnversionedValue(&result.TabletIndex, row[*id]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", TabletIndexColumnName)
                << ex;
        }
    }
    if (auto id = idMapping.RowIndex) {
        ValidateRowValueCount(row, *id);
        try {
            FromUnversionedValue(&result.RowIndex, row[*id]);
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", RowIndexColumnName)
                << ex;
        }
    }
{%- endif %}
{%- for field in type.fields if not field.expression %}
    if (idMapping.{{field.cpp_name}}) {
        auto id = *idMapping.{{field.cpp_name}};
        ValidateRowValueCount(row, id);
        try {
{%- if field.sort_order %}
            FromUnversionedValue(&result.Key.{{field.cpp_name}}, row[id]);
{% else %}
            FromUnversionedValue(&result.{{field.cpp_name}}, row[id]);
{% endif %}
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "{{field.column_name}}")
                << ex;
        }
    }
{%- endfor %}

    return result;
}

{% endfor %}
////////////////////////////////////////////////////////////////////////////////

} // namespace {{namespace}}
