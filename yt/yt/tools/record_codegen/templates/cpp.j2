// Autogenerated, do not edit!

#include <{{h_path}}>

#include <yt/yt/client/table_client/record_codegen_cpp.h>

{% if cpp_verbatim %}
{{cpp_verbatim}}
{% endif %}

namespace {{namespace}} {

using namespace NTableClient;
using namespace NTableClient::NDetail;

////////////////////////////////////////////////////////////////////////////////

{% for type in types %}
{{type.type_name}}IdMapping::{{type.type_name}}IdMapping(const TNameTablePtr& nameTable)
{%- for field in type.fields if not field.expression %}
    {{":" if loop.index0 == 0 else ","}} {{field.cpp_name}}(nameTable->FindId("{{field.column_name}}"))
{%- endfor %}
{% if type.sorted is not none and not type.sorted %}
    , RowIndex(nameTable->FindId("$row_index"))
{% endif %}
{ }

////////////////////////////////////////////////////////////////////////////////

const {{type.type_name}}Descriptor* {{type.type_name}}Descriptor::Get()
{
    return LeakySingleton<{{type.type_name}}Descriptor>();
}

const NTableClient::TTableSchemaPtr& {{type.type_name}}Descriptor::GetSchema() const
{
    return Schema_;
}

const NTableClient::TNameTablePtr& {{type.type_name}}Descriptor::GetNameTable() const
{
    return NameTable_;
}

const {{type.type_name}}IdMapping& {{type.type_name}}Descriptor::GetIdMapping() const
{
    return IdMapping_;
}

{{type.type_name}}Descriptor::{{type.type_name}}Descriptor()
    : Schema_(New<TTableSchema>(
        std::vector{
{%- for field in type.fields if not field.expression %}
            TColumnSchema("{{field.column_name}}", ESimpleLogicalValueType::{{field.column_type}})
{%- if field.sort_order %}
                .SetSortOrder(ESortOrder::{{field.sort_order}})
{%- endif %}
{%- if field.lock %}
                .SetLock("{{field.lock}}")
{%- endif %}
{%- if field.required is not none %}
                .SetRequired({{"true" if field.required else "false"}})
{%- endif %}
            ,
{%- endfor %}
        }))
    , NameTable_(TNameTable::FromSchema(*Schema_))
    , IdMapping_(NameTable_)
{ }

////////////////////////////////////////////////////////////////////////////////

{%- if type.sorted is none or type.sorted %}

TLegacyKey {{type.type_name}}Key::ToKey(const TRowBufferPtr& rowBuffer) const
{
    std::array values{
{%- for field in type.fields if field.sort_order and not field.expression %}
        ToUnversionedValue({{field.cpp_name}}, rowBuffer, {{loop.index0}}),
{%- endfor %}
    };
    return rowBuffer->CaptureRow(TRange(values), /*captureValues*/ false);
}

{{type.type_name}}Key {{type.type_name}}Key::FromKey(TLegacyKey key)
{
    YT_VERIFY(key);
    ValidateKeyValueCount(key, {{type.type_name}}Descriptor::Get()->GetSchema()->GetKeyColumnCount());
    {{type.type_name}}Key result;
{%- for field in type.fields if field.sort_order and not field.expression %}
    FromUnversionedValue(&result.{{field.cpp_name}}, key[{{loop.index0}}]);
{%- endfor %}
    return result;
}

////////////////////////////////////////////////////////////////////////////////

{%- endif %}

TUnversionedRow {{type.type_name}}::ToUnversionedRow(
    const TRowBufferPtr& rowBuffer,
    const {{type.type_name}}IdMapping& idMapping,
    EValueFlags flags) const
{
    std::array values{
{%- for field in type.fields if field.sort_order and not field.expression %}
        ToUnversionedValue(
            Key.{{field.cpp_name}},
            rowBuffer,
            GetColumnIdOrThrow(idMapping.{{field.cpp_name}}, TStringBuf("{{field.column_name}}"))),
{%- endfor %}
{%- for field in type.fields if not field.sort_order and not field.expression %}
        ToUnversionedValue(
            {{field.cpp_name}},
            rowBuffer,
            GetColumnIdOrThrow(idMapping.{{field.cpp_name}},
            TStringBuf("{{field.column_name}}")),
            {% if field.aggregate %}
                flags & NYT::NTableClient::EValueFlags::Aggregate
            {% else %}
                flags & NYT::NTableClient::EValueFlags::None
            {% endif %}
            ),
{%- endfor %}
    };
    return rowBuffer->CaptureRow(TRange(values), /*captureValues*/ false);
}

{{type.type_name}} {{type.type_name}}::FromUnversionedRow(
    TUnversionedRow row,
    const {{type.type_name}}IdMapping& idMapping)
{
    {{type.type_name}} result;
{%- for field in type.fields if not field.expression %}
    if (idMapping.{{field.cpp_name}}) {
        auto id = *idMapping.{{field.cpp_name}};
        ValidateRowValueCount(row, id);
        try {
{% if field.sort_order %}
            FromUnversionedValue(&result.Key.{{field.cpp_name}}, row[*idMapping.{{field.cpp_name}}]);
{% else %}
            FromUnversionedValue(&result.{{field.cpp_name}}, row[*idMapping.{{field.cpp_name}}]);
{% endif %}
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "{{field.column_name}}")
                << ex;
        }
    }
    {%- if field.required -%}
    else {
        THROW_ERROR_EXCEPTION("No such column %Qv", "{{field.column_name}}");
    }
    {% endif %}
{%- endfor %}

{% if type.sorted is not none and not type.sorted %}
    if (idMapping.RowIndex) {
        auto id = *idMapping.RowIndex;
        FromUnversionedValue(&result.RowIndex, row[id]);
    }
{% endif %}
    return result;
}

////////////////////////////////////////////////////////////////////////////////

TUnversionedRow {{type.type_name}}Partial::ToUnversionedRow(
    const TRowBufferPtr& rowBuffer,
    const {{type.type_name}}IdMapping& idMapping,
    EValueFlags flags) const
{
    TUnversionedRowBuilder builder;
{%- for field in type.fields if field.sort_order and not field.expression %}
    builder.AddValue(
        ToUnversionedValue(
            Key.{{field.cpp_name}},
            rowBuffer,
            GetColumnIdOrThrow(idMapping.{{field.cpp_name}}, TStringBuf("{{field.column_name}}"))));
{%- endfor %}
{%- for field in type.fields if not field.sort_order and not field.expression %}
    if (idMapping.{{field.cpp_name}} && {{field.cpp_name}}) {
        builder.AddValue(
            ToUnversionedValue
            (*{{field.cpp_name}},
            rowBuffer,
            *idMapping.{{field.cpp_name}},
            {% if field.aggregate %}
                flags & NYT::NTableClient::EValueFlags::Aggregate
            {% else %}
                flags & NYT::NTableClient::EValueFlags::None
            {% endif %}
        ));
    }
{%- endfor %}
    return rowBuffer->CaptureRow(builder.GetRow(), /*captureValues*/ false);
}

{{type.type_name}}Partial {{type.type_name}}Partial::FromUnversionedRow(
    TUnversionedRow row,
    const {{type.type_name}}IdMapping& idMapping)
{
    {{type.type_name}}Partial result;
{%- for field in type.fields if not field.expression %}
    if (idMapping.{{field.cpp_name}}) {
        auto id = *idMapping.{{field.cpp_name}};
        ValidateRowValueCount(row, id);
        try {
{%- if field.sort_order %}
            FromUnversionedValue(&result.Key.{{field.cpp_name}}, row[id]);
{% else %}
            FromUnversionedValue(&result.{{field.cpp_name}}, row[id]);
{% endif %}
        } catch (const std::exception& ex) {
            THROW_ERROR_EXCEPTION("Error parsing column %Qv", "{{field.column_name}}")
                << ex;
        }
    }
{%- endfor %}
    return result;
}

{% endfor %}
////////////////////////////////////////////////////////////////////////////////

} // namespace {{namespace}}
