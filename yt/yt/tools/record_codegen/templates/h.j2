// Autogenerated, do not edit!

#pragma once

#include <yt/yt/client/table_client/record_codegen_h.h>
#include <yt/yt/client/table_client/row_base.h>
{% for include in includes %}
#include <{{include}}>
{% endfor %}

{% if h_verbatim %}
{{h_verbatim}}
{% endif %}

namespace {{namespace}} {

////////////////////////////////////////////////////////////////////////////////

{% for type in types %}
struct {{type.type_name}};
struct {{type.type_name}}Partial;
struct {{type.type_name}}Key;
struct {{type.type_name}}IdMapping;
class {{type.type_name}}Descriptor;

struct {{type.type_name}}IdMapping
{
    explicit {{type.type_name}}IdMapping(const NYT::NTableClient::TNameTablePtr& nameTable);

{% for field in type.fields %}
    const std::optional<int> {{field.cpp_name}};
{%- endfor %}
};

class {{type.type_name}}Descriptor
    : public NYT::NTableClient::IRecordDescriptor
{
public:
    using TRecord = {{type.type_name}};
    using TRecordPartial = {{type.type_name}}Partial;
    using TKey = {{type.type_name}}Key;
    using TIdMapping = {{type.type_name}}IdMapping;
    static constexpr int FieldCount = {{type.fields | length}};
{% if type.verbatim %}
{{type.verbatim}}
{% endif %}
{% if type.descriptor_verbatim %}
{{type.descriptor_verbatim}}
{% endif %}

    static const {{type.type_name}}Descriptor* Get();

    const NTableClient::TTableSchemaPtr& GetSchema() const override;
    const NTableClient::TNameTablePtr& GetNameTable() const override;
    const {{type.type_name}}IdMapping& GetIdMapping() const;

private:
    const NTableClient::TTableSchemaPtr Schema_;
    const NTableClient::TNameTablePtr NameTable_;
    const {{type.type_name}}IdMapping IdMapping_;

    DECLARE_LEAKY_SINGLETON_FRIEND()

    {{type.type_name}}Descriptor();
};

struct {{type.type_name}}Key
{
    using TRecordDescriptor = {{type.type_name}}Descriptor;
{% if type.verbatim %}
{{type.verbatim}}
{% endif %}
{% if type.key_verbatim %}
{{type.key_verbatim}}
{% endif %}
{%- for field in type.fields if field.sort_order %}
    {{field.cpp_type}} {{field.cpp_name}}{};
{%- endfor %}

    NYT::NTableClient::TLegacyKey ToKey(const NYT::NTableClient::TRowBufferPtr& rowBuffer) const;
    static {{type.type_name}}Key FromKey(NYT::NTableClient::TLegacyKey key);
};

struct {{type.type_name}}
{
    using TRecordDescriptor = {{type.type_name}}Descriptor;
{% if type.verbatim %}
{{type.verbatim}}
{% endif %}
{% if type.record_verbatim %}
{{type.record_verbatim}}
{% endif %}
    {{type.type_name}}Key Key;
{% for field in type.fields if not(field.sort_order)%}
    {{field.cpp_type}} {{field.cpp_name}}{};
{%- endfor %}

    NYT::NTableClient::TUnversionedRow ToUnversionedRow(
        const NYT::NTableClient::TRowBufferPtr& rowBuffer,
        const {{type.type_name}}IdMapping& idMapping,
        NYT::NTableClient::EValueFlags flags = NYT::NTableClient::EValueFlags::None) const;
    static {{type.type_name}} FromUnversionedRow(
        NYT::NTableClient::TUnversionedRow row,
        const {{type.type_name}}IdMapping& idMapping);
};

struct {{type.type_name}}Partial
{
    using TRecordDescriptor = {{type.type_name}}Descriptor;
{% if type.verbatim %}
{{type.verbatim}}
{% endif %}
{% if type.record_verbatim %}
{{type.record_verbatim}}
{% endif %}
    {{type.type_name}}Key Key;
{% for field in type.fields if not(field.sort_order)%}
    std::optional<{{field.cpp_type}}> {{field.cpp_name}}{};
{%- endfor %}

    NYT::NTableClient::TUnversionedRow ToUnversionedRow(
        const NYT::NTableClient::TRowBufferPtr& rowBuffer,
        const {{type.type_name}}IdMapping& idMapping,
        NYT::NTableClient::EValueFlags flags = NYT::NTableClient::EValueFlags::None) const;
    static {{type.type_name}}Partial FromUnversionedRow(
        NYT::NTableClient::TUnversionedRow row,
        const {{type.type_name}}IdMapping& idMapping);
};

{% endfor %}
////////////////////////////////////////////////////////////////////////////////

} // namespace {{namespace}}
