# Функции

## Работа с lambda и Callable
### Apply
**Аргументы**:

| arg1 | arg2 | ... |
| --- | --- | --- |

**Возвращаемое значение**: lambda body after all args are filled

Возвращает тело lambda, в котором все аргументы заменены переданными значениями.

**Аргументы**:

| c | arg1 | arg2 | ... |
| --- | --- | --- | --- |
| Callable (T1,T2...)->R | T1 | T2 | ... |

**Возвращаемое значение**: R

Вызывает Callable, передавая аргументы.
Если у Callable есть опциональные аргументы, то их можно не указывать при вызове.
Вызываемая сторона при этом для незаполненных аргументов получит специальный маркер (пустой `NUdf::TUnboxedValue` в C++, `None` в Python).

### NamedApply
**Аргументы**:

| positionalArgs | namedArgs |
| --- | --- |
| tuple | tuple of (Name:atom, value) |

**Возвращаемое значение**: lambda body after all args are filled

Возвращает тело lambda, в котором все аргументы заменены переданными значениями.
Подстановка аргумента может быть проведена как по индексу (позиционная), так и по имени (именованная).
Один аргумент не может быть использован более одного раза.

**Аргументы**:

| c | positionalArgs | namedArgs | (dependentArg)* |
| --- | --- | --- | --- |
| Callable (T1,T2...)->R | tuple | tuple of (Name:atom, value) | |

**Возвращаемое значение**: R

Вызывает Callable, передавая аргументы.
Если у Callable есть опциональные аргументы, то можно перестать передавать аргументы, с точки, на которой они начинаются.
Вызываемая сторона при этом для незаполненных аргументов получит пустой Optional.
Подстановка аргумента может быть проведена как по индексу (позиционная), так и по имени (именованная).
Один аргумент не может быть использован более одного раза.
При вызове могут быть переданы зависимые аргументы. Они не участвуют в вызове Callable, но позволяют указать зависимость результата вызова от одного и более параметров. Обычно это бывает нужно при работе с мутабельными объектами Resource.

### Udf
**Аргументы**:

| name | [runConfig | [userType | [typeConfig]]] |
| --- | --- | --- | --- |
| Atom | * | Void or Type | Atom |

**Возвращаемое значение**: Callable (T1,T2...)->R

Создает Callable, представляющий функцию в некотором модуле.
name записывается в форме 'ModuleName.FunctionName'.


* `runConfig` — по умолчанию `Void`, но UDF может потребовать значение другого типа для инициализации.
* `userType` — по умолчанию `Void`, что означает, что пользовательский тип не задан. В качестве значения можно указать любой тип.
* `typeConfig` — по умолчанию пустая строка, ее формат определяется реализацией UDF.
Для заданной пары name + userType + typeConfig сигнатура Udf (тип Callable) должна быть детерминирована.

пример:
``` lisp
(let pireMatch (Udf 'Pire.Match (String '"\d")))
(let result (Apply pireMatch (String 'abc)))
```
### ScriptUdf
**Аргументы**:

| scriptType | functionName | functionType | script |
| --- | --- | --- | --- |
| Atom | Atom | CallableType | * |

**Возвращаемое значение**: Callable (T1,T2...)->R

Создает Callable, представляющий функцию в некотором модуле.
Возможные значения scriptType: { Python }


* `functionName` — определяет входную точку в скрипте.
* `functionType` — описывает тип функции (тип возвращаемого значения, количество и типы аргументов).
* `script` — тело скрипта. Может быть указан Callable, возвращающий строку.
Для заданной пары scriptType + functionName сигнатура Udf (тип Callable) должна быть детерминирована.

пример:
``` lisp
# prepare python udf
(let ui32 '['Uint32](DataType))
(let udfType (CallableType '('0) ui32Tuple ui32Tuple ui32Tuple))
(let udfScript (String '@@
def Sum(x, y):
    return x + y
@@))
(let udf (ScriptUdf 'Python 'Sum udfType udfScript))

# call udf
(let x (Uint32 '10))
(let y (Uint32 '32))
(let result (Apply udf x y))
```

### Callable
**Аргументы**:

| Callable type          | lambda |
| ---------------------- | ------ |
| TypeOf (T1,...,Tn)->R  | n args |

**Возвращаемое значение**: Callable (T1,T2...)->R

Создает Callable путем фиксации типов аргументов и результата для lambda. В Callable type не должно быть необязательных аргументов, а количество обязательных аргументов должно совпадать с количеством аргументов lambda. Тип возвращаемого значения из lambda при этом должен совпадать с типом результата в Callable type. При вызове полученного Callable происходит вызов исходной lambda.

## Конструкторы типов
### TypeOf
**Аргументы**:

| value |
| --- |
| * |

**Возвращаемый тип**: Type of value

Возвращает тип аргумента.

### DataType
**Аргументы**:

| dataTypeName |
| --- |
| Atom |

**Возвращаемый тип**: Type of Data

Описывает тип данных.

* `dataTypeName` — имя типа данных, примеры возможных значений: "Bool", "Int8", "Uint8", "Int16", "Uint16", "Int32", "Uint32", "Int64", "Uint64", "Float", "Double", "String", "Utf8", "Yson", "Json", "Date", "Datetime", "Timestamp", "Interval", "TzDate", "TzDatetime", "TzTimestamp", "Uuid". Например для Decimal(3,4) будет (DataType 'Decimal '3 '4)

### ListType
**Аргументы**:

| itemType |
| --- |
| Type |

**Возвращаемый тип**: Type of List of itemType

Описывает тип списка с заданным типом элемента.

### OptionalType
**Аргументы**:

| itemType |
| --- |
| Type |

**Возвращаемый тип**: Type of Optional of itemType

Описывает тип `Optional` с заданным типом элемента.

### TupleType
**Аргументы**:

| item1Type | ... |
| --- | --- |
| Type | ... |

**Возвращаемый тип**: Type of Tuple of (item1type...)

Описывает тип Tuple с заданными типами элементов. Допускается пустой список типов.

### StructType
**Аргументы**:

| member1 | ... |
| --- | --- |
| Tuple of (name:Atome memberType:Type) | ... |

**Возвращаемый тип**: Type of Struct of (member1.name : member1.memberType...)

Описывает тип `Struct` с заданными именами и типами элементов. Допускается пустой список пар. Имена не могут быть пустыми или повторяться.

### DictType
**Аргументы**:

| keyType | payloadType |
| --- | --- |
| Type of Data | * |

**Возвращаемый тип**: Type of Dict of (keyType, payloadType)

Описывает тип `Dict` с заданными типами ключа и значения (payload). Ключ должен иметь тип `Data`, `Optional<Data>`, либо быть непустым кортежем (`Tuple`) из этих двух типов.

### VoidType
**Аргументы**:

**Возвращаемый тип**: Type of Void

Описывает тип для значения `Void`.

### OptionalItemType
**Аргументы**:

| x |
| --- |
| Type of Optional of T |

**Возвращаемый тип**: Type of T

Возвращает тип элемента (`T`), хранящийся в `Optional<T>`.

### ListItemType
**Аргументы**:

| x |
| --- |
| Type of List of T |

**Возвращаемый тип**: Type of T

Возвращает тип элемента списка `List`.

### DictKeyType
**Аргументы**:

| x |
| --- |
| Type of Dict of K,V |

**Возвращаемый тип**: Type of K

Возвращает тип ключа словаря `Dict`.

### DictPayloadType
**Аргументы**:

| x |
| --- |
| Type of Dict of K,V |

**Возвращаемый тип**: Type of V

Возвращает тип значения (payload) словаря `Dict`.

### TupleElementType
**Аргументы**:

| x | index |
| --- | --- |
| Type of Tuple of (T1,T2,...) | Atom |

**Возвращаемый тип**: Type of T[index]

Возвращает тип указанного элемента кортежа `Tuple`.

### StructMemberType
**Аргументы**:

| x | memberName |
| --- | --- |
| Type of Struct of (member1:T1,member2:T2,...) | Atom |

**Возвращаемый тип**: Type of T[memberName]

Возвращает тип указанного элемента структуры `Struct`.

### CallableType
**Аргументы**:

| c | r | [arg1 | ... ] |
| --- | --- | --- | --- |
| Tuple of ([optionalArgsCount:Atom [Payload:Atom]]) | Tuple of (Type of R) | Tuple of (Type Of T1,[Name:Atom,[Flags:Atom]]) | |

**Возвращаемый тип**: Type of Callable (T1,T2,...)->R

Создает описание типа для `Callable` по заданным типам результата и типам аргументов.
Необязательный аргумент: количество опциональных аргументов (отсчитывается с конца списка аргументов).

### CallableResultType
**Аргументы**:

| c |
| --- |
| Type of Callable (T1,T2,...)->R |

**Возвращаемый тип**: Type R

Извлекает тип результата из переданного типа `Callable`.

### CallableArgumentType
**Аргументы**:

| c | index |
| --- | --- |
| Type of Callable (T1,T2,...)->R | Atom |

**Возвращаемый тип**: Type T[index]

Извлекает тип аргумента из переданного типа `Callable`.

### ResourceType
**Аргументы**: нет

**Возвращаемый тип**: Type of Resource

### FormatType
**Аргументы**:

| type |
| --- |
| Type of T |

**Возвращаемый тип**: Data(String)

Формирует имя типа в виде строки.

### ParseType
**Аргументы**:

| type |
| --- |
| Atom |

**Возвращаемый тип**: Type of T

Парсит описание типа из строки.

### AddMemberType
**Аргументы**:

| structType | memberName | memberType |
| --- | --- | --- |
| Type of Struct | Atom | Type |

**Возвращаемый тип**: TypeOf (AddMember (instance of structType) memberName (instance of memberType))

Вычисляет тип структуры после выполнения операции `AddMember`. Не допускается повтор имен полей, при повторе имен возникнет ошибка типизации.

### RemoveMemberType,ForceRemoveMemberType
**Аргументы**:

| structType | memberName |
| --- | --- |
| Type of Struct | Atom |

**Возвращаемый тип**: TypeOf (RemoveMember/ForceRemoveMember (instance of structType) memberName)

Вычисляет тип структуры после выполнения операции `RemoveMember/ForceRemoveMember`. Версия без `Force` требует наличия поля с указанным именем в переданной структуре.

### FlattenMembersType
**Аргументы**:

| arg1 | ... |
| --- | --- |
| tuple of (prefix1: Atom, structType1:Type of Struct or Type of Optional of Struct) |  |

**Возвращаемый тип**: TypeOf (FlattenMembers tuple of (prefix1, (instance of structType1))...)

Вычисляет тип структуры после выполнения операции `FlattenMembers`. В случае повтора имен полей возникнет ошибка типизации.

### VariantType
**Аргументы**:

| underlyingType |
| --- |
| Type |

**Возвращаемый тип**: Type of Variant of underlyingType

Описывает тип `Variant` с заданным базовым типом. В качестве базового типа допускаются либо непустой `Tuple`, либо непустой `Struct`.

### VariantUnderlyingType
**Аргументы**:

| x |
| --- |
| Type of Variant of T |

**Возвращаемый тип**: Type of T

Возвращает базовый тип для `Variant`: `Tuple` или `Struct`.

## Конструкторы
### Tuple
Для создания кортежа (`Tuple`) используется синтаксис цитирования списка вместо вызова функции — см. **LIST_VALUE**.
Пример: '('A B) создаст `Tuple` с двумя элементами: первый — атом со значением A, второй — биндинг с именем B.
Тип для `Tuple` будет определяться последовательностью типов каждого элемента.
Пустой кортеж создается как `'()`.

### DataSource
**Аргументы**:

| category | ... |
| --- | --- |
| Atom | |

**Возвращаемый тип**: DataSource.

Представляет собой ссылку на источник данных.
Первым аргументом является атом с названием категории `DataSource`, например, "yamr". Разбор остальных аргументов зависит от провайдера данных.

### DataSink
**Аргументы**:

| category | ... |
| --- | --- |
| Atom | |

**Возвращаемый тип**: DataSink.

Представляет собой ссылку на приемник данных.
Первым аргументом является атом с названием категории `DataSink`, например, "yamr". Разбор остальных аргументов зависит от провайдера данных.

### Data

#### String
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(String)

Заворачивает атом как типизированное значение с типом `String`.

#### Yson
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(Yson)

Заворачивает атом как типизированное значение с типом `Yson`.

#### Utf8
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(Utf8)

Заворачивает атом как типизированное значение с типом `Utf8`.

#### Byte
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(Byte)

Заворачивает атом как типизированное значение с типом `Byte (unsigned)`.

#### Int32
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(Int32)

Заворачивает атом как типизированное значение с типом `Int32`.

#### Uint32
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(Uint32)

Заворачивает атом как типизированное значение с типом `Uint32`.

#### Int64
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(Int64)

Заворачивает атом как типизированное значение с типом `Int64`.

#### Uint64
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(Uint64)

Заворачивает атом как типизированное значение с типом `Uint64`.

#### Bool
**Аргументы**:

| atom |
| --- |
| Atom |

**Возвращаемый тип**: Data(Bool)

Заворачивает атом как типизированное значение с типом `Bool`.

### Key
**Аргументы**:

| arg1 | ... |
| --- | --- |
| keyItem:tuple of (tag:Atom value:*?) | |

**Возвращаемый тип**: Key.

Конструктор ключа, состоящий из последовательности пар вида тег—значение (опциональное).
Используется для описания координат для чтения/записи в `DataSource/DataSink`.

### Struct
**Аргументы**: нет

**Возвращаемый тип**: Struct of ()

Создает пустую структуру.

**Аргументы**:

| structType | value1 | ... |
| --- | --- | --- |
| Type Of Struct | Tuple of (name: Atom, value:*) | |

**Возвращаемый тип**: structType

Создает структуру с заданным типом и значениями. Количество значений и их типы должны совпадать с количеством полей в типе. Имена значений могут быть заданы в произвольном порядке.

### Just
**Аргументы**:

| item |
| --- |
| * |

**Возвращаемый тип**: Optional (typeof item)

Возвращает заполненный Optional, содержащий заданный item.

### Nothing
**Аргументы**:

| optionalType |
| --- |
| Type of Optional of T |

**Возвращаемый тип**: optionalType

Возвращает пустой Optional заданного типа.

### Optional
**Аргументы**:

| optionalType | value |
| --- | --- |
| Type of Optional of T | T |

**Возвращаемый тип**: optionalType

Возвращает заполненный Optional, проверяя, что он соответствует заданному типу.

### List
**Аргументы**:

| listType | [item1 | ...] |
| --- | --- | --- |
| Type of List of T | T | |

**Возвращаемый тип**: listType

Возвращает список заданного типа. Все элементы, если они указаны, должны быть одного типа, равного типу элемента в типе списка.

### Dict
**Аргументы**:

| dictType | value1 | ... |
| --- | --- | --- |
| Type Of Dict | Tuple of (key:*, value:*) | |

**Возвращаемый тип**: dictType

Создает словарь с заданным типом и значениями ключей/пайлоада. Типы ключей/пайлоада должны совпадать с теми, которые указаны в типе словаря.

### Void
**Аргументы**:

**Возвращаемый тип**: void

Возвращает экземпляр `Void`.

### InstanceOf
**Аргументы**: type:Type

| type |
| --- |
| Type |

**Возвращаемый тип**: Type

Возвращает экземпляр `Type`.
Не должна исполняться: предназначена только для вычисления типов (например, подстановки в лямбда-функцию).

### Variant
**Аргументы**:

| item | index | varType |
| --- | --- | --- |
| T | Atom | Variant of Tuple |

**Возвращаемый тип**: varType

Создает экземпляр `Variant`, заполняет в нем элемент с заданным индексом. При этом тип элемента (item) должен совпадать с тем, что описано в `Tuple`.

**Аргументы**:

| item | name | varType |
| --- | --- | --- |
| T | Atom | Variant of Struct |

**Возвращаемый тип**: varType

Создает экземпляр `Variant`, заполняет в нем элемент с заданным именем. При этом тип элемента (item) должен совпадать с тем, что описано в `Struct`.

### ToSequence
**Аргументы**:

| input |
| --- |
| InputType |

**Возвращаемый тип**:

* InputType, если InputType: List of T, или Stream of T, или Optional of T
* Optional of InputType, в противном случае

Переводит входящий аргумент `input` в "перечислимый" тип, а именно, если входящий `InputType` был Stream, List, Optional, то оставляет его без изменений, иначе входящему добавляется Optional

## Операции с внешним миром
### Read!
**Аргументы**:

| world | datasource | key | fields | options |
| --- | --- | --- | --- | --- |
| World | DataSource | Key | * | * |

**Возвращаемый тип**: Tuple of (World, *), где второй элемент пары — обычно коллекция данных, определяется провайдером данных.

Чтение из источника данных, типы fields и options определяются провайдером данных.

### Write!
**Аргументы**:

| world | datasink | key | data | options |
| --- | --- | --- | --- | --- |
| World | DataSink | Key | * | * |

**Возвращаемый тип**: World

Запись в приемник данных, типы data и options определяются провайдером данных.

### Commit!
**Аргументы**:

| world | datasink |
| --- | --- |
| World | DataSink |

**Возвращаемый тип**: World

Завершение транзакции в приемнике данных.

### Configure!
**Аргументы**:

| world | dataprovider | ... |
| --- | --- | --- |
| World | DataSource or DataSink | |

**Возвращаемый тип**: World

Конфигурирование провайдера данных. Должно быть выполнено до начала операций с провайдером этой категории. Параметры и/или наличие поддержки операции `Configure!` определяются провайдером данных.

### Sync!
**Аргументы**:

| world1 | [world2 | ...] |
| --- | --- | --- |
| World | World | |

**Возвращаемый тип**: World

Соединяет несколько зависимостей в одну.

### If!
**Аргументы**:

| world | predicate | worldThen | worldElse |
| --- | --- | --- | --- |
| World | Data(Bool) | World | World |

**Возвращаемый тип**: World

В зависимости от значения предиката вызывает расчет либо мира `worldThen`, либо `worldElse`.

## Операции с Atom
### Combine
**Аргументы**:

| item1 | [item2 | ...] |
| --- | --- | --- |
| Atom | Atom | |

**Возвращаемый тип**: atom

Склеивает переданные атомы в один.

## Операции с Tuple
### Left!
**Аргументы**:

| pair |
| --- |
| Tuple of world,T |

**Возвращаемый тип**: world

Извлекает первый элемент пары.

### Right!
**Аргументы**:

| pair |
| --- |
| Tuple of world,T |

**Возвращаемый тип**: T

Извлекает второй элемент пары.

### Nth
**Аргументы**:

| tuple | index |
| --- | --- |
| Tuple | Atom |

**Возвращаемый тип**: typeof(tuple item at index)

Извлекает по индексу значение из `Tuple`.

**Аргументы**:

| tuple | index |
| --- | --- |
| Optional of Tuple | Atom |

**Возвращаемый тип**: Optional of typeof(tuple item at index) or typeof(tuple item at index)

Извлекает по индексу значение из опционального `Tuple`.
Тип результата оборачивается Optional, если только он уже не был Optional.
Если не было самого кортежа (`Tuple`), результат — пустой Optional.

## Операции с List (и другими контейнерами как с List)

### Filter, OrderedFilter
**Аргументы**:

| list | predicate |
| --- | --- |
| List/Stream/Optional of T | Lambda (item:T)->Data(Bool) |

**Возвращаемый тип**: TypeOf(list)

Фильтрует список,стрим или optional, оставляя только элементы, для которых предикат вернул `true`.
Порядок элементов в результате не определен для `Filter` и совпадает с порядком исходной последовательности для `OrderedFilter`.

### TakeWhile
**Аргументы**:

| list | predicate |
| --- | --- |
| List/Stream/Optional of T | Lambda (item:T)->Data(Bool) |

**Возвращаемый тип**: TypeOf(list)

Фильтрует список/стрим/optional, выдавая элементы, пока предикат истинный, далее останавливается

### TakeWhileInclusive
**Аргументы**:

| list | predicate |
| --- | --- |
| List/Stream/Optional of T | Lambda (item:T)->Data(Bool) |

**Возвращаемый тип**: TypeOf(list)

Фильтрует список/стрим/optional, выдавая элементы, пока предикат истинный, далее останавливается, но так же включает элемент, на котором сработал останавливающий предикат.

### SkipWhileInclusive
**Аргументы**:

| list | predicate |
| --- | --- |
| List/Stream/Optional of T | Lambda (item:T)->Data(Bool) |

**Возвращаемый тип**: TypeOf(list)

Фильтрует список/стрим/optional, сначала пропуская все элементы, пока предикат истинный, далее выдает все без остатка, но не включая элемент, на котором сработал предикат, а начинает со следующего за ним.

### SkipWhile
**Аргументы**:

| list | predicate |
| --- | --- |
| List/Stream/Optional of T | Lambda (item:T)->Data(Bool) |

**Возвращаемый тип**: TypeOf(list)

Фильтрует список/стрим/optional, сначала пропуская все элементы, пока предикат истинный, далее выдает все без остатка, не обращая внимания на предикат.

### Map, OrderedMap
**Аргументы**:

| list | handler |
| --- | --- |
| List/Stream/Optional of T | Lambda (item:T)->U |

**Возвращаемый тип**: List/Stream/Optional of U

Преобразует список,стрим или optional вызывая handler для каждого элемента.
Порядок элементов в результате не определен для `Map` и совпадает с порядком исходной последовательности для `OrderedMap`.
Вид последовательности совпадает с тем, что в аргументе list (т.е. только меняется тип T на U).

### MapNext
**Аргументы**:

| list | handler |
| --- | --- |
| Stream of T | Lambda (item:T, nextItem:T?)->U |

**Возвращаемый тип**: Stream of U

Преобразует стрим вызывая handler для каждого элемента. В handler передаются текущий и следующий элемент стрима.
Если следующий элемент отсутствует, то в качестве nextItem передается пустой `Optional`.
Порядок элементов в результате совпадает с порядком исходной последовательности.

### FoldMap
**Аргументы**:

| list | state | handler |
| --- | --- | --- |
| List/Stream of T | S | Lambda (item:T state:S)->Tuple of (U S) |

**Возвращаемый тип**: List/Stream of U

Преобразует каждый элемент списка или стрима, вызывая `handler` для каждого элемента, передавая `state`, полученный при обработке предыдущего элемента. Количество элементов в результирующем списке как у исходного. Соответствующий начальный `state` создаётся до вызова. Lambda `handler` должна возвращать литеральный tuple.
Вид типа выхода соответствует виду входа.

### Fold1Map
**Аргументы**:

| list | init | update |
| --- | --- | --- |
| List/Stream of T | Lambda (item:T)->Tuple of (U S) | Lambda (item:T state:S)->Tuple of (U S) |

**Возвращаемый тип**: List/Stream of U

Преобразует каждый элемент списка по следующей процедуре:

* для первого элемента вызывает `init` и создаёт `state` и новый элемент списка;
* для последующих элементов вызывает `update` и передаёт `state`, полученный при обработке предыдущего элемента, как результат лямбды получает новый элемент и новый `state`.
* Количество элементов в результирующем списке как у исходного.

Lambda `init` и `update` должны возвращать литеральный tuple.
Вид типа выхода соответствует виду входа.

### Chain1Map
**Аргументы**:

| list | init | update |
| --- | --- | --- |
| List/Stream of T | Lambda (item:T)->S | Lambda (item:T state:S)->S |

**Возвращаемый тип**: List/Stream of S

Преобразует каждый элемент списка по следующей процедуре:

* для первого элемента вызывает `init` и создаёт `state` который также является следующим элементом результата;
* для последующих элементов вызывает `update` и передаёт как `state` результат обработки предыдущего элемента, а как результат лямбды получает новый `state` и он же следующий элемент.
* Количество элементов в результирующем списке как у исходного.

Вид типа выхода соответствует виду входа.

### FlatMap, OrderedFlatMap

**Аргументы**:

| list | handler |
| --- | --- |
| List/Stream/Optional of T | Lambda (item:T)->List/Stream/Optional of U |

**Возвращаемый тип**: List/Stream/Optional of U

Преобразует список,стрим или optional, вызывая `handler` для каждого элемента и объединяя результирующие последовательности.
Порядок объединения и положения элементов в нем не определены для `FlatMap`. Для `OrderedFlatMap` порядок элементов выходной последовательности совпадает с порядком исходной последовательности.
Если вид входа List или Stream, то такой же и тип выхода. А если вид входа - Optional, то вид выхода совпадает с тем, что вернул `handler`.

### StaticMap
**Аргументы**:

| tuple | handler |
| --- | --- |
| Tuple of (T1,T2...) | Lambda (item:T)->U |

**Возвращаемый тип**: Tuple of (Lambda(item1), Lambda(item2)...)

Преобразует `tuple`, вызывая `handler` для каждого элемента. Возвращает `Tuple` того же размера с поэлементно преобразованными элементами.

**Аргументы**:

| struct | handler |
| --- | --- |
| Struct of (name1:T1,name2:T2...) | Lambda (item:T)->U |

**Возвращаемый тип**: Struct of (name1:Lambda(item1), name2:Lambda(item2)...)

Преобразует `struct`, вызывая `handler` для каждого элемента. Возвращает структуру того же размера и с теми же именами полей с поэлементно преобразованными элементами.

### StaticZip
**Аргументы**:

| tuple1 | tuple2 | [tuple3 ...] |
| --- | --- | --- |
| Tuple of (T1,T2...) | Tuple of (U1,U2...) | Tuple of (V1, V2...) |

**Возвращаемый тип**: Tuple of (Tuple of (T1, U1, V1...), TupleOf (T2, U2, V2...), TupleOf(T3, U3, V3...)...)

Склеивает элементы аргументов с одинаковыми позициями в `tuple`. Все аргументы должны быть `tuple` одного размера. Возвращает `tuple` того же размера.

**Аргументы**:

| struct1 | struct2 | [struct3 ...] |
| --- | --- | --- |
| Struct of (name1:T1,name2:T2...) | Struct of (name1:U1,name2:U2...) | Struct of (name1:V1,name2:V2...) |

**Возвращаемый тип**: Struct of (name1:Tuple of (T1, U1, V1...), name2:Tuple of (T2, U2, V2...), name3: Tuple of (T3, U3, V3...)...)

Склеивает элементы аргументов с одинаковыми именами в `tuple`. Все аргументы должны быть структурами с одинаковым набором имен. Возвращает структуру с тем же набором имен.

### Sort

**Аргументы**:

| list | ascending | keySelector |
| --- | --- | --- |
| List of T | Data(Bool) | Lambda (item:T)->Data(U) |

**Возвращаемый тип**: List of T

Сортирует список по одному полю, возвращаемому из `keySelector`. Порядок сортировки задается параметром `ascending`.

**Аргументы**:

| list | ascending | keySelector |
| --- | --- | --- |
| List of T | Tuple of Data(Bool) | Lambda (item:T)->Tuple of Data(U) |

**Возвращаемый тип**: List of T

Сортирует список по нескольким полям, возвращаемым из `keySelector`. Порядок сортировки по каждому полю задается параметром `ascending`.
Размеры `Tuple` для результата функции и `ascending` должны совпадать и быть не меньше 2.

### GroupByKey

**Аргументы**:

| list | keySelector | listHandler |
| --- | --- | --- |
| List of T | Lambda (item:T)->K | Lambda (key: K, list: List of T)->List of V |

**Возвращаемый тип**: List of V

Тип `K` должен быть либо `Data`, либо `Optional of Data`, либо `Tuple` из них.
Группирует список по ключу.

* Ключ генерируется путем применения `keySelector` к каждому элементу списка.
* Для каждого ключа строит список элементов, содержащих это значение ключа.
* Построенная пара ключ—список передается в `listHandler`.
* Списки, полученные по всем вызовам `listHandler`, объединяются в один список, как в `FlatMap`.

Порядок элементов в списках, поступающих в `listHandler`, а также порядок объединения общего списка не определен.

### CombineByKey

**Аргументы**:

| list | preMap | keySelector | initHandler | updateHandler | finishHandler |
| --- | --- | --- | --- | --- | --- |
| List of T | Lambda (item:T)->List of P or Optional of P | Lambda (item:P)->K | Lambda (key: K, item: P)->S | Lambda (key: K, item: P, state: S)->S | Lambda (key:K, state:S)->List of V or Optional of V |

**Возвращаемый тип**: List of V

Применяет функцию `preMap` к исходному списку, после чего группирует полученный список по ключу, сгенерированному в результате применения `keySelector` к каждому элементу полученного списка.
Порядок обработки:

* Для каждого ключа строит список элементов.
* Для первого элемента каждого такого списка вызывается `initHandler`, который возвращает `state`.
* Для второго и последующего элементов вызывается `updateHandler`, в которой передается `state` и возвращается новый `state`.
* В конце обработки каждого ключа вызывается `finishHandler`.
* Результаты от всех вызовов `finishHandler` объединяются в один список, как в `FlatMap`.

Порядок элементов в списках, поступающих в `initHandler/updateHandler`, а также порядок объединения общего списка не определен.

### Fold
**Аргументы**:

| list | state | handler |
| --- | --- | --- |
| List/Optional of T | U | Lambda (item:T, state:U)->U |

**Возвращаемый тип**: U

Преобразует список или optional, вызывая `handler` для каждого элемента, передавая `state`, полученный при обработке предыдущего элемента. В результате обработки всего списка возвращается последнее значение `state` либо начальное значение `state`, если последовательность пуста.

### Fold1
**Аргументы**:

| list | initLambda | updateLambda |
| --- | --- | --- |
| List/Optional of T | Lambda (item:T)->U | Lambda (item:T, state:U)->U |

**Возвращаемый тип**: optional of U

Преобразует список или optional по следующей процедуре:

* для первого элемента вызывает `initLambda` и создает `state`;
* для последующих элементов вызывает `updateLambda` и передает `state`, полученный при обработке предыдущего элемента.
* при достижении последнего элемента возвращает заполненный `Optional`, содержащий последнее значение `state`, либо пустой `Optional`, если исходная последовательность была пуста.

### ListIf
**Аргументы**:

| predicate | item |
| --- | --- |
| Data(Bool) | T |

**Возвращаемый тип**: List of T

Возвращает список из одного элемента, содержащего `item`, если предикат вернул `true`, иначе — пустой список.

### AsList
**Аргументы**:

| item1 | [item2 | ...] |
| --- | --- | --- |
| T | T | |

**Возвращаемый тип**: List of T

Возвращает список из одного или более элементов. Типы всех элементов должны совпадать.

### ToList
**Аргументы**:

| item |
| --- |
| List/Optional of T |

**Возвращаемый тип**: List of T

Переводит свой аргумент в список. А именно:
* Если аргумент - заполненный `Optional`, то возвращает список из одного элемента. Т.е. для `Just x` возвращает `AsList x`
* Если аргумент - пустой `Optional`, то возвращает пустой список
* Если аргумент - список, то возвращает аргумент

### FlatListIf
**Аргументы**:

| predicate | item |
| --- | --- |
| Data(Bool) | List of T |

**Возвращаемый тип**: List of T

Возвращает `item`, если предикат вернул `true`, иначе — пустой список.

### FlatOptionalIf
**Аргументы**:

| predicate | item |
| --- | --- |
| Data(Bool) | Optional of T |

**Возвращаемый тип**: Optional of T

Возвращает `item`, если предикат вернул `true`, иначе — пустой `Optional`.

### Append
**Аргументы**:

| list | item |
| --- | --- |
| List of T | T |

**Возвращаемый тип**: List of T

Добавляет элемент в конец списка.

### Insert
**Аргументы**:

| list | item |
| --- | --- |
| List of T | T |

**Возвращаемый тип**: List of T

Добавляет элемент в список, положение добавленного элемента в списке не определено.

### Prepend
**Аргументы**:

| item | list  |
| --- | --- |
| T | List of T |

**Возвращаемый тип**: List of T

Добавляет элемент в начало списка.

### Extend, OrderedExtend, Merge {#extend} {#orderedextend}
**Аргументы**:

| list1 | [list2 | ...] |
| --- | --- | --- |
| List of T | List of T | |

**Возвращаемый тип**: List of T

Объединение списков одного типа. Порядок элементов после объединения для `Extend` не определен. Для `OrderedExtend` сначала идут элементы первого списка с сохранением его порядка, а затем элементы второго списка с сохранением его порядка и т.д. Для `Merge` порядок элементов упорядочен по общему префиксу сортировки, если входные списки являются сортированными списками структур, иначе порядок не определен как и для `Extend`.

{% if rtmr != true %}

### UnionAll, UnionMerge
**Аргументы**:

| list1 | [list2 | ...] |
| --- | --- | --- |
| List of Struct T1 | List of Struct T2 | |

**Возвращаемый тип**: List of Struct T'

Объединение списков структур по правилам [UNION ALL](/docs/yt/syntax/select#unionall) из SQL. Порядок элементов после объединения для `UnionAll` не определен. Для `UnionMerge` порядок элементов упорядочен по общему префиксу сортировки, если входные списки являются сортированными списками структур, иначе порядок не определен как и для `UnionAll`.

{% endif %}

### Length
**Аргументы**:

| list |
| --- |
| List of T |

**Возвращаемый тип**: Data(Uint64)

Длина списка.

### HasItems
**Аргументы**:

| list |
| --- |
| List of T/Dict of T |

**Возвращаемый тип**: Data(Bool)

Возвращает `true`, если список не пуст.

### Skip
**Аргументы**:

| list | len |
| --- | --- |
| List or Stream of T | Data(Uint64) |

**Возвращаемый тип**: List or Stream of T

Пропустить `len` элементов в списке/потоке. Если `len` превышает количество элементов в списке/потоке, будет возвращен пустой список/поток.

### Take
**Аргументы**:

| list | len |
| --- | --- |
| List or Stream of T | Data(Uint64) |

**Возвращаемый тип**: List or Stream of T

Взять не более `len` элементов в списке/потоке. Если `len` превышает количество элементов в списке/потоке, то будет возвращен исходный список/поток.

### ToOptional
**Аргументы**:

| list |
| --- |
| List of T |

**Возвращаемый тип**: Optional of T

Если список не пуст, возвращает заполненный Optional с первым элементом списка, иначе - пустой Optional.

### Reverse
**Аргументы**:

| list |
| --- |
| List of T |

**Возвращаемый тип**: List of T

Обращение списка.

### Zip
**Аргументы**:

| list1 | ... |
| --- | --- |
| List of T1 | |

**Возвращаемый тип**: List of Tuple(T1 ...)

Построение списка, каждый элемент которого представляет собой кортеж из соответствующих друг другу элементов каждого из переданных списков. Длина возвращаемого списка определяется самым коротким списком.

### ZipAll
**Аргументы**:

| list1 | ... |
| --- | --- |
| List of T1 | |

**Возвращаемый тип**: List of Tuple(Optional of T1 ...)

Построение списка, каждый элемент которого представляет собой кортеж из соответствующих друг другу элементов каждого из переданных списков. Длина возвращаемого списка определяется самым длинным списком. После исчерпания списка на месте его элементов возвращаются пустые `Optional`.

### Extract, OrderedExtract
**Аргументы**:

| list | memberName |
| --- | --- |
| List of Struct | Atom |

**Возвращаемый тип**: List of (Member Struct memberName)

Строит новый список, извлекая поле структуры из списка структур. Порядок в новом списке сохраняется только для `OrderedExtract`.

**Аргументы**:

| list | memberName |
| --- | --- |
| Optional of Struct | Atom |

**Возвращаемый тип**: Optional of (Member Struct memberName)

Строит новый `Optional`, извлекая поле структуры из `Optional` со структурой.
Если входной `Optional` пуст, то генерируется пустой `Optional`.

**Аргументы**:

| list | index |
| --- | --- |
| List of Tuple | Atom |

**Возвращаемый тип**: List of (Nth Tuple index)

Строит новый список, извлекая поле кортежа из списка кортежей. Порядок в новом списке сохраняется только для `OrderedExtract`.

**Аргументы**:

| list | index |
| --- | --- |
| Optional of Tuple | Atom |

**Возвращаемый тип**: Optional of (Nth Tuple index)

Строит новый `Optional`, извлекая поле `Tuple` из `Optional`, содержащего `Tuple`.
Если входной `Optional` пуст, то генерируется пустой `Optional`.

### ExtractMembers
**Аргументы**:

| list | memberNames |
| --- | --- |
| List or Stream or Optional | tuple of Atom |

**Возвращаемый тип**: List or Stream or Optional of Struct with filtered members

Фильтрует список/поток/Optional оставляя только указанные поля в структурах.

### Enumerate
**Аргументы**:

| list | [start | [step]] |
| --- | --- | --- |
| List of T | Data(Uint64) | Data(Uint64) |

**Возвращаемый тип**: List of Tuple(Uint64, T)

Построение списка пар,  в первом элементе пары находится индекс элемента, во втором — сам элемент списка. Элементы нумеруются, начиная со значения аргумента `start`. Каждый последующий индекс увеличивается на величину `step`. Значение по умолчанию для start = 0, для step = 1.

### ListFromRange
**Аргументы**:

| start | end | [step] |
| --- | --- | --- |
| T1 | T2 | T3 |

**Возвращаемый тип**: List of Common type(T1,T2,T3)

Типы T1,T2,T3 должны быть простыми (числовыми или дата/время) - для типа элементов списка в результате будет использован объединяющий тип.
Если хотя бы один из типов опционален, то возвращаемый список опционален.
Если хотя бы один из параметров Nothing(T?), то результат Nothing(CommonType?).
Если среди параметров есть параметр типа NullType, то он не участвует в выводе CommonType.
Если step не задан, то его значение равно Uint8(1).
Функция строит ленивый список, состоящий из таких чисел x, что start <= x < end если step >0, или start >= x > end если step < 0.
Если start >= end при step > 0 или start <= end при step < 0, то возвращается пустой список.
Для случая step равного 0 или NaN возвращается пустой список.
Если start или end равны NaN, то условия отбора в список никогда не выполняется и возвращается пустой список.

### Replicate
**Аргументы**:

| item | count |
| --- | --- |
| T | ui64|

**Возвращаемый тип**: List of T

Возвращает список из объекта item, повторенного count раз

### Join
**Аргументы**:

| list1 | list2 | keyExtractor1 | keyExtractor2 | kind |
| --- | --- | --- | --- | --- |
| List of T | List of U | Lambda (item:T)->V | Lambda (item:U)->V | Atom |
V = Data(X) | Tuple of (Data(X), ...)

**Возвращаемый тип**:

* List of Tuple(T, U) если kind = Inner
* List of Tuple(T, Optional of U) если kind = Left
* List of Tuple(Optional of T, U) если kind = Right
* List of Tuple(Optional of T, Optional of U) если kind = Full

Объединяет два списка в один, группируя элементы с равными ключами. Ключ для каждого списка генерируется соответствующей lambda-функцией.
Тип ключей — либо `Data`, либо непустой `Tuple`, все элементы которого имеют тип `Data`.
Порядок формирования выходного списка не определен. При повторении ключей будет возвращено декартово произведение по заданному ключу пар элементов первого и второго списка.

{% if rtmr != true %}
### EquiJoin
**Аргументы**: list1:listDef list2:listDef ...  joinTree globalSettings:settings

| list1 | list2 | ... | joinTree | globalSettings |
| --- | --- | --- | --- | --- |
| ""Tuple of (List of Struct, TableName: Atom | Tuple of Atoms)"" | ""Tuple of (List of Struct, TableName: Atom | Tuple of Atoms)"" |  | ""Tuple of (Kind: Atom, left: Atom | joinTree, right: Atom | joinTree, leftColumns: joinColumns, rightColumns: joinColumns, linkSettigs: settings)"" | Tuple of Tuple of (Atom,...) |

joinColumns = Tuple of (TableName: Atom, Column: Atom ...)

**Возвращаемый тип**: List of Struct

В возвращаемом типе содержатся колонки вида `tableI.columnJ`, где `tableI` — все исходные таблицы, за исключением тех, по которым проводился semi join или only join, `columnJ` — их колонки.
Если колонка — ключевая и имела тип `Optional`, и тип `Join` для ее стороны (правая/левая) не дает пустых строк, то ее тип очищается от `Optional`, так как при выполнении `Join` пустые `Optional` отбрасываются.
Если типы колонок для сравнения — совместимые, но разные (например, `Int32` и `Uint32`), то они оба приводятся к общему типу, который и будет указан в возвращаемом типе.

`EquiJoin` Выполняет JOIN нескольких входов, каждый из который является списком структур, в выходной список структур.
Если в `listDef` имя таблицы задано в виде атома, то оно добавляется в виде `table.column` в имена полей выходных структур.
Если имя таблицы задано в виде непустого `Tuple`, то выполняется проверка, что такая таблица(-ы) есть в исходном списке таблиц, указанном в аргументах EquiJoin.

Поддерживаемые виды JOIN (Kind):
Inner, Left, Right, Full, LeftOnly, RightOnly, Exclusion, LeftSemi, RightSemi. Подробнее см. [описание функции JOIN](/docs/yt/syntax/join) в руководстве пользователя.

В `JoinColumn` указываются пары таблица—колонка, по которым проводится сравнение. Типы ключевых колонок могут быть только `Data` или `Optional of Data`.
В последнем случае отбрасываются все записи, в которых хотя бы одна ключевая колонка содержит незаполненный `Optional`.
В выходном списке все ключевые колонки становятся non-optional, даже если были таковыми на входе. Если же указанный тип JOIN подразумевает отсутствие какой-либо части, то в выдаче все колонки этой части возвращаются пустыми `Optional`.

В `JoinTree` листовыми узлами являются имена таблиц, для которых выполняется слияние. По мере приближения к корню `JoinTree` в scope для сравнения могут попадать таблицы по правому или левому поддереву.
Порядок выдачи выходного списка не определен.
На типы неключевых колонок нет ограничений, кроме того, что они должны быть сериализуемыми (`Persistable`).
{% endif %}

### AggregationTraits
**Аргументы**:

| item type | init | update  | save | load | merge | finish |
| --- | --- | --- | --- | --- | --- | --- |
| Type of T | Lambda (T[,parent])->S1 | Lambda (T,S1[,parent])->S1 | Lambda (S1)->U | Lambda (U)->S2 | Lambda (S2,S2)->S2 | Lambda (S2)->V |

**Возвращаемый тип**: Void

Функция не предназначена для самостоятельного использования, только как trait колонки в функции `Aggregate`.
Проводит типизацию 6 возможных действий при проведении агрегации: init, merge, update, save, load, finish.
Тип `U` должен быть сериализуемым (persistable).

{% note info "Примечание" %}

Если в init/update lambda используется работа с созданием **мутабельного Resource**, то вызываемому значению (Callable), создавшему Resource, следует передать зависимый аргумент — параметр `parent` с типом `Uint32`. Обычно это делается с помощью вызова `NamedApply`, но можно создать отдельный аргумент типа `Uint32` в Callable (UDF-функции), создающей Resource. Передача этого аргумента необходима, чтобы разные агрегационные функции не склеились при оптимизации графа вычислений, что привело бы к неверному результату.

{% endnote %}

### Aggregate
**Аргументы**:

| list | key columns | aggregated columns |
| --- | --- | --- |
| List of Struct | Tuple of (columnName:Atom) | Tuple of aggregated description |

aggregated description: Tuple of (columnName:Atom || Tuple of (columnName1, columnName2 ...), trait : AggregationTraits, [distinct field:Atom])

**Возвращаемый тип**: List of Struct (key columns + aggregated columns)

Проводится агрегация списка структур. Для каждой ключевой колонки в исходном списке (которая может иметь тип `Data` или `Optional of Data`) будет возвращена такая же колонка в выходном списке.
Для агрегируемых колонок может быть задано одно или более имя. Если имя одно, то оно имеет тип `U` в соответствующем `AggregationTraits`.
Если же имен несколько, то тип `U` в соответствующем `AggregationTraits` должен представлять собой `Tuple`. Для каждого имени будет взят соответствующий по позиции элемент `Tuple`.

`AggregationTraits` описывают агрегацию всей строки исходного списка, если не задан режим `distinct`.
Если задано имя поля для `distinct`, то поле должно иметь тип `Data` или `Optional of Data`. В этом случае тип `T` в `AggregationTraits` описывает не строку списка, а отдельный member с тем именем, для которого проводится `distinct`.

В общем случае сначала в AggregationTraits используется init, update, save операции в операции Map Combine, а далее — load merge и finish в операции Reduce.
Порядок поступления элементов в update/merge не определен.

## Операции с Struct
### Member
**Аргументы**:

| struct | name |
| --- | --- |
| Struct | Atom |

**Возвращаемый тип**: typeof(member with name in Struct)

Извлекает по имени из структуры значение.

**Аргументы**:

| struct | name |
| --- | --- |
| Optional of Struct | Atom |

**Возвращаемый тип**: Optional of typeof(member with name in Struct) or typeof(member with name in Struct)

Извлекает по имени из опциональной структуры значение.
Тип результата оборачивается `Optional`, если только он уже не был Optional.
Если не было самой структуры, результат — пустой `Optional`, иначе — значение из структуры, при необходимости завернутое в `Optional`.

### AddMember
**Аргументы**:

| struct | name | value |
| --- | --- | --- |
| Struct | Atom | * |

**Возвращаемый тип**: typeof(Struct with new member name/typeof value)

Создает новую структуру, с добавленным именем/значением.

### RemoveMember, ForceRemoveMember {#removemember} {#forceremovemember}
**Аргументы**:

| struct | name |
| --- | --- |
| Struct | Atom |

**Возвращаемый тип**: typeof(Struct without member name)

Создает новую структуру без указанного поля. `RemoveMember` требует, чтобы это поле было в структуре, тогда как `ForceRemoveMember` в этом случае вернет структуру без изменений.

### ReplaceMember
**Аргументы**:

| struct | name | value |
| --- | --- | --- |
| Struct | Atom | * |

**Возвращаемый тип**: typeof(Struct with replaced member name/typeof value)

Создает новую структуру с измененным значением у заданного поля. Тип у нового значения может отличаться от типа значения в исходной структуре.

### AsStruct
**Аргументы**:

| [item1 | ...] |
| --- | --- |
| Tuple of (name1:Atom value1:T1) |  |

**Возвращаемый тип**: Struct of (name1:value1)...

Создает структуру из заданных имен и значений полей.

### FlattenMembers
**Аргументы**:

| item1 | ... | itemN |
| --- | --- | --- |
| (Tuple of (prefix1:Atom struct1:Struct1[?] of (Name1_1:Value1_1...)) | ... | (Tuple of (prefixN:Atom structN:StructN[?] of (NameN_1:ValueN_1...)) |

**Возвращаемый тип**: Struct of (prefix1+name1_1:value1_1 ... prefix1+Name1_K1:value1_K1 ... prefixN+nameN_1:valueN_1 ...)

Создает структуру, в которой объединены поля заданных структур, причем указанный префикс добавляется к каждому полю заданных структур.
Если в каком-то аргументе передан `Optional of Struct`, то типы колонок вычисляются как в `Member` — для колонки типа `Optional Of U` тип не меняется, в противном случае к типу добавляется `Optional`.

### SelectMembers
**Аргументы**:

| struct | prefixes |
| --- | --- |
| OrigStruct | Tuple of (prefix1:Atom ... prefixN:Atom) |

**Возвращаемый тип**: Subset members of OrigStruct

Создает структуру, в которой от исходной структуры оставлены только те поля, префикс которых соответствует любому из `prefix1, ..., prefixN`.

### FilterMembers
**Аргументы**:

| struct | members |
| --- | --- |
| OrigStruct | Tuple of (member1:Atom ... memberN:Atom) |

**Возвращаемый тип**: Subset members of OrigStruct

Создает структуру, в которой от исходной структуры оставлены только указанные поля.

### DivePrefixMembers
**Аргументы**:

| struct | prefixes |
| --- | --- |
| OrigStruct | Tuple of (prefix1:Atom ... prefixN:Atom) |

**Возвращаемый тип**: Subset members of OrigStruct

Создает структуру, в которой от исходной структуры оставлены только те поля, префикс которых соответствует любому из `prefix1, ..., prefixN`, но, в отличие от SelectMembers, от полей отрезается соответствующий префикс. Если поле структуры соответствует нескольким префиксам, то отрезается префикс с наибольшей длиной.

### CastStruct
**Аргументы**:

| struct | newType |
| --- | --- |
| Struct1 | Type of Struct2 |

**Возвращаемый тип**: Type of Struct2

Преобразует структуру в заданный тип. Если типы структур отличаются, то поля в `Struct2` можно только убирать по отношению к `Struct1`, а тип их должен быть тем же самым.

### FlattenByColumns
**Аргументы**:

| Struct T            | column1: Atom                          | ... | [columnN: Atom]                          |
| --- | --- | --- | --- |
| //или//             | //или//                                | ... | //[или]//                                |
| Optional of Struct T| Tuple of (column1: Atom, alias1: Atom) | ... | [Tuple of (columnN: Atom, aliasN: Atom)] |

**Где**:

* N: от 1 и выше
* columnJ: тип столбца любой из: Optional of **TfJ**, List of **TfJ**, Dict of <TkJ, TpJ> (//в случае Dict, **TfJ** = Tuple of (TkJ, TpJ)//)

**Возвращаемый тип**: List of Struct T' //или// List of Optional Of Struct T' (соответствует входному типу).

Где: `T'` Изначальный `Struct T`, разложенный по столбцу(-цам) `column1 ... columnN`, что изменится:

* если для столбца `columnJ` был определен `aliasJ`, то к структуре добавляется поле с именем `aliasJ` и типом `TfJ` (см. описание типа выше), по исходному имени поле также доступно;
* если указан только столбец `columnJ`, то у структуры поле `columnJ` преобразуется в тип `TfJ`.
**{% cut "**Примеры**:" %}

Добавляется новое поле `subkey`, элементом которого будет каждый элемент из `subkey_list`:
```
(let core (FlatMap core (lambda '(row) (block '(
    (let res (FlattenByColumns row '('subkey_list 'subkey)))
    (return res)
)))))
```
Добавляется новое поле `subkey`, элементом которого будет каждый элемент из `subkey_list`, поле `values` (в зависимости от типа) становится «плоским» или «теряет Optional»:
```
(let core (FlatMap core (lambda '(row) (block '(
    (let res (FlattenByColumns row '('subkey_list 'subkey) 'values))
    (return res)
)))))
```

{% endcut %}

## Операции с Variant
### Guess

**Аргументы**:

| var | index |
| --- | --- |
| Variant of Tuple(T1,T2...) or Optional of Variant of Tuple(T1,T2...) | Atom |

**Возвращаемый тип**: Optional of T[index]

Если `var` — пустой `Optional`, то возвращает пустой `Optional`.
Возвращает завернутый в `Just` элемент варианта, если индекс альтернативы совпадает с тем, который сейчас находится в варианте.
В противном случае возвращает пустой `Optional`.

**Аргументы**:

| var | name |
| --- | --- |
| Variant of Struct(name1:T1,name2:T2...) or Optional of Variant of Struct(name1:T1,name2:T2...) | Atom |

**Возвращаемый тип**: Optional of T[name]

Если `var` — пустой `Optional`, то возвращает пустой `Optional`.
Возвращает завернутый в `Just` элемент варианта, если имя альтернативы совпадает с тем, которое сейчас находится в варианте.
В противном случае возвращает пустой `Optional`.

### Visit

**Аргументы**:

| var | index1 | lambda1 | ... | [defaultValue] |
| --- | --- | --- | --- | --- |
| Variant of Tuple(T1,T2...) | Atom | Lambda (T[index])->U | ... | U |

**Возвращаемый тип**: U

Для заданных индексов в `Tuple` вызывает переданные обработчики, в противном случае возвращает `defaultValue`, если оно определено.
Каждая альтернатива должна быть обработана не более одного раза.
Если не задано `defaultValue`, то должны быть обработаны все варианты.
Типы всех обработчиков и `defaultValue` должны совпадать.

**Аргументы**:

| var | name1 | lambda1 | ... | [defaultValue] |
| --- | --- | --- | --- | --- |
| Variant of Struct(name1:T1,name2:T2...) | Atom | Lambda (T[name])->U | ... | U |

**Возвращаемый тип**: U

Для заданных имен полей в `struct` вызывает переданные обработчики, в противном случае возвращает `defaultValue`, если оно определено.
Каждая альтернатива должна быть обработана не более одного раза.
Если не задано `defaultValue`, то должны быть обработаны все варианты.
Типы всех обработчиков и `defaultValue` должны совпадать.

### Way

**Аргументы**:

| var |
| --- |
| Variant of Tuple(T1,T2...) or Optional of Variant of Tuple(T1,T2...) |

**Возвращаемый тип**: Uint32 or Optional of Uint32

Возвращает индекс альтернативы. Для пустого Optional возвращает пустой выходной Optional.

**Аргументы**:

| var |
| --- |
| Variant of Struct(name1:T1,name2:T2...) or Optional of Variant of Struct(name1:T1,name2:T2...) |

**Возвращаемый тип**: Utf8 or Optional of Utf8

Возвращает имя альтернативы. Для пустого Optional возвращает пустой выходной Optional.

### VariantItem

**Аргументы**:

| var |
| --- |
| Variant of Tuple(T,T...) or Optional of Variant of Tuple(T,T...) |

**Возвращаемый тип**: T or Optional of T

Возвращает любой заполненный элемент альтернативы. Все типы альтернативы должны быть эквиваленты. Для пустого Optional возвращает пустой выходной Optional.

**Аргументы**:

| var |
| --- |
| Variant of Struct(name1:T,name2:T...) or Optional of Variant of Struct(name1:T,name2:T...) |

**Возвращаемый тип**: T or Optional of T

Возвращает любой заполненный элемент альтернативы. Все типы альтернативы должны быть эквиваленты. Для пустого Optional возвращает пустой выходной Optional.

## Операции с Data
### <, <=, ==, !=, >=, > (Less, LessOrEqual, Equals, NotEquals, Greater, GreaterOrEqual)
**Аргументы**:

| left | right |
| --- | --- |
| Data(T) | Data(T) |

**Возвращаемый тип**: Data(Bool)

Сравнение данных одного типа.

### , -, * (Add, Sub, Mul)
**Аргументы**:

| left | right |
| --- | --- |
| Data(T) | Data(T) |

**Возвращаемый тип**: Data(T)

Арифметика для числовых типов.

Также поддерживаются следующие операции:
* Interval + Interval -> Interval?
* Interval - Interval -> Interval?
* Date/DateTime/Timestamp + Interval -> Date/DateTime/Timestamp?
* Interval + Date/DateTime/Timestamp -> Date/DateTime/Timestamp?
* Date/DateTime/Timestamp - Interval -> Date/DateTime/Timestamp?
* Date/DateTime/Timestamp - Date/DateTime/Timestamp = Interval

### /, % (Div, Mod)
**Аргументы**:

| left | right |
| --- | --- |
| Data(T) | Data(T) |

**Возвращаемый тип**: Optional of Data(T) или Data(T) для чисел с плавающей точкой

Деление и взятие остатка для числовых типов, возвращается пустой `Optional` при делении на ноль или целочисленном переполнении.
Для чисел с плавающей точкой доступна только операция `/` (Div). При делении на ноль получится или `NaN` или `±Inf`.

Также поддерживаются следующие операции:
* Interval * Integral -> Interval?
* Integral * Interval -> Interval?
* Interval / Integral -> Interval?

### Inc,Dec
**Аргументы**:

| val |
| --- |
| Data(T) |

**Возвращаемый тип**: Data(T)

Инкремент и декремент.

### BitNot
**Аргументы**:

| val |
| --- |
| Data(T) |

**Возвращаемый тип**: Data(T)

Битовое отрицание для беззнаковых целых чисел.

### BitAnd,BitOr,BitXor
**Аргументы**:

| left | right |
| --- | --- |
| Data(T) | Data(T) |

**Возвращаемый тип**: Data(T)

Битовое логическое И, ИЛИ, ИСКЛЮЧАЮЩИЕ ИЛИ для беззнаковых целых чисел.

### CountBits
**Аргументы**:

| val |
| --- |
| Data(T) |

**Возвращаемый тип**: Data(T)

Подсчет количества битов для беззнаковых целых чисел.

### ShiftLeft,RotLeft,ShiftRight,RotRight
**Аргументы**: arg:Data(T) bits:Data(Byte)

| arg | bits |
| --- | --- |
| Data(T) | Data(Byte) |

**Возвращаемый тип**: Data(T)

Сдвиги для беззнаковых целых чисел.


* `ShiftRight/ShiftLeft` — выполняет сдвиг с выталкиванием бит.
* `RotRight/RotLeft` — выполняет циклический сдвиг: выдвинутые биты появляются с противоположной стороны.

Если величина `bits` превышает разрядность числа, то `ShiftRight/ShiftLeft` возвращает `0`, а `RotRight/RotLeft` использует в качестве величины сдвига остаток от деления `bits` на разрядность числа. Иными словами, `RotRight/RotLeft` при сдвиге на число бит, равное разрядности числа, не изменяет значения числа.

### Plus,Minus
**Аргументы**:

| val |
| --- |
| Data(T) |

**Возвращаемый тип**: Data(T)

`Plus` не изменяет аргумент, `Minus` меняет знак аргумента.

### Ascending, Descending
**Аргументы**:

| val |
| --- |
| sortable T |

**Возвращаемый тип**: String

Возвращает строку, которая упорядочена так же, как значения исходного типа. Для `Ascending` - по возрастанию, для `Descending` - по убыванию.

### Min,Max
**Аргументы**:

| left | right |
| --- | --- |
| Data(T) | Data(T) |

**Возвращаемый тип**: Data(T)

Получение минимума или максимума.

### And, Or, Xor
**Аргументы**:

| left | right |
| --- | --- |
| Data(bool) | Data(bool) |

**Возвращаемый тип**: Data(Bool)

Логические операции над двумя аргументами.

### Not
**Аргументы**:

| arg |
| --- |
| Data(Bool) |

**Возвращаемый тип**: Data(Bool)

Логическое отрицание.

### Likely
**Аргументы**:

| arg |
| --- |
| Data(Bool) или Optional of Data(Bool) |

**Возвращаемый тип**: Data(Bool) или Optional of Data(Bool)

Возвращает переданное значение. Используется как подсказка для процедур оптимизации, что чаще всего значение является `true`.
Использование `Likely` может положительно повлиять на производительность запроса, если предположение о преобладании значений true верно, и **отрицательно** — если оно неверно.

### ByteAt

**Аргументы**:

| str | index |
| --- | --- |
| Data(Utf8 or Optional Utf8 or String or Optional String) | Data(Uint32) |

**Возвращаемый тип**: Optional of Byte

Возвращает символ из строки по индексу `index` в байтовом представлении. Нумерация индексов от нуля.

### Concat

**Аргументы**:

| left | right |
| --- | --- |
| Data(String or Utf8) | Data(String or Utf8) |

**Возвращаемый тип**: Data(String or Utf8)

Конкатенация строк. Если обе строки — `Utf8`, то и возвращаемый тип — тоже.

### Substring

**Аргументы**:

| str | start | count |
| --- | --- | --- |
| Data(String) | Data(Uint32) | Data(Uint32) |

**Возвращаемый тип**: Data(String)

Получение подстроки.

### FromString

**Аргументы**:

| arg | dataType |
| --- | --- |
| Data(String) | Atom |

**Возвращаемый тип**: Optional of Data(dataType)

Парсит строку как тип данных, заданный именем в `dataType`, возвращает пустой `Optional` при ошибке парсинга или заполненный `Optional` при успехе.

### ToString

**Аргументы**:

| arg |
| --- |
| Data(U) |

**Возвращаемый тип**: Data(String)

Конвертирует число в строку.

### Convert

**Аргументы**:

| arg | anotherDataType |
| --- | --- |
| Data(someDataType) | Type |

**Возвращаемый тип**: Data(anotherDataType)

Преобразует один числовой тип в другой, возможно, усекая результат при преобразовании в более узкий тип.
Нельзя использовать для преобразования чисел с плавающей точкой в интегральные типы (см. `ToIntegral`).

### ToIntegral

**Аргументы**:

| arg | anotherDataType |
| --- | --- |
| Data(someDataType) | Type |

**Возвращаемый тип**: Optional(Data(anotherDataType))

Преобразует один числовой тип в другой, возможно, усекая результат при преобразовании в более узкий тип,
но проверяя, что значение попадает в диапазон целевого типа.
Предназначен для преобразования чисел в интегральные типы.
Если значение выходит за диапазон целевого интегрального типа, или значение с плавающей точкой содержит `NaN` или `±Inf`, то возвращается пустой `Optional`.
Если входом является пустой `Optional`, то и выход пустой `Optional`.

### BitCast

**Аргументы**:

| arg | anotherDataType |
| --- | --- |
| Optional(Data(someDataType)) или Data(someDataType) | Type |

**Возвращаемый тип**: Optional(Data(anotherDataType)) или Data(anotherDataType)

Преобразует один интегральный тип в другой интегральный, используя `Convert`.
Если входом является пустой `Optional`, то и выход пустой `Optional`.

### SafeCast

**Аргументы**:

| arg | anotherType |
| --- | --- |
| Value of some persistable type | Type |

**Возвращаемый тип**: anotherType или Optional(anotherType)

Преобразует один тип в другой, используя `Convert`, `ToString`, `FromString` или `ToIntegral` в зависимости от исходного и целевого типов.
Если входом является пустой `Optional`, то и выход пустой `Optional`.
Также выход пуст тогда, когда произошла ошибка преобразования (в `FromString` или `ToIntegral`).

### Cast

**Аргументы**:

| arg | anotherDataType |
| --- | --- |
| Optional(Data(someDataType)) или Data(someDataType) | Atom |

**Возвращаемый тип**: Optional(Data(anotherDataType)) или Data(anotherDataType)

*Устаревшая*: Будет удалена - используйте `BitCast` или `SafeCast`.

### AlterTo

**Аргументы**:

| srcValue | targetType | successHandler | failValue |
| --- | --- | --- | --- |
| T | U | Lambda(item: U)-> V | V |

**Возвращаемый тип**: V

Конвертирует значение типа `T` в значение типа `U`.
Если конвертация прошла успешно, то вызывается `successHandler` которому передается сконвертированное значение.
В противном случае возвращается `failValue`.
У типов `T` и `U` должен быть общий тип.

### TryRemoveAllOptionals
**Аргументы**:

| tuple |
| --- |
| Tuple of (T1,T2?,T3...) |

**Возвращаемый тип**: Tuple of (T1, T2, T3)?

**Аргументы**:

| struct |
| --- |
| Struct of (name1:T1,name2:T2?,name3:T3...) |

**Возвращаемый тип**: Struct of (name1:T1, name2:T2, name3:T3...)?

Распаковывает все `Optional` элементы внутри `struct` или `tuple`.
Типом результата будет `Optional` `struct` или `tuple`, в котором все исходные элементы стали не-`Optional`.
Если хотя бы один исходный `Optional` был пуст, то результатом будет пустой `Optional`.

### Size

**Аргументы**:

| arg |
| --- |
| Data(U) |

**Возвращаемый тип**: Data(Uint32)

Количество байт в `Data`.

## Операции с Optional
### Exists
**Аргументы**:

| opt |
| --- |
| Optional of T |

**Возвращаемый тип**: Data(Bool)

Возвращает `true`, если `Optional` заполнен.

**Аргументы**:

| opt |
| --- |
| U, где U - не Optional of T |

**Возвращаемый тип**: Data(Bool)

Возвращает `true`.

### Coalesce
**Аргументы**:

| opt | default |
| --- | --- |
| Optional of T | T |

**Возвращаемый тип**: T

Возвращает `default`, если `Optional` не заполнен, иначе `item`, если `Optional` равен `Just item`.

**Аргументы**:

| opt | default |
| --- | --- |
| Optional of T | Optional of T |

**Возвращаемый тип**: optional of T

Возвращает `default`, если `Optional` не заполнен, иначе `opt`.

**Аргументы**:

| opt | default |
| --- | --- |
| U, где U - не Optional of T | U |

**Возвращаемый тип**: U

Возвращает `opt`.

### Unwrap
**Аргументы**:

| opt | [message] |
| --- | --- |
| T | String |

**Возвращаемый тип**: U если T это Optional of U, иначе T

Если `Optional` не пуст, возвращает его содержимое. Если же он пуст, вызывает ошибку времени выполнения.
Если указан аргумент message, то он добавляется в сообщение об ошибке, если не пуст.
Если входное значение не является `Optional`, то оно возвращается без изменений.

### OptionalIf
**Аргументы**:

| predicate | item |
| --- | --- |
| Data(Bool) | T |

**Возвращаемый тип**: Optional of T

Возвращает заполненный `Optional`, если предикат вернул `true`, иначе - пустой.

### OptionalReduce
**Аргументы**:

| x | y | handler |
| --- | --- | --- |
| T | T | lambda (x:T, y:T)->T, где T не является Optional of U |

**Возвращаемый тип**: T

Применяет бинарную операцию к аргументам.

**Аргументы**:

| x | y | handler |
| --- | --- | --- |
| Optional of T | Optional of T | lambda (x:T, y:T)->T |

**Возвращаемый тип**: Optional of T

Применяет бинарную операцию к распакованным аргументам, если оба аргумента не пусты. Если оба входных аргумента пусты, возвращается пустой `Optional`.
Если не пуст только один аргумент, то он и будет возвращен.

### FromYsonSimpleType

**Аргументы**:

| yson         | dataType |
| --- | --- |
| Data(String) | Atom     |

**Возвращаемый тип**: Optional of Data(dataType)

Извлекает из `yson` сырого YSON в виде строки, в `dataType`, возвращает пустой `Optional` при ошибке парсинга или заполненный `Optional` при успехе.

## Операции с Dict
### Length
**Аргументы**:

| dict |
| --- |
| Dict of (K,V) |

**Возвращаемый тип**: Data(Uint64)

Возвращает количество различных ключей в словаре.

### HasItems
**Аргументы**:

| dict |
| --- |
| Dict of (K,V) |

**Возвращаемый тип**: Data(Bool)

Возвращает `true`, если словарь не пуст.

### Contains
**Аргументы**:

| dict | key |
| --- | --- |
| Dict of (K,V) | K |

**Возвращаемый тип**: Data(Bool)

Возвращает признак того, что ключ найден в словаре.

**Аргументы**:

| dict | key |
| --- | --- |
| Optional of Dict of (K,V) | K |

**Возвращаемый тип**: Data(Bool)

Возвращает признак того, что ключ найден в словаре.
Если исходный `Optional` пуст, то возвращается `false`.

### Lookup
**Аргументы**:

| dict | key |
| --- | --- |
| Dict of (K,V) | K |

**Возвращаемый тип**: Optional of V

Если ключ найден в словаре, то возвращается `Just value`. Иначе возвращается пустой `Optional`.

**Аргументы**:

| dict | key |
| --- | --- |
| Optional of Dict of (K,V) | K |

**Возвращаемый тип**: Optional of V

Если ключ найден в словаре, то возвращается `Just value`. Иначе возвращается пустой `Optional`.
Если исходный `Optional` пуст, то возвращается пустой `Optional`.

### DictItems
**Аргументы**:

| dict          |
| --- |
| Dict of (K,V) |

**Возвращаемый тип**: List of Tuple(K,V)

Строит список из пар ключ/значение словаря. Порядок определен только для сортированных списков.

**Аргументы**:

| dict                      |
| --- |
| Optional of Dict of (K,V) |

**Возвращаемый тип**: Optional of List of Tuple(K,V)

Строит список из пар ключ/значение словаря. Порядок определен только для сортированных списков.
Если исходный `Optional` пуст, то возвращается пустой `Optional`.

### DictKeys
**Аргументы**:

| dict          |
| --- |
| Dict of (K,V) |

**Возвращаемый тип**: List of K

Строит список из ключей словаря. Порядок определен только для сортированных списков.

**Аргументы**:

| dict                      |
| --- |
| Optional of Dict of (K,V) |

**Возвращаемый тип**: Optional of List of K

Строит список из ключей словаря. Порядок определен только для сортированных списков.
Если исходный `Optional` пуст, то возвращается пустой `Optional`.

### DictPayloads
**Аргументы**:

| dict          |
| --- |
| Dict of (K,V) |

**Возвращаемый тип**: List of V

Строит список из значений словаря, лежащих по ключам. Порядок определен только для сортированных списков.

**Аргументы**:

| dict                      |
| --- |
| Optional of Dict of (K,V) |

**Возвращаемый тип**: Optional of List of V

Строит список из значений словаря, лежащих по ключам. Порядок определен только для сортированных списков.
Если исходный `Optional` пуст, то возвращается пустой `Optional`.

### AsDict
**Аргументы**:

| item1                                        | ... |
| --- | --- |
| Tuple of (key1:KeyType payload1:PayloadType) | ... |

**Возвращаемый тип**: Dict of (KeyType,PayloadType)

Создает словарь из непустого списка пар ключ—значение. Типы всех ключей и типы всех значений должны совпадать.

### ToIndexDict
**Аргументы**:

| list      |
| --- |
| List of T |

**Возвращаемый тип**: Dict of (Data(Uint64),T)

Создает словарь с ключами — порядковыми индексами элемента в списке, начиная с нуля. Позволяет получать доступ к элементам списка по индексу.

**Аргументы**:

| list                  |
| --- |
| Optional of List of T |

**Возвращаемый тип**: Optional of Dict of (Data(Uint64),T)

Создает словарь с ключами — порядковыми индексами элемента в списке, начиная с нуля. Позволяет получать доступ к элементам списка по индексу.
Если исходный `Optional` пуст, то возвращается пустой `Optional`.

### ToDict
**Аргументы**:

| list             | keySelector   | payloadSelector | options       |
| --- | --- | --- | --- |
| List/Stream of T | lambda (T)->K | lambda (T)->V   | Tuple of Atom |

**Возвращаемый тип**: Dict of (K,V) или Dict of (K,List of V)

Создает словарь из списка или стрима.
Допустимые значения опций:

* Тип словаря: `Hashed`, `Sorted` или `Auto`.
* Тип обработки повторения ключей:
    * `One` — если ключи повторяются, для ключа будет использовано первое значение в списке.
    * `Many` — если ключи повторяются, значением ключа станет список всех значений с данным ключом.

Обязательно должен быть указан и тип словаря, и тип обработки повторения ключей.
В режиме `Auto` если ключ является хешируемым, то строится `Hashed` реализация словаря, иначе - `Sorted`.

### DictFromKeys
**Аргументы**:

| dictKeyType                                 | keys              |
| --- | --- |
| Type of (DataType или Optional of DataType) | Tuple of (keys:*) |

**Возвращаемый тип**: Dict of (DataType,Void)

Создает словарь из ключей типа `DataType` без значений, для быстрого поиска элементов.
Если ключ не может быть преобразован к типу `DataType`, то значение будет проигнорировано.

## Ветвление
### If
**Аргументы**:

| predicate  | thenValue | elseValue |
| --- | --- | --- |
| Data(Bool) | T         | T         |

**Возвращаемый тип**: T

Если предикат равен `true`, возвращает `thenValue`, иначе возвращает `elseValue`.

### MatchType
**Аргументы**:

| expression | typeKindName | matchExpr         | nonMatchExpr      |
| --- | --- | --- | --- |
| T          | Atom         | Lambda(item:T)->U | Lambda(item:T)->V |

**Возвращаемый тип**: U или V

Подстановка тела из `matchExpr` или `nonMatchExpr` во время компиляции.
Если тип `expression` соответствует переданному имени (`typeKindName`) вызывается `matchExpr` с `expression` в качестве аргумента, в противном случае — вызывается `nonMatchExpr`.

### IfType
**Аргументы**:

| expression | type | matchExpr         | nonMatchExpr      |
| --- | --- | --- | --- |
| T          | Type | Lambda(item:T)->U | Lambda(item:T)->V |

**Возвращаемый тип**: U или V

Подстановка тела из `matchExpr` или `nonMatchExpr` во время компиляции. Вместо аргумента `matchExpr` подставляется `expression`, если `expression` имеет тип `type`.

### TryMember
**Аргументы**:

| struct | name | defaultValue |
| --- | --- | --- |
| Struct/Optional of Struct | Atom | * |

**Возвращаемый тип**: typeof(defaultValue)

Извлекает из структуры значение по имени, если такое поле есть в структуре, иначе возвращает `defaultValue`.
Если в структуре есть поле, то его тип должен совпадать с типом `defaultValue`.

### WeakField
**Аргументы**:

| struct | targetType | memberTuple: (Column) or (Column Source) | [default]        |
| --- | --- | --- | --- |
| Struct | Atom       | Tuple of (Atom) or Tuple of (Atom Atom)  | Data(targetType) |

**Возвращаемый тип**: Optional of DataType(targetType)

Извлекает из структуры и конвертирует в тип `targetType` значение по имени `Column` (учитывает ещё имя таблицы `Source`, если оно задано), если такое поле есть в структуре, иначе пытается найти его в словаре, который лежит в поле структуры `_rest`, а если там нет то в словаре, который лежит в поле `_other` и, если не находит, то возвращает `default` или пустой Optional.

### TryWeakMemberFromDict
**Аргументы**:

| otherDict                | restDict               | targetType | member |
| --- | --- | --- | --- |
| Dict of (String, String) | Dict of (String, Yson) | Atom       | Atom   |

**Возвращаемый тип**: Optional of DataType(targetType)

Пытается найти поле `member` в словаре `restDict`, а если там нет то в `otherDict` и преобразует его в тип `targetType`. Если не находит ключа, то возвращает пустой `Optional`.

### IfPresent
**Аргументы**:

| opt           | presentHandler | missingValue |
| --- | --- | --- |
| Optional of T | lambda (T)->U  | U            |

**Возвращаемый тип**: U

Выполняет `presentHandler` на распакованном `Optional`, если он заполнен, или возвращает `missingValue`, если он не заполнен.

### DependsOn
**Аргументы**:

| value |
| --- |
| T     |

**Возвращаемый тип**: T

Указывает на функциональную зависимость. Реально вычисления аргумента во время выполнения не происходит, но функция, принимающая DependsOn в качестве аргумента будет рассчитана повторно, если изменится какой-либо входной аргумент. Обычно в качестве value задается или константа (для построения нескольких инстансов вычислений), либо аргумент lambda.

### Seq
**Аргументы**:

| [arg1 | arg2 | ...] | argN |
| --- | --- | --- | --- |
| T1 | T2 | | Tn |

**Возвращаемый тип**: Tn

Гарантирует вычисление аргументов в указанном порядке. Возвращает значение последнего аргумента. Функция полезна при работе с мутабельными ресурсами.

## Работа с файлами
### FilePath
**Аргументы**:

| name |
| --- |
| Atom |

**Возвращаемый тип**: Data(String)

Возвращает путь к файлу с заданным именем в локальной файловой системе. Используется относительный путь, представляющий собой хэш, например: `./1234abc.file`.

### FileContent
**Аргументы**:

| name |
| --- |
| Atom |

**Возвращаемый тип**: Data(String)

Возвращает в виде строки содержимое указанного файла на локальной файловой системе. Размер файла не должен превышать 4 Гб.

## Работа с генератором случайных чисел и временем
### NewMTRand
**Аргументы**:

| seed         |
| --- |
| Data(Uint64) |

**Возвращаемый тип**: Resource

Создает экземпляр генератора случайных чисел.
MT в имени функции означает [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister).

### NextMTRand
**Аргументы**:

| gen |
| --- |
| Resource |

**Возвращаемый тип**: tuple of (Data(Uint64), Resource)

Генерирует случайное число из всего диапазона `Uint64`, используя состояние указанного генератора в момент вызова. Состояние генератора после этой операции изменяется.
Возвращает пару — число и состояние генератора.
После вызова `NextMTRand` уже существующие ссылки на ресурс будут указывать на новое состояние генератора.
MT в имени функции означает [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister).

### Random
**Аргументы**: any DependsOn nodes

**Возвращаемый тип**: Double

Возвращает случайное значение в интервале `[0..1)`. Значение изменяется, если меняется какой-либо зависимый узел в графе.
Если нет зависимых узлов, то возвращаемое значение будет константой — при повторных обращениях будет одно и то же значение.

Подробнее о логике генерации случайных чисел см. [описание функций Random/RandomNumber/RandomUuid](/docs/yt/builtins/basic#random) в руководстве пользователя.

### RandomNumber
**Аргументы**: any DependsOn nodes

**Возвращаемый тип**: Uint64

Возвращает случайное значение в интервале `[0..pow(2,64)-1]`. Значение изменяется, если меняется какой-либо зависимый узел в графе.
Если нет зависимых узлов, то возвращаемое значение будет константой — при повторных обращениях будет одно и то же значение.

Подробнее о логике генерации случайных чисел см. [описание функций Random/RandomNumber/RandomUuid](/docs/yt/builtins/basic#random) в руководстве пользователя.

### RandomUuid
**Аргументы**: any DependsOn nodes

**Возвращаемый тип**: Uuid

Возвращает Uuid version 4. Значение изменяется, если меняется какой-либо зависимый узел в графе.
Если нет зависимых узлов, то возвращаемое значение будет константой — при повторных обращениях будет одно и то же значение.

Подробнее о логике генерации случайных чисел см. [описание функций Random/RandomNumber/RandomUuid](/docs/yt/builtins/basic#random) в руководстве пользователя.

### Now,CurrentUtcDate,CurrentUtcDatetime,CurrentUtcTimestamp
**Аргументы**: any DependsOn nodes

**Возвращаемый тип**: Uint64/Date/Datetime/Timestamp

Возвращает количество микросекунд с 1970 года в Uint64 (Now), либо сразу значение одного из типов даты.
Если нет зависимых узлов, то возвращаемое значение будет константой — при повторных обращениях будет одно и то же значение.

### TimezoneId
**Аргументы**:

| name |
| --- |
| String |

**Возвращаемый тип**: Optional of Data(Uint16)

Преобразовать [IANA имя временной зоны](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) в Id. При неверном имени временной зоны возвращается пустой optional.

### TimezoneName
**Аргументы**:

| id |
| --- |
| Uint16 |

**Возвращаемый тип**: Optional of String(Uint16)

Преобразовать Id временной зоны в [IANA имя временной зоны](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones). При неверном Id возвращается пустой optional.

### AddTimezone
**Аргументы**:

| utc | timezoneId |
| --- | --- |
| Date/Datetime/Timestamp[?] | Uint16[?] |

**Возвращаемый тип**: Optional of Data(TzDate/TzDatetime/TzTimestamp)

Добавляет метку временной зоны к UTC времени.
Id временной зоны должен быть получен через функцию TimezoneId.
При некорректном Id возвращается пустой optional.

### RemoveTimezone
**Аргументы**:

| local |
| --- |
| TzDate/TzDatetime/TzTimestamp[?] |

**Возвращаемый тип**: Data(Date/Datetime/Timestamp) [?]

Удаляет метку временной зоны, сохраняя только UTC время.

## Работа с очередью
### QueueCreate
**Аргументы**:

| elemType | capacity | initSize | [dependOnArgs ...] |
| --- | --- | --- | --- |
| Type of T | Uint64 callable / Void | Uint64 callable | * |

**Возвращаемый тип**: Resource<Queue, Type of T>

Создаёт безопасную FIFO очередь, для хранения элементов с типом Type of T, где:

* capacity - емкость очереди (Void задает неограниченную очередь)
* initSize - начальное количество (пустых) элементов в очереди, должно быть не больше `capacity`
* dependOnArgs ... - опциональные аргументы добавляющие зависимость очереди от них

### QueuePush
**Аргументы**:

| resource| elem |
| --- | --- |
| Resource<Queue, Type of T> | U |

**Возвращаемый тип**: Resource<Queue, Type of T>

Добавляет элемент `elem` в очередь. Тип U должен приводиться к T.

### QueuePop
**Аргументы**:

| resource |
| --- |
| Resource<Queue, Type of T> |

**Возвращаемый тип**: Resource<Queue, Type of T>

Исключает из очереди самый старый элемент.

### QueuePeek
**Аргументы**:

| resource | index | dependOnArgs ... |
| --- | --- | --- |
| Resource<Queue, Type of T> | Uint64 | * |

**Возвращаемый тип**: Optional of T

Смотрит в очереди по индексу `index` элемент и возвращает его. Нумерация `index` начинается с нуля, где 0 -- самый старый элемент в очереди. При выходе за границу очереди возвращается пустой `Optional`. Пустой `Optional` возвращается также для пустых элементов, которые создаются с помощью параметра `initSize` в `QueueCreate`. `dependOnArgs ...` - опциональные аргументы, добавляющие зависимость возвращаемого значения от них.

### PreserveStream
**Аргументы**:

| stream | queue | outpace |
| --- | --- | --- |
| Stream of T | Resource<Queue, Type of T> | Uint64 callable |

**Возвращаемый тип**: Stream of T

Прогоняет поток `stream` через очередь `queue` поддерживая в очереди вплоть до `outpace` последующих элементов.

## Работа с Stream
### EmptyIterator
**Аргументы**:

| type |
| --- |
| Type of T |

**Возвращаемый тип**: Stream of T

Строит пустой стрим.

### ToStream
**Аргументы**:

| opt | [dependent nodes] |
| --- | --- |
| Optional of T | * |

**Возвращаемый тип**: Stream of T

Строит стрим из optional. Для получения разных инстансов стримов из одного optional должны быть заданы разные dependent nodes.

**Аргументы**:

| opt | [dependent nodes] |
| --- | --- |
| List of T | * |

**Возвращаемый тип**: Stream of T

Строит стрим из списка - алиас для функции Iterator

**Аргументы**:

| opt | [dependent nodes] |
| --- | --- |
| Stream of T | * |

**Возвращаемый тип**: Stream of T

Возвращает первый аргумент

### Iterator
**Аргументы**:

| list | [dependent nodes] |
| --- | --- |
| List of T | * |

**Возвращаемый тип**: Stream of T

Строит стрим из списка. Для получения разных инстансов стримов из одного списка должны быть заданы разные dependent nodes.

### Iterable
**Аргументы**:

| lambda |
| --- |
| ()->Stream of T |

**Возвращаемый тип**: List of T

Строит список из стрима.

### ForwardList
**Аргументы**:

| stream |
| --- |
| Stream of T |

**Возвращаемый тип**: List of T

Строит однопроходной список из стрима. При попытке использовать нижележащий стрим в таком списке повторно, будет выдана ошибка во время выполнения.

### Collect
**Аргументы**:

| list |
| --- |
| List/Stream of T |

**Возвращаемый тип**: List of T

Буферизует (ленивый) список или стрим в жадный список.

### LMap
**Аргументы**:

| list | handler |
| --- | --- |
| List of T | Lambda (item:Stream of T)->List/Stream/Optional of U |

**Возвращаемый тип**: List of U

Преобразует список вызывая handler для каким-либо образом сгруппированных подпоследовательностях исходного списка и конкатенируя результат.
Порядок элементов в результате и в подпоследовательностях на входе handler не определен, но эти последовательности не пересекаются и покрывают полный исходный список.

### PartitionByKey
**Аргументы**:

| list | keySelector | sortDirection | sortKeySelector | handler |
| --- | --- | --- | --- | --- |
| List/Stream of T | (item:T)->K | Bool/Tuple of Bool or Void | (item:T)->S or Void | (list: Stream of Tuple<K, Stream of T>)->List/Stream/Optional of V |

**Возвращаемый тип**: List/Stream of V

Тип `K` должен быть Hashable и Equatable.
Если используется сортировка после партицирования по ключу, то должны быть заданы одновременно sortKeySelector и sortDirection, в противном случае они оба должны быть литеральным Void.
Тип `S` должен быть Comparable.
Если `S` является таплом, то `sortDirection` должен быть таплом той же длины.
Партицирует список по ключу, дополнительно выполняя сортировку в каждой партиции. handler видит по меньшей мере стрим с одним ключам и стримом по этому ключу, но реализация может использовать и большее количество ключей в стриме верхнего уровня.

* Ключ генерируется путем применения `keySelector` к каждому элементу списка.
* Для каждого ключа строит список элементов, содержащих это значение ключа.
* Построенная пара ключ—список сортируется по ключу в `sortKeySelector` и направлению `sortDirection` - если они заданы
* Все (отсортированные) пары ключ-список передаются в `handler`, причем в виде стрима по каждому ключу.
* Списки, полученные по всем вызовам `handler`, объединяются в один список, как в `FlatMap`.

Порядок элементов в списках, поступающих в `handler`, а также порядок объединения общего списка не определен.
Тип списка выхода совпадает стипом списка входа.

### PartitionsByKeys
**Аргументы**:

| list | keySelector | sortDirection | sortKeySelector | handler |
| --- | --- | --- | --- | --- |
| List/Stream of T | (item:T)->K | Bool/Tuple of Bool or Void | (item:T)->S or Void | (list: List/Stream of T)->List/Stream of V |

**Возвращаемый тип**: List/Stream of V

Переупорядочивает входной список/стрим и передает его в handler.
Элементы одной партиции (т.е. те, для которых keySelector возврящает одинаковый результат) идут в этом стриме последовательно.
Внутри партиции элементы упорядочены согласно `sortKeySelector` / `sortDirection`. Порядок разных партиций друг относительно друга не определен.
Первые 4 аргумента имеют тот же смысл, что и в `PartitionByKey`.
Результатом `PartitionsByKeys` явяелся результат `handler`.

### Chopper
**Аргументы**:

| list | keySelector | groupSwitch | handler |
| --- | --- | --- | --- |
| Stream of T | (item:T)->K | (key:K, item:T)->Bool | (key:K, list: Stream of T)->Stream of V |

**Возвращаемый тип**: Stream of V

Нарезает исходный стрим на несколько стримов, передает эти стримы в `handler` и склеивает полученные результаты в один стрим.
Новый стрим начинается с элемента на котором `groupSwitch` возвращает True.

### Switch
**Аргументы**:

| list | bufferBytes | labels1 | handler1 | ... |
| --- | --- | --- | --- | --- |
| Stream of T/Stream of Variant<Tuple<T1,T2...>> | Atom | Tuple of Atom | Lambda (item:Stream of T/Variant<Tuple<V1,V2...>>)->Stream of U1/Variant<Tuple<W1,W2...>> | |

**Возвращаемый тип**: Stream of U/Variant<W1,W2...>

Преобразует входной стрим в стримы для каждого обработчика и собирает результат в единый стрим.
Во время работы операция буферизует часть входного стрима в буфере примерного размера bufferBytes и вызывает на этом буфер каждый handler-ы, заканчивая сигналом приостановки стрима. Так продолжается пока не опустеет входной стрим, тогда handler-ы получат сигнал о конце стрима.
Если тип элемента входного стрима - Variant, то он должен иметь Tuple как underlying type и в этом случае handler-ы могут быть подписаны индексами в этом tuple, в противном случае все индексы должны иметь значение 0.
Для каждого handler можно указать более одного индекса в labels, и они не могут повторяться в пределах одного handler-а (но могут в разных handler-ах). В этом случае входом в handler будет стрим Variant-ов с отмеченными индексами.
Если выходом handler является стрим Variant (который должен быть на базе тапла), или если есть несколько handler-ов, то выходом самой операции Switch является стрим Variant на базе тапла, где все индексы являются сквозными по всем handler-ам.
Порядок объединения частичных стримов от handler-ов не определен.

### Condense
**Аргументы**:

| stream | initState | switchHandler | updateHandler |
| --- | --- | --- | --- |
| Stream of T | U | Lambda (item:T, state:U)->Bool | Lambda (item:T, state:U)->U |

**Возвращаемый тип**: Stream of U

Преобразует стрим, вызывая `switchHandler` для каждого элемента и текущего значения `state`.
Если `switchHandler` вернул true, то немедленно отдаёт в поток текущий `state` и заново инициализирует его из `initState`, а иначе обновляет его, получая новое значение через `updateHandler` от последнего `state` и обрабатываемого элемента.
По завершении стрима возвращает последнее значение `state`.

### Condense1
**Аргументы**:

| stream | initHandler | switchHandler | updateHandler |
| --- | --- | --- | --- |
| Stream of T | Lambda (item:T)->U | Lambda (item:T, state:U)->Bool | Lambda (item:T, state:U)->U |

**Возвращаемый тип**: Stream of U

Преобразует стрим, получает первоначальный `state` вызывая `initHandler` для первого элемента.
Для последующих элементов сначала вызывает `switchHandler`, и если тот вернул true, то немедленно отдаёт в поток текущий `state` и снова вызывает `initHandler`, а иначе вызывает `updateHandler`, передавая `state`, полученный при обработке предыдущего элемента.
По завершении стрима возвращает последнее значение `state`, либо формирует пустой стрим, если исходный стрим был пуст.

### Squeeze
**Аргументы**:

| stream | state | handler |
| --- | --- | --- |
| Stream of T | U | Lambda (item:T, state:U)->U |

**Возвращаемый тип**: Stream of U

Преобразует стрим, вызывая `handler` для каждого элемента, передавая `state`, полученный при обработке предыдущего элемента. В результате обработки всего стрима возвращается одно последнее значение `state` либо начальное значение `state`, если стрим был пуст.

*Устаревшая*: Будет удалена - используйте `Condense`.

### Squeeze1
**Аргументы**:

| stream | initHandler| updateHandler |
| --- | --- | --- |
| Stream of T | Lambda (item:T)->U | Lambda (item:T, state:U)->U |

**Возвращаемый тип**: Stream of U

Преобразует стрим, вызывая `initHandler` для первого элемента и `updateHandler` для последующих, передавая `state`, полученный при обработке предыдущего элемента. В результате обработки всего стрима возвращается одно последнее значение `state`, либо формируется пустой стрим, если исходный стрим был пуст.

*Устаревшая*: Будет удалена - используйте `Condense1`.

### MultiHoppingCore
**Аргументы**

| stream | keyExtractor| timeExtractor | hop | interval | delay | initHandler | updateHandler | saveHandler | loadHandler | mergeHandler | finishHandler |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| Stream of T | Lambda (item:T)->K | Lambda (item:T)->Timestamp? | Interval | Interval | Interval | Lambda (item:T)->S | Lambda (item:T, state:S)->S | Lambda (state:S)->Z | Lambda (state:Z)->S | Lambda (state1:S, state2:S)->S | Lambda (key:K, state:S, time:F)->U |

**Возвращаемый тип**: Stream of U

Разбивает входящий поток по ключам, которые получаются путем применения `keyExtractor` к каждому элементу потока. Внутри каждого ключа совершает агрегацию значений согласно алгоритму [HoppingWindow](https://docs.yandex-team.ru/rtmapreduce/faq/_includes/yql#hop_window).

* `timeExtractor` функция для извлечения времени для каждой записи
* `hop` размер одного hop (см. описание алгоритма hoppping window)
* `interval` размер interval (см. описание алгоритма hoppping window)
* `delay` время ожидания отставших данных до закрытия окна

* `initHandler` вызывается для входящего элемента, если других элементов с таким ключем не было ранее. Результатом вызова является стейт, который будет храниться для указанного ключа и использоваться в дальнейшей работе
* `updateHandler` вызывается в том случае, когда элемент с таким-же ключем уже был встречен ранее. Принимает на вход сам элемент из потока и сохраненный для текущего ключа и bucket стейт. Соответсвенно, результатом вызова должен быть новый стейт, который будет сохранен вместо предыдущего.
* `saveHandler` преобразует значение внутри каждого bucket в вид используемый для сохранения состояния.
* `loadHandler` вызывается при загрузке сохраненного состояния каждого bucket.
* `mergeHandler` вызывается при необходимости смержить состояние двух bucket.
* `finishHandler` вызывается при закрытии окна. Принимает на вход `key` - ключ для которого произошло закрытие, `state` - сохраненное для окна состояние, `time` - конечное время закрытого окна. Вернувшийся результат будет записан в выходной поток.

## Общие операции
### Pickle, StablePickle
**Аргументы**:

| value |
| --- |
| T |

**Возвращаемый тип**: String

Сериализует произвольный объект в последовательность байт. Несериализуемыми являются Callable и Resource.
Формат сериализации не версионируется, допускается использовать в пределах одного запроса.
Для типа `Dict` функция StablePickle предварительно сортирует ключи, а для Pickle порядок элементов словаря в сериализованном представлении не определен.

### Unpickle
**Аргументы**:

| type | buffer |
| --- | --- |
| Type of T | String |

**Возвращаемый тип**: T

Десериализует произвольный объект из последовательности байт. Если возникает ошибка десериализации, то выполнение прерывается. Предполагается, что буфер перед этим сформирован функцией Pickle или StablePickle.

### ConstraintsOf
**Аргументы**:

| value |
| --- |
| * |

**Возвращаемое значение**: Yson

Извлекает набор констрейнтов из своего аргумента. Возвращаемый Yson представляет собой словарь, ключами которого являются названия констрейнтов. Структура значений определяется самим констрейнтом.

### Ensure
**Аргументы**:

| value | predicate | [message] |
| --- | --- | --- |
| T | Bool | String |

**Возвращаемый тип**: T

Возвращает первый аргумент, если во время выполнения значения предиката было true, иначе генерирует ошибку во время выполнения.
Если указан аргумент message, то он добавляется в сообщение об ошибке, если не пуст.

### EnsureType, EnsureConvertibleTo
**Аргументы**:

| type | expected | [message] |
| --- | --- | --- |
| TypeOf(T) | TypeOf(U)| String |

**Возвращаемый тип**: TypeOf(T)

| value | expected | [message] |
| --- | --- | --- |
| T | TypeOf(U)| String |

**Возвращаемый тип**: T

Возвращает первый аргумент, если тип T равен типу U (для EnsureType) или может быть неявно преобразован в тип U (для EnsureConvertibleTo).
Иначе генерирует ошибку типизации.
Если указан аргумент message, то он добавляется в сообщение об ошибке, если не пуст.
