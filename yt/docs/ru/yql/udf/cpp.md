# Разработка UDF на C++

## Введение
На данный момент в YQL поддерживаются пользовательские функции (UDF) на C++, Python{% if audience == "internal" %} и JavaScript{% endif %}. Ниже речь пойдет только о C++, про [Python](python.md){% if audience == "internal" %} и [JavaScript](javascript.md) есть отдельные статьи.{% else %} есть отдельная статья.{% endif %}

На сервисе YQL уже установлен набор базовых функций — рекомендуем ознакомиться со [списком](list/index.md){% if audience == "internal" %} или просто поизучать директорию Аркадии, которая будет описана ниже, чтобы избежать изобретения велосипеда{% endif %}.

## Терминология

* **Вызываемое значение** <span style="color: gray;">callable</span> — сущность с фиксированной, строго типизированной сигнатурой, которая при вызове способна вернуть результат по своим аргументам.
* **Пользовательская функция** <span style="color: gray;">(function, user defined function, UDF)</span> — фабрика по созданию вызываемых значений.
* **Модуль** <span style="color: gray;">(module)</span> — набор тесно связанных функций с общим префиксом; все функции модуля распространяются вместе в одной разделяемой библиотеке (`.so`). Если модуль специфичен для какого-либо проекта, то крайне желательно отразить это в его имени в виде префикса.
* **Регистратор** <span style="color: gray;">(registrator)</span> — интерфейс для внесения модулей и функций в общий реестр.
* **Группа модулей** <span style="color: gray;">(group)</span> — группа модулей, принадлежащих структурному подразделению или крупному проекту; служит лишь для логического разделения исходного кода (см. следующий раздел), из YQL/SQL не видна.
* **Конфигурационные параметры** — опциональный механизм для настройки пользовательской функции (фабрики вызываемых значений). Позволяют изменить поведение вызываемых значений без перекомпиляции:
    * `Type Config`, `User Type` — по ним функция должна определить и объявить сигнатуру вызываемого значения; используется при построении графа вычислений. Должны быть известны в момент компиляции, поэтому `Type Config` обязательно должен быть атомом, а `User Type` — некоторым типом, например полученным с помощью операции TypeOf.
    * `Run Config` — по нему функция должна вернуть вызываемое значение с объявленной ранее сигнатурой. Тип значения Run Config указывается в коде UDF при объявлении сигнатуры вызываемого значения. Отличается от обычного аргумента тем, что он передается при инициализации, а не при каждом вызове.

{% if audience == "internal" %}
## Рекомендуемая структура директорий
Технических ограничений для разработки пользовательских функций (UDF) внутри или за пределами вашей части Аркадии нет. Однако рекомендуем придерживаться следующей конвенции, чтобы мы знали о существовании вашей UDF и могли заранее указать на потенциальные проблемы (посткоммит-ревью) или провести массовый рефакторинг: `{{yql.udf-rule-dir}}`

Группа `common` предназначена для общественно полезных функций и библиотек, а конкретные крупные проекты и сервисы располагаются рядом на том же уровне. Рекомендуется, чтобы имя директории на следующем уровне вложенности соответствовало располагающемуся в ней модулю. В модули входят наборы тесно связанных пользовательских функций, которые можно размещать в общем файле (`.cpp`) или в отдельных файлах в зависимости от размера их кода.

## Примеры
Примеры готовых модулей можно посмотреть здесь:

* <{{source-root}}/yql/udfs>
* <{{source-root}}/yql/essentials/udfs>

Совсем простые примеры см. в поддиректории [examples]({{source-root}}/yql/udfs/examples), приближенные к реальности — в остальных, например [common]({{source-root}}/yql/essentials/udfs/common?rev=r15269206).

Перед изучением следующего раздела рекомендуем открыть один или несколько примеров, так как в разделе даны только пояснения к коду, но полные листинги не приводятся.

## Деплой вместе с YQL релизами

Чтобы UDF деплоилась вместе с YQL релизами, ее нужно указать в [a.yaml файле]({{source-root}}/yql/ci/projects/common.a.yaml?rev=r13986026#L233-268).

## Ограничения на использование UDF в сервисе YQL

Внешние сотрудники не могут запускать запросы с приложенными к ним С++ UDF. Такие запросы будут завершаться с ошибкой `Native UDF support is disabled`. Роботы также по умолчанию относятся к внешним сотрудникам, за исключением тех, у кого во владельцах прописаны штатные струдники. Подробности см. в [соответсвующем посте]({{nda-link}}/mTvAZ_w47EVF3e).

{% else %}

## Примеры
Примеры готовых модулей можно посмотреть здесь: [{{source-root}}/yql/essentials/udfs]({{source-root}}/yql/essentials/udfs).

Совсем простые примеры см. в поддиректории [examples]({{source-root}}/yql/essentials/udfs/examples), приближенные к реальности — в остальных, например [common]({{source-root}}/yql/essentials/udfs/common).

Перед изучением следующего раздела рекомендуем открыть один или несколько примеров, так как в разделе даны только пояснения к коду, но полные листинги не приводятся.

{% endif %}

## Интерфейсы (С++)

### TUnboxedValue (udf\_value.h)

Класс-обертка вокруг типизированных данных. Предоставляет набор конструкторов для создания сложных типов данных из простых типов данных и набор хелперов для работы со сложными типами данных.

Числа, интервалы, даты, включая даты с временной зоной и короткие строки до 14 байт хранятся по значению, метод `IsEmbedded()` для них вернет `true`. Строки длиннее 14 байт хранятся по указателю.

### TUnboxedValuePod(udf\_value.h)

Является базовым классом для TUnboxedValue. Не
производит автоматический подсчет ссылок на свое значение, в отличие от своего наследника, который осуществляет это в конструкторе и деструкторе - ключевым моментом здесь является отсутсвие конструкторов и деструкторов у класса TUnboxedValuePod. Реализует всю логику работы с
типизированными данными.

### IValueBuilder (udf\_value\_builder.h)

Метод Run должен возвращать TUnboxedValue. Для числовых типов можно воспользоваться конструктором типа, например `return TUnboxedValue<ui32>(123);`. Для создания TUnboxedValue с более сложным содержимым в метод Run передается IValueBuilder. На нем можно вызвать один из методов `New***` для получения интерфейса `I***ValueBuilder`, где *** — одно из String/Struct/Dict/пр. С его помощью можно добавить специфичных для каждого типа элементов и в конце вызвать `Build` для получения заполненного TUnboxedValue.
Есть вариант создать Struct/Tuple с преаллокацией для хранения содержимого, для этого надо вызвать соответствующий метод `New***(const TType* type, TUnboxedValue*& items)` и заполнить элементы items на месте.


См. [{{yql.udf-ivaluebuilder-example}}]({{yql.udf-ivaluebuilder-example-link}}) для примера со структурами.

### TBoxedValue (udf\_value.h)
Класс типичного UDF наследуется от TBoxedValue и помимо конструктора переопределяет метод Run, в котором должна размещаться основная логика по обработке одного конкретного вызова. В аргументы Run передается интерфейс IValueBuilder, о котором ниже, а также сами переданные аргументы в виде массива TUnboxedValue.

В конструкторе можно сохранить какое-то состояние в приватные переменные класса, таким образом конкретный объект нашего класса-наследника TBoxedValue превращается в вызываемое значение с потенициально уникальным поведением.

Для простых UDF (без использования YQL-структур, C++ шаблонов, наследования и т. п.), можно воспользоваться макросом `SIMPLE_UDF(udfName, signature)` (находится в `udf_helpers.h`). `signature` задается в виде `returnType(arg1, arg2, ..., argN)`.

Пример использования:
``` cpp
SIMPLE_UDF(TAbs, ui64(i64)) {
    i64 input = args[0].Get<i64>();
    ui64 result = static_cast<ui64>(input >= 0 ? input : -input);
    return TUnboxedValue(result);
}
```
Функция будет зарегистрирована под именем `Abs`, аргумент типа `i64`, результат — `ui64`.

Пример, когда успех не гарантируется:
``` cpp
SIMPLE_UDF(TParseDuration, TOptional<ui64>(char*)) {
    TDuration result;
    auto input = args[0].AsStringRef();
    bool success = TDuration::TryParse(input, result);
    return success ? TUnboxedValue::Optional(result.Seconds()) : TUnboxedValue();
}
```
Под `Optional (type)` ([тип, допускающий значение NULL](../types/optional.md)) подразумевается возможность отсутствия значения указанного типа, например в случае какой-то ошибки. Из SQL такого типа наличие в результате  можно проверить с помощью конструкции `IS [NOT] NULL`.

### IUdfModule (udf\_registrator.h)

Для типовых модулей можно воспользоваться макросом `SIMPLE_MODULE(moduleName, udfs...)` (находится в `udf_helpers.h`):

* Первым аргументом — имя класса-модуля, при регистрации префикс `T` и суффикс `Module` будут отброшены.
* Далее — список из N входящих в него UDF, при регистрации которых будет отброшен только префикс `T`.

Таким образом, в примере `SIMPLE_MODULE(TFooModule, TBar, TBaz)` после регистрации (о которой ниже) из YQL будет доступен модуль `Foo` с двумя UDF — `Bar` и `Baz`.

#### Реализация модуля вручную

Класс типичного модуля наследуется от IUdfModule и должен реализовать два метода:

* `GetAllFunctionNames` — в переданном `IFunctionNamesSink` нужно вызвать метод `Add(name)` для каждой из UDF, входящей в модуль.
* `BuildFunctionTypeInfo` — по переданному имени UDF и Type Config нужно на переданном `IFunctionTypeInfoBuilder` вызвать:
  * `Args()->Add<ui32>()[->Add(foo)->Add...].Done()`:
    * для указания аргументов и их типов, для чисел и строк тип аргумента можно указать шаблоном;
    * сложный тип вроде Struct/Dict/etc можно описать с помощью одноименного метода `IFunctionTypeInfoBuilder`, затем передав его в аргумент `Add`, пример:
``` cpp
ui32 a = 0;
ui32 b = 0;
auto foo = builder.Struct()->AddField<char*>("A", &a).AddField<ui32>("B", &b).Build();
builder.Args()->Add(foo);
```
  * При описании типов наподобие `builder.List()->...` следует максимально внимательно копировать чужие примеры, так как часто вызов цепочки методов билдера в неправильной последовательности или с неправильными аргументами нормально компилируется, но в рантайме падает в корку с нетривиальным бектрейсом. Пример такой цепочки:

``` cpp
// udf returns list of lists of char*
auto retType = buider.List()->Item(builder.List()->Item<char*>().Build()).Build(); // Correct
auto retType = buider.List()->Item<char*>().Build(); // Wrong type, coredump with backtrace in casting to string deep in validating
auto retType = buider.List()->Build(); // No type at all, coredump with attempt to dereference nullptr deep in type machinery
builder.Returns(retType);
```
  * Также в аргументах передается битовая маска `ui32 flags`, в которой на момент написания может присутствовать только `(cpp)TFlags::TypesOnly`, при наличии которого не обязательно вызвать `builder.Implementation(new TMyUdf);` для UDF, соответствующей переданному имени.

{% if audience == "internal" %}
#### Реализация UDF через кодогенерацию

Начиная с версии ABI 2.16, UDF может дополнительно предоставлять BC модуль для встраивания в кодогенерацию графа вычислений. Для этого на интерфейсе `IFunctionTypeInfoBuilder` нужно вызывать метод `builder.IRImplementation(moduleIR, moduleUniqId, functionName)` и передать туда сам BC-модуль, его уникальный ID и имя функции внутри модуля, которая реализует UDF. В этом случае код функции из BC-модуля будет встроен в общий генерируемый код графа вычислений. Уникальный ID модуля нужен для предотвращения повторной линковки модуля, если в нем находятся реализации сразу нескольких UDF.

Функция с реализацией UDF должна иметь следующую сигнатуру:
``` cpp
// pThis - указатель на объект, переданный в `builder.Implementation()`
// result - указатель на память, куда нужно положить результат вычислений UDF.
//   Если возвращаемый объект не embedded, то счетчик на нем должен быть сброшен в 0
// valueBuilder - указатель на valueBuilder
// args - указатель на массив аргументов
extern "C" void UDFFunction(
    const NKikimr::NUdf::IBoxedValue* pThis,
    NKikimr::NUdf::TUnboxedValuePod* result,
    const NKikimr::NUdf::IValueBuilder* valueBuilder,
    const NKikimr::NUdf::TUnboxedValuePod* args
);
```

Дополнительно можно форсировать inlining функции LLVM-компилятором, добавив макрос `UDF_ALWAYS_INLINE` перед ней.

Если BC-модуль включает файлы из {{yql.udf-ydb-link}}, то их нужно предварить определением `#define LLVM_BC`, чтобы исключить попадание в BC-модуль лишних зависимостей.

Для реализации типовой UDF с BC-модулем, скомпилированным через LLVM\_BC, можно воспользоваться макросом `SIMPLE_UDF_WITH_IR(udfName, signature, resourcePath, functionName)` (находится в `udf_helpers.h`). `resourcePath` является путем к ресурсу, в котором лежит скомпилированный BC-модуль. Она же используется и как уникальный идентификатор модуля при вызове `builder.IRImplementation`. `functionName` задает строку с именем функции, реализующей UDF в BC-модуле.

Пример BC-модуля с реализацией UDF `Math::Pi`:
``` cpp
#define LLVM_BC

#include <contrib/ydb/library/yql/public/udf/udf_value.h>
#include <util/generic/ymath.h>
#include <util/system/compiler.h>

namespace NKikimr {
namespace NUdf {

extern "C" UDF_ALWAYS_INLINE
void Pi(const IBoxedValue* /*pThis*/, TUnboxedValuePod* result, const IValueBuilder* /*valueBuilder*/, const TUnboxedValuePod* /*args*/) {
    *result = TUnboxedValuePod(M_PI);
}

}
}
```

Пример реализации UDF с поддержкой кодогенерации:
``` cpp
SIMPLE_UDF_WITH_IR(TPi, double(), "/llvm_bc/Math", "Pi") {
    TUnboxedValuePod res;
    Pi(this, &res, valueBuilder, args);
    return res;
}
```
{% endif %}
### IRegistrator (udf\_registrator.h)

Для упрощенной регистрации модуля в системе рекомендуется использовать макрос:
``` cpp
REGISTER_MODULES(
    TFooModule,
    TBarModule<true>,
    TBarModule<false>
)
```
Имя модуля в этом случае берется из метода `Name()`, который должен вернуть `TStringRef` по значению, макрос `SIMPLE_MODULE` создает его автоматически.

#### Альтернативный вариант для продвинутых пользователей

Нужно объявить функцию `Register` следующего вида и в переданном интерфейсе зарегистрировать модуль(-и), а также экспортировать версию ABI:
``` cpp
extern "C" YQL_UDF_API void Register(NKikimr::NUdf::IRegistrator& registrator, ui32 flags)
{
     registrator->AddModule("Foo", new NDetail::TFooModule(flags));
}

extern "C" YQL_UDF_API ui32 AbiVersion()
{
    return CurrentAbiVersion();
}
```
Список флагов перечислен в `IUdfModule::TFlags`. На момент написания реализован только `TypesOnly`, который используется как указание на то, что реальных вычислений пока производиться не будет, так как ещё идет построение графа вычислений, и на данном этапе нужны только сигнатуры функций.

### Обработка исключений/ошибок

Чтобы возвращать пользователю фатальные исключения, нужно использовать следующую конструкцию:

``` cpp
try {
   ...
} catch (const std::exception& e) {
    UdfTerminate(e.what());
}
```

Вместо `e.what()` можно написать человекочитаемое описание ошибки, если это возможно.

{% note warning "Внимание" %}

Завершать выполнение программы целиком с помощью `abort`, `exit`, `Y_ABORT_UNLESS`, `Y_ABORT` и подобных механизмов из кода UDF крайне не рекомендуется, так как это ограничит область её применения только теми окружениями, где под каждый расчет создается отдельный процесс. Реализация `UdfTerminate` знает о текущем окружении и вызовет ожидаемый им механизм обработки ошибок.

{% endnote %}

{% if audience == "internal" %}
### ya.make

В ya.make вместо `PROGRAM/LIBRARY` нужно использовать макрос `YQL_UDF`, который собирает директорию как динамически загружаемую библиотеку `.so`, автоматически приписывая нужный `PEERDIR` и другие настройки. Так как получающиеся после сборки `.so` часто затем попадают в плоскую директорию, во избежание потенциальных коллизий рекомендуется использовать префикс проекта в первом аргументе макроса `YQL_UDF`.

Бинарный интерфейс (ABI) фреймворка UDF со временем эволюционирует и расширяется, что отражается в его версии. Используемая в UDF версия ABI указывается в её `ya.make` с помощью макроса `YQL_ABI_VERSION`, например `YQL_ABI_VERSION(2 0 0)`. В зависимости от указанной версии часть интерфейсов может быть доступна или нет, см. условия вида `#if UDF_ABI_COMPATIBILITY_VERSION_CURRENT >= UDF_ABI_COMPATIBILITY_VERSION(2, 0)` в [{{source-root}}/yql/essentials/public/udf/udf_value.h]({{source-root}}/yql/essentials/public/udf/udf_value.h).

## SecureParams

SecureParam - механизм передачи секретов, позволяющий использовать секретную информацию в программе, но при этом не позволяющий эту информацию узнать, используется главным образом в Udf. Например используется [PushData Udf]({{yql.pages.udf.push-data}}) для получения токена.

Сигнатура:
``` yql
SecureParam(String) -> String
```

Для пользователя SecureParams представляет собой функцию `SecureParam` принимающая строку - идентификатор секрета. Идентификатор представляет собой строку вида `"type:id"`, где `type` - тип секрета, `id` - собственно ключ (имя) по которому можно получить секрет.
Пример:
```
$oauth_token = AsTuple("token", SecureParam("token:database"));`
```
Другие возможные идентификаторы:

`"api:oauth"` - oauth токен текущего пользователя
`"api:cookie"` - сессионная кука текущего пользователя

{% endif %}

