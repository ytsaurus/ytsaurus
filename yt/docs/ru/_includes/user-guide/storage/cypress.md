# Дерево метаинформации

В данном разделе приведено описание Кипариса — дерева метаинформации. Кипарис содержит в себе различную системную информацию, а также данные о том, где хранятся пользовательские данные. Раздел состоит из трех частей, описывающих [общее представление дерева](#description), [атрибуты узлов Кипариса](#attributes) и [TTL для узлов Кипариса](#TTL).

## Общее представление дерева { #description }

С пользовательской точки зрения Кипарис похож на дерево [файловой системы](https://ru.wikipedia.org/wiki/Файловая_система) в Linux, но имеет ряд существенных отличий. Во-первых, с каждым узлом в дереве связан [набор атрибутов](../../../user-guide/storage/attributes.md), в том числе задаваемых пользователем. Во-вторых, дерево является [транзакционным](../../../user-guide/storage/transactions.md). В третьих, в качестве узла Кипариса могут быть не только файлы и директории, но и [другие объекты](../../../user-guide/storage/objects.md). По аналогии с файловой системой в Кипарисе поддерживается [система контроля доступов](../../../user-guide/storage/access-control.md).

Корневым элементом Кипариса является `/`, который имеет тип **map_node** (то есть является директорией). Адресация узлов в Кипарисе осуществляется с помощью [YPath](../../../user-guide/storage/ypath.md).

Примеры путей: `//tmp` – временная директория, `//tmp/@` – атрибуты этой директории, `//tmp/table/@type` – путь до атрибута `type` узла `//tmp/table`.

С использованием YPath Кипарис может быть изображен следующим образом:

```
/
  /home
    /user1
      /table
        /@id
        /@chunk_ids
        /@type
        ...
      ...
    /user2
    ...
  /tmp
  /sys
    /chunks
      ...
    ...
  ...
```

С Кипарисом можно работать с помощью [CLI](../../../api/cli/cli.md).

## Атрибуты узлов Кипариса { #attributes }

Помимо атрибутов, общих для всех объектов, узлы Кипариса имеют дополнительные атрибуты, представленные в таблице:

| **Атрибут**                | **Тип**            | **Значение**                                                                                                                  |
| -------------------------- | ------------------ | ------------------------------------------------------------                                                                  |
| `parent_id`                | `string`           | Идентификатор узла-родителя (отсутствует в корне)                                                                             |
| `locks`                    | `array<Lock>`      | [Список блокировок](../../../user-guide/storage/transactions.md), взятых на узел                                                               |
| `lock_mode`                | `LockMode`         | Текущий [режим блокировки](../../../user-guide/storage/transactions.md) узла (зависит от транзакции)                                           |
| `path`                     | `string`           | Полный путь к узлу                                                                                                            |
| `key`                      | `string`           | Ключ, по которому данный узел доступен в родительском каталоге (если узел лежит в таковом)                                    |
| `creation_time`            | `DateTime`         | Время [создания](#time_attributes) узла                                                                                       |
| `modification_time`        | `DateTime`         | Время [последней модификации](#time_attributes) узла                                                                          |
| `access_time`              | `DateTime`         | Время [последнего доступа](#time_attributes) к узлу                                                                           |
| `expiration_time`          | `DateTime`         | Время, когда узел будет [автоматически удален](#TTL). Опциональный атрибут                                                    |
| `expiration_timeout`       | `DateTime`         | Интервал времени, после которого узел будет [автоматически удален](#TTL), если к нему не было обращений. Опциональный атрибут |
| `access_counter`           | `integer`          | Количество обращений к узлу с момента создания                                                                                |
| `revision`                 | `integer`          | [Ревизия](#time_attributes) узла                                                                                              |
| `resource_usage`           | `ClusterResources` | Ресурсы кластера, занимаемые узлом                                                                                            |
| `recursive_resource_usage` | `ClusterResources` | Ресурсы кластера, занимаемые узлом и всем его поддеревом                                                                      |
| `account`                  | `string`           | Аккаунт, используемый при учете ресурсов, занимаемых данным узлом                                                             |
| `annotation`               | `string`           | Человекочитаемая [аннотация](../../../user-guide/storage/annotations.md) объекта                                                               |

Каждый узел имеет свой свой атрибут, отвечающий за управление доступом, поэтому среди его атрибутов есть `inherit_acl`, `acl` и `owner`, подробнее можно прочитать в разделе [Система контроля доступов](../../../user-guide/storage/access-control.md).

### Атрибуты времени { #time_attributes }

Атрибут `creation_time` хранит время, когда узел был создан. Атрибут `modification_time` хранит время, когда узел или его атрибуты в последний раз изменялись. Атрибут `modification_time` не учитывает изменение сыновей узла, т.е. атрибут `modification_time` у `map_node` не меняется, если где-то в глубине дерева происходят изменения.

При создании и при каждом изменении узла система обновляет его атрибут `revision`. В нем хранится неотрицательное целое число. Гарантируется, что ревизия с течением времени растет строго монотонно. Ревизии можно использовать для проверки того факта, что узел не изменился. Атрибут `revision` изменяется одновременно с `modification_time`.

Атрибут `access_time` хранит время последнего обращения к содержимому узла. Обращение к атрибутам при этом не учитывается. Также, для повышения эффективности система не изменяет данный атрибут на каждое обращение, а накапливает факты обращений и обновляет атрибут `access_time` с периодичностью порядка секунды.

{% note warning "Внимание" %}

В редких случаях возможна ситуация, когда к узлу было обращение, но в результате сбоя мастер-сервера атрибут `access_time` не будет обновлен.

{% endnote %}

Для большинства команд, при помощи которых происходит чтение или запись, существуют опции `suppress_access_tracking` и `suppress_modification_tracking`, которые позволяют отключить обновления атрибутов `access_time`, `modification_time` и `revision` при чтении и записи соответственно. В частности, {{web-interface}} использует `suppress_access_tracking`, так что просмотры содержимого через web UI не приводят к обновлению `access_time`.

{% note info "Примечание" %}

В случае создания или модификации узла под транзакцией описанные атрибуты устанавливаются один раз: во время изменений внутри транзакции. Таким образом, узел может стать виден в родительских транзакциях существенно позже, чем его `creation_time`, только после коммита соответствующей транзакции.

{% endnote %}

## TTL для узлов Кипариса { #TTL }

Кипарис может автоматически удалять узлы по наступлении указанного момента времени или в случае отсутствия обращений к узлу на протяжении указанного интервала времени. Для управления этой возможностью существуют атрибуты `expiration_time` и `expiration_timeout`. По умолчанию атрибуты отсутствуют, в этом случае система не будет автоматически удалять узел. Для работы TTL необходимо:
  - указать в атрибуте `expiration_time` момент времени, при наступлении которого узел будет удален. Если узел композитный, то будет также удалено все его поддерево;
  - указать в атрибуте `expiration_timeout` интервал времени, в течение которого к узлу должны отсутствовать обращения, чтобы узел (и все его поддерево, если узел композитный) был удален.

Момент времени необходимо указать либо строкой в isoformat, либо целым числом миллисекунд с начала эпохи. Эти способы эквивалентны:

```bash
yt set //home/project/path/table/@expiration_time '"2020-05-16 15:12:34.591+03:00"'
yt set //home/project/path/table/@expiration_time '1589631154591'
```

Интервал времени указывается в миллисекундах:
```bash
# Удалить узел, если его «не трогали» неделю.
yt set //home/project/path/table/@expiration_timeout 604800000
```

{% note warning "Внимание" %}

Данные, удаленные с помощью описанного механизма, невозможно восстановить. Используйте его с осторожностью.

{% endnote %}

Данные атрибуты можно менять в транзакциях, однако эффект имеют только их закоммиченные значения.

Чтобы выставлять данные атрибуты для узла, необходимо иметь [право](../../../user-guide/storage/access-control.md) `write` на сам узел, как и для многих других атрибутов, а также `remove` для данного узла и всего его поддерева, так как фактически заказывается удаление, хоть и отложенное. Чтобы удалить данные атрибуты, достаточно права `write`.

Система не дает никаких гарантий точности времени удаления. На практике удаление происходит в пределах единиц секунд после наступления указанного времени.

Автоматическое удаление узла не наступает, если в момент наступления указанного времени на узле есть блокировки, отличные от `snapshot`. Система удалит узел, как только все блокировки будут сняты. Этим свойством можно пользоваться для искусственного продления времени жизни узла.

При копировании и перемещении узла атрибуты `expiration_time` и `expiration_timeout` по умолчанию сбрасываются, так что копия не будет автоматически удалена. У команд есть опции `preserve-expiration-time` и `preserve-expiration-timeout`, позволяющие поменять поведение.

{% note warning "Внимание" %}

Ряд вызовов API, создающих временные таблицы, устанавливают на них `expiration_time`/`expiration_timeout`, чтобы таблицы самоочищались. Следует иметь это в виду и не хранить в таких таблицах важные данные.

{% endnote %}

Удаление может произойти раньше, если узел находится в поддереве с меньшим значением `expiration_time`/`expiration_timeout` в корне. Чтобы получить фактическое время удаления узла, можно воспользоваться атрибутом `effective_expiration`:

```bash
$ yt get //home/project/path/table/@effective_expiration
{
  "time": {"value": 42, "path": //testator/path}
  "timeout": {"value": 42, "path": //testator/path}
}
```

При отсутствии, например, `expiration_time` на пути от корня до узла, в поле `"time"` будет записано YSON entity.