# Аккаунты

В данном разделе рассказывается об аккаунтах и связанных с ними квотах в системе {{product-name}}. Приводится описание иерархии аккаунтов, даются примеры действий с аккаунтами, приводится перечень атрибутов аккаунта.

## Общие сведения { #common }

Все типы квот для хранения данных привязаны к **аккаунту** проекта. Аккаунт — это служебный объект в [Кипарисе](../../../user-guide/storage/cypress.md). Все аккаунты имеют уникальные имена. При этом они находятся в отдельном пространстве имён, так что имя пользователя и аккаунта могут совпадать. Имя аккаунта хранится в атрибуте `name`, доступном как на чтение, так и на запись.

Все известные системе аккаунты можно найти в `//sys/accounts`. Создание и удаление аккаунтов производится командами `create` и `remove`.

## Атрибуты узлов { #attributes }

Каждый узел Кипариса имеет атрибут `account`, доступный на чтение и запись. Этот атрибут хранит имя аккаунта, к которому привязан данный узел. В случае файлов и таблиц назначение аккаунта влечет за собой расход его дисковой квоты. При этом учитывается пространство, физически выделенное на узлах кластера для хранения данных, поэтому оно зависит от степени репликации (атрибут `replication_factor`), способа erasure-кодирования (атрибут `erasure_codec`) и используемой компрессии (атрибут `compression_codec`).

Различные узлы Кипариса (файлы или таблицы) могут ссылаться на одни и те же чанки. Кроме того, один и тот же узел может ссылаться на чанк несколько раз. Подобное повторное использование может возникнуть, например, в результате работы команды `copy` для таблиц и файлов, а также команд `merge` и `erase` для таблиц. Такие чанки учитываются в квоте единожды (с максимальным среди ссылающихся на них таблиц коэффициентом репликации).

Узлы всех остальных типов (отличных от файлов и таблиц) не требуют хранения данных на нодах кластера и потому не расходуют дисковую квоту аккаунта.

В случае композитных узлов потомки при создании автоматически наследуют аккаунт родителя (если не указано иное). Выставление правильного значения атрибута `account` на домашней директории пользователя гарантирует, что созданные им таблицы и файлы по умолчанию будут отнесены к правильному аккаунту.

Чтобы узнать, сколько и каких ресурсов потребляет данный узел Кипариса, следует использовать его атрибут `resource_usage`. Также существует вычисляемый атрибут `recursive_resource_usage`, отмеряющий использование ресурсов с учетом потомков. Данные атрибуты имеют структуру `ClusterResources`, смотрите далее.

Чтобы выставить аккаунт `A` некоторому узлу Кипариса, пользователь, инициировавший данное изменение, должен иметь право `use` на аккаунте `A`. Кроме того, у него должно быть право `write`. Аккаунт для узла можно также указать сразу в момент создания узла; в этом случае также необходимо иметь право `use`.

При копировании частей Кипариса командой `copy`, а также при перемещении командой `move` аккаунты, а также владельцы в копируемом поддереве изменяются — они становятся равными аккаунту каталога, куда происходит копирование, и пользователю, выполняющему копирование, соответственно. Чтобы предотвратить изменение аккаунта, существует опция `preserve_account`.

В случае превышения пользователем квоты аккаунта по отдельным видам ресурсов система начинает отказывать в дальнейшем использовании аккаунта по превышенному виду ресурса. Это не означает, что использование аккаунта никогда не превышает лимитов. Например, лимиты могли быть принудительно выставлены ниже использования. Кроме того, отслеживание потребления дисковой и чанковой квот работает асинхронно, что также может выливаться в превышение отведенных лимитов.

## Иерархия аккаунтов { #account_tree }

Аккаунты могут быть вложены в другие аккаунты. Это позволяет гибко настраивать квоты и естественным образом отражать в них организационную структуру, которой принадлежат пользователи и проекты. Например, может существовать общая квота отдела и вложенные в нее проектные квоты или, например, аккаунт сервиса и подаккаунты входящих в него групп. Основным преимуществом представления аккаунтов в виде дерева является то, что пользователи получают возможность самостоятельно управлять выданными им квотами, разделяя их на части и объединяя воедино по необходимости.

Далее в разделе описывается иерархическая организация аккаунтов и принципы работы с этой иерархией — из командной строки и веб-интерфейса.

### Квотирование { #account_tree_algo }

Квота, выданная любому неверхнеуровневому аккаунту, не может превышать квоту его родителя (и, по индукции, любого предка).

По умолчанию сумма квот подаккаунтов не может превышать квоту родителя. Но иногда такая переподписка может быть удобной, поэтому её можно включить:

```bash
yt set //sys/account_tree/my_account/@allow_children_limit_overcommit %true
```

В таком режиме сумма лимитов детей может превышать лимит родителя. Тем не менее, лимит индивидуального подаккаунта по-прежнему должен быть меньше либо равен лимиту родительского аккаунта.

Написанное выше относится к лимитам потребления (`limits`), а не к используемым ресурсам (`usage`). Ресурсы, использованные в некотором аккаунте, учитываются в его квоте, а также в квотах всех его предков. Валидация работает так же: если увеличение потребления привело бы к исчерпанию квоты в аккаунте или в любом из его предков, генерируется ошибка.

**Можно ли занимать ресурсы в нелистовых аккаунтах?**
Технически возможно, но пользователю будет сложнее оценить, где расходуется квота.

**Верно ли, что аккаунт не может переполниться, если на нем не включен флаг, разрешающий оверкоммит дочерним аккаунтам?**
Верно тогда и только тогда, когда непосредственно в данном аккаунте не используются ресурсы.

### Просмотр дерева аккаунтов { #account_tree_viewing }

Несмотря на иерархическую организацию, аккаунты обладают глобально уникальными именами. Данное обстоятельство существенно упрощает работу с ними, т.к. позволяет ссылаться на аккаунт, не указывая полный путь к нему.

{% cut "В веб-интерфейсе {{product-name}}" %}

Иерархия аккаунтов представлена на странице **Accounts** (а также в разделе **Dashboard**). Благодаря глобальной уникальности имен, редактируя путь к аккаунту, достаточно указать лишь его имя.

![](../../../../images/account_tree_view.png){ .center }

{% endcut %}

{% cut "В командной строке" %}

Дерево аккаунтов в Кипарисе находится по пути `//sys/account_tree`. Полный плоский список доступен по пути `//sys/accounts` (имена аккаунтов глобально уникальны, несмотря на иерархическую организацию).

```bash
$ yt list //sys/account_tree/my_account
my_subaccount1
my_subaccount2

$ yt list //sys/accounts
my_account
my_subaccount1
my_subaccount2
```

{% endcut %}

### Создание аккаунта { #account_tree_creating }

Максимальная допустимая высота дерева аккаунтов равна 10.

Создать аккаунт верхнего уровня можно в веб-интерфейсе {{product-name}}, нажав **Create account** на странице **Accounts**. Вложенные аккаунты создаются из командой строки или в веб-интерфейсе {{product-name}}.

{% cut "В веб-интерфейсе {{product-name}}" %}

Для создания нового аккаунта необходимо:

1. На странице **Accounts** нажать **Create account**.
2. Указать {% if audience == "internal" %}ABC-сервис, {% endif%}название нового аккаунта, имя родительского аккаунта, в который будет вложен создаваемый аккаунт, а также ответственных за новый аккаунт пользователей. При необходимости можно также запросить автоматическое создание домашней директории, соответствующей аккаунту.

![](../../../../images/account_tree_create.png){ .center }

{% endcut %}

{% cut "В командной строке" %}

Чтобы создать аккаунт, в атрибуте `name` необходимо указать его имя, а в `parent_name` — имя родителя. Если имя родителя не указано, будет создан аккаунт верхнего уровня. Создавать такие аккаунты имеют право лишь администраторы {{product-name}}.

```bash
yt create account --attributes='{ name = "my_subaccount3"; parent_name = "my_account" }'
```

{% endcut %}

### Удаление аккаунта { #account_tree_removing }

Аккаунты можно перемещать и переименовывать, так что удалять аккаунт следует лишь в том случае, когда действительно отпала необходимость в его существовании.

{% note warning "Внимание" %}

Перед удалением аккаунта обязательно нужно убедиться, что в нем нет данных. В противном случае, аккаунт вместо удаления будет переведен в специальное состояние ожидания до тех пор, пока все ассоциированные с ним узлы Кипариса не будут удалены, после чего удаление произойдёт автоматически. Использовать аккаунт в таком состоянии невозможно, равно как и вернуть его в штатное состояние.

{% endnote %}

{% cut "В веб-интерфейсе {{product-name}}" %}

Для удаления аккаунта необходимо:

1. На странице **Accounts** найти аккаунт в списке и нажать значок с карандашом для редактирования аккаунта.
2. В появившемся диалоге перейти в раздел **Delete**, нажать кнопку **Delete** и подтвердить действие.

{% endcut %}

{% cut "В командной строке" %}

Чтобы удалить аккаунт, достаточно указать путь к нему:

```bash
yt remove //sys/accounts/my_subaccount3

# или

yt remove //sys/account_tree/my_account/my_subaccount3
```

{% endcut %}

### Перемещение или переименование аккаунта { #account_tree_moving }

{% cut "В веб-интерфейсе {{product-name}}" %}

Для перемещения аккаунта необходимо:

1. На странице **Accounts** найти аккаунт в списке и нажать значок с карандашом для редактирования аккаунта.
2. В появившемся диалоге в разделе **General** в выпадающем списке **Parent** выбрать, куда переместить аккаунт.

{% endcut %}

{% cut "В командной строке" %}

Переместить аккаунт можно двумя способами:

1. Перемещение аккаунта с помощью атрибута `parent_name`

```bash
$ yt set //sys/account_tree/my_account/my_subaccount3/@parent_name my_subaccount2
$ yt exists //sys/account_tree/my_account/my_subaccount3
%false
$ yt exists //sys/account_tree/my_account/my_subaccount2/my_subaccount3
%true
```

Благодаря глобальной уникальности имен аккаунтов, достаточно указать только имя родителя, а не полный путь к нему.

2. Перемещение аккаунта с помощью команды `move`

```bash
yt move //sys/account_tree/my_account/my_subaccount3 //sys/account_tree/my_account/my_subaccount2/my_subaccount3
```

Следует обратить внимание, что в качестве пути назначения указывается полный путь к аккаунту, включая его имя. В частности, это позволяет переименовать аккаунт одновременно с перемещением.

{% endcut %}

### Передача ресурсов одного аккаунта другому{ #account_tree_transferring_resources }

{% cut "В веб-интерфейсе {{product-name}}" %}

Для передачи ресурсов необходимо:

1. На странице **Accounts** найти аккаунт, которому нужно передать ресурсы, и нажать значок с карандашом для редактирования аккаунта.
2. В появившемся диалоге перейти в раздел, соответствующий типу ресурса, который необходимо передать.
3. Указать аккаунт, чьи ресурсы будут перераспределены (по умолчанию предлагается аккаунт-родитель), и новый лимит.
4. Нажать **Save**.

![](../../../../images/account_tree_transfer_resources.png){ .center }

{% endcut %}

{% cut "В командной строке" %}

Передача ресурсов аккаунта с помощью команды `transfer-account-resources`:

```bash
# yt transfer-account-resources <src_account> <dst_account> --resource-delta <resource_delta>
yt transfer-account-resources my_subaccount1 my_subaccount2 --resource-delta '{node_count=10}'
```

Аргумент `resource-delta` представляет собой YSON-структуру типа `ClusterResources` (смотрите ниже). Например: `{node_count=5;disk_space_per_medium={default=1024}}`. Необходимо указывать именно объём передаваемых ресурсов, а не новые лимиты. Отсутствующие квоты можно пропускать.

В случае ошибки `argument command: invalid choice` следует обновить утилиту `yt`. Подробнее можно прочитать в разделе [Как попробовать](../../../overview/try-yt.md).

{% endcut %}

## Встроенные аккаунты { #builtin_accounts }

Данные аккаунты появляются в системе в момент инициализации. Их нельзя удалить.

1. Аккаунт `tmp`. При инициализации назначается каталогу `//tmp`, а значит и всем его потомкам. По умолчанию правом пользоваться данным аккаунтом имеют все аутентифицированные пользователи системы (группа `users`).
2. Аккаунт `sys`. При инициализации назначается всем остальным узлам. Явных разрешений на его использование по умолчанию никому не выдаётся. Аккаунт используется для внутренних нужд системы {{product-name}}.

## Атрибуты аккаунта { #account_attributes }

| **Атрибут**                        | **Тип**                           | **Описание**                                                 |
| ---------------------------------- | --------------------------------- | ------------------------------------------------------------ |
| name                               | string                            | Имя аккаунта (непустая строка)                               |
| parent_name                        | string                            | Имя родительского аккаунта                                   |
| resource_limits                    | ClusterResources                  | Лимиты ресурсов для аккаунта                                 |
| allow_children_limit_overcommit    | bool                              | Может ли сумма лимитов подаккаунтов превышать лимит данного аккаунта (см. выше) |
| resource_usage                     | ClusterResources                  | Занятые непосредственно данным аккаунтом ресурсы (включая незакоммиченные транзакции) |
| committed_resource_usage           | ClusterResources                  | Занятые непосредственно данным аккаунтом ресурсы (без учёта активных транзакций) |
| recursive_resource_usage           | ClusterResources                  | Занятые данным поддеревом аккаунтов ресурсы (включая незакоммиченные транзакции) |
| recursive_committed_resource_usage | ClusterResources                  | Занятые данным поддеревом аккаунтов ресурсы (без учёта активных транзакций) |
| violated_resource_limits           | ViolatedClusterResources          | Флаги превышения ресурсов для аккаунта                       |
| recursive_violated_resource_limits | RecursiveViolatedClusterResources | Для каждого типа ресурса — количество аккаунтов, превысивших лимит, в данном поддереве |

`ClusterResources` представляет собой следующую структуру:

### Структура ClusterResources

| **Атрибут**           | **Тип**         | **Описание**                                            |
| --------------------- | --------------- | ------------------------------------------------------- |
| disk_space            | integer         | Суммарное дисковое пространство в байтах                |
| disk_space_per_medium | string->integer | Дисковое пространство в байтах (для каждого медиума)    |
| node_count            | integer         | Количество узлов Кипариса                               |
| master_memory         | integer         | Объем потребленной оперативной памяти мастер-серверов   |
| chunk_count           | integer         | Количество чанков                                       |
| tablet_count          | integer         | Количество таблетов                                     |
| tablet_static_memory  | integer         | Объём памяти для динамических таблиц, поднятых в память |

Поле `disk_space` доступно только для чтения. Для изменения лимитов следует следует изменять значения словаря `disk_space_per_medium`.

`ViolatedClusterResources` представляет собой следующую структуру:

### Структура ViolatedClusterResources

| **Атрибут**           | **Тип**         | **Описание**                                                 |
| --------------------- | --------------- | ------------------------------------------------------------ |
| disk_space            | boolean         | Превышен ли лимит на дисковое пространство хотя бы по одному медиуму |
| disk_space_per_medium | string->boolean | Превышен ли лимит на дисковое пространство (по каждому медиуму) |
| node_count            | boolean         | Превышен ли лимит на количество узлов Кипариса               |
| chunk_count           | boolean         | Превышен ли лимит на количество чанков                       |
| tablet_count          | boolean         | Превышен ли лимит на количество таблетов                     |
| tablet_static_memory  | boolean         | Превышено ли ограничение на объём памяти, занимаемой динамическими таблицами, поднятыми в память |

`RecursiveViolatedClusterResources` представляет собой следующую структуру:

### Структура RecursiveViolatedClusterResources

| **Атрибут**           | **Тип**         | **Описание**                                                 |
| --------------------- | --------------- | ------------------------------------------------------------ |
| disk_space            | integer         | Количество аккаунтов в поддереве, превысивших лимит на дисковое пространство хотя бы по одному медиуму |
| disk_space_per_medium | string->integer | Количество аккаунтов в поддереве, превысивших лимит на дисковое пространство (по каждому медиуму) |
| node_count            | integer         | Количество аккаунтов в поддереве, превысивших лимит на количество узлов Кипариса |
| chunk_count           | integer         | Количество аккаунтов в поддереве, превысивших лимит на количество чанков |
| tablet_count          | integer         | Количество аккаунтов в поддереве, превысивших лимит на количество таблетов |
| tablet_static_memory  | integer         | Количество аккаунтов в поддереве, превысивших ограничение на объём памяти, занимаемую динамическими таблицами, поднятыми в память |
