# Прокси

В данном разделе содержится информация о различных интерфейсах, которые позволяют работать с системой {{product-name}}: [HTTP](#http_proxy) и [RPC](#rpc_proxy) прокси.

## HTTP-прокси { #http_proxy }

**HTTP-прокси** — это универсальный языко-независимый интерфейс для работы с системой {{product-name}}.


{% note warning "Предупреждение" %}

HTTP API является весьма низкоуровневым и плохо подходит для написания простого и надёжного прикладного кода. В частности, при его использовании необходимо правильно организовать логирование запросов и разметку их correlation ids, балансировать нагрузку на прокси, брать дополнительные явные блокировки на таблицы, обрабатывать ошибки и в ряде случаев повторять действия и т. д.

Мы настоятельно рекомендуем использовать поддерживаемые нами SDK для вашего языка, в которых эти задачи уже решены, например для [Python](../../../api/python/start.md) или [С++](../../../api/cpp/description.md).

Для работы в консоли также следует использовать [CLI](../../../api/cli/cli.md), а не задавать прямые HTTP-запросы.

{% endnote %}

Каждой HTTP-прокси приписана та или иная роль, которая указывает, какого рода нагрузку будет обслуживать прокси.
- Запросы к дереву метаинформации — например, `get`, `set`, `create` — считаются сравнительно лёгкими и обрабатываются контрольными (лёгкими) HTTP-прокси, роль `control`.
- Запросы на чтение или запись — например, `read-table`, `write-table` — потенциально могут передавать существенно больший объём данных и сильнее нагружать сеть узлов кластера {{product-name}}. Поэтому такие запросы обрабатываются так называемыми тяжёлыми прокси (data-прокси), роль `data`.
- Отдельные процессы могут использовать свои роли, чтобы их нагрузка не мешала другим процессам.

Клиентские SDK обычно скрывают работу с ролями. Единственное, что может потребоваться, это указать роль в конфигурации клиента, если для тяжёлых запросов требуется использование нестандартной роли. Но при непосредственной работе с HTTP лёгкие и тяжёлые запросы должны отправляться на разные хосты.  {% if audience == "internal" %} Например, чтобы создать таблицу на кластере `{{proxy-pages.common.cluster-name}}`, запрос следует отправить на хост `{{proxy-pages.common.light-proxy}}`, а чтобы записать данные в таблицу — на хост `{{proxy-pages.common.heavy-proxy}}`.{% endif %} Если отправить тяжёлый запрос через лёгкий HTTP-прокси, сервер вернёт ошибку. Подробнее читайте в разделе [Список тяжёлых прокси](http-reference.md#hosts).

{% if audience == "internal" %}
{% note warning "Внимание" %}

Если ваши процессы активно используют http-прокси, например, регулярно читают сотни гигабайт данных в несколько потоков, вам следует использовать выделенную роль.  Если этого не сделать, то перегрузка общих проксей может сказаться на стабильности работы всего кластера.

Существует роль `ml`, которая широко используется в процессах машинного обучения.

Завести новую роль для своей команды можно через тикет на [YTADMINREQ](https://st.yandex-team.ru/YTADMINREQ), в рамках заведения потребуется оценить планируемую нагрузку и предоставить ресурсы (например из вычислительной квоты YT).

{% endnote %}
{% endif %}

Примеры взаимодействия с {{product-name}} через HTTP-интерфейс представлены в разделе [HTTP-прокси](../../../user-guide/proxy/http.md).

Справочную информацию по HTTP-прокси можно посмотреть в разделе [Справочник по HTTP-прокси](../../../user-guide/proxy/http-reference.md).

## RPC-прокси { #rpc_proxy }

**RPC-прокси** — это специальный интерфейс для взаимодействия с {{product-name}}, через протокол RPC. Обращение к RPC Proxy происходит по протоколу TCP, порт 9013. Основные отличия RPC-прокси от HTTP-прокси:

- более высокая скорость обработки запросов, что достигается за счет следующих особенностей:
  - работа с RPC-прокси происходит по специальному внутреннему протоколу, который лучше подходит для работы с большим числом одновременных запросов;
  - в RPC-прокси запрос передаётся в нативном формате {{product-name}}, поэтому не требует дополнительного времени и ресурсов на конвертацию;
  - возможность сохранить совместимость на уровне пользовательского кода при изменениях в протоколе взаимодействия компонентов внутри {{product-name}} кластера.

Как и HTTP-прокси, все RPC-прокси разделены на роли. Роль указывается в конфигурации при подключении к кластеру и позволяет разделять пользовательскую нагрузку. Роль по умолчанию `default`.

{% if audience == "internal" %}

{% note warning "Внимание" %}

Процессы, использующие общую роль `default`, могут сталкиваться с ошибками, если другие пользователи перегрузят эти общие машины. Поэтому общую роль `default` нельзя использовать для production процессов. Подробнее о заведении своей роли можно прочитать в [памятке администратора бандла](../../../user-guide/dynamic-tables/bundleadmin.md#allokaciya-tabletnyh-nod-i-proksi).

{% endnote %}

{% endif %}

Поддерживаются следующие языки программирования:

- [C++](../../../user-guide/proxy/rpc.md#c_plus_plus)
- [Java](../../../user-guide/proxy/rpc.md#java)
- [Python](../../../user-guide/proxy/rpc.md#python)

По каждому языку программирования доступны примеры.
