## Roren

Roren – это библиотека для описания вычислительных пайплайнов. Она вдохновлялась [Apache Beam](https://beam.apache.org/), [FlumeJava](https://dl.acm.org/doi/abs/10.1145/1809028.1806638).

Вычисления, описанные с помощью Roren, могут запускаться поверх YT, BigRT или локально. На этой странице описан Roren поверх YT и локальный.

### Основные возможности и преимущества Roren

Roren позволяет описывать и запускать пайплайны операций на YT. Пайплайн это ациклический граф. Т.е. какие-то операции могут быть независимыми, какие-то могут зависеть от других операций. Циклы в зависимостях не допускаются.

Roren избавляет от необходимости управлять временными таблицами.

Перед запуском графа отрабатывает оптимизатор, который пытается уменьшить число выполняемых операций, схлопывая, например, подряд идущие map'ы в одну операцию.

Roren позволяет в каких-то случаях передавать пользовательский код в виде лямбд, что позволяет компактнее описывать вычисления.

Есть возможность запускать пайплайн локально в режиме unittest'ов, без поднятия локального YT.

### Статус

Основные возможности библиотеки реализованы, поверх неё работают несколько production процессов. Но новые пользователи определенно наткнутся на то, что каких-то возможностей не хватает, а какие-то места сыроваты.

{% if audience == 'internal' %}
Приходите на рассылку `yt@` с фич-реквестами и баг-репортами.
{% endif %}

#### Пример

```(cpp)
struct TUserLoginInfo
{
    TString Name;
    TString Login;

    Y_SAVELOAD_DEFINE(Name, Login);
};

struct TUserEmailInfo
{
    TString Name;
    TString Email;

    Y_SAVELOAD_DEFINE(Name, Email);
};

int main() {
    NYT::Initialize();

    auto pipeline = MakeYtPipeline("freud", "//tmp");

    pipeline
        | YtRead<TNode>("//home/tutorial/staff_unsorted")
        | ParDo([] (const TNode& node) -> TUserLoginInfo {
            TUserLoginInfo info;
            info.Name = node["name"].AsString();
            info.Login = node["login"].AsString();
            return info;
        })
        | ParDo([] (const TUserLoginInfo& info) {
            TUserEmailInfo result;
            result.Name = info.Name;
            result.Email = info.Login + "@yandex-team.ru";
            return result;
        })
        | ParDo([] (const TUserEmailInfo& info) {
            TNode result;
            result["name"] = info.Name;
            result["email"] = info.Email;
            return result;
        })
        | YtWrite(
            "//tmp/output",
            TTableSchema()
                .AddColumn("name", NTi::String())
                .AddColumn("email", NTi::String())
        );

    pipeline.Run();
    return 0;
}
```

### Работа с библиотекой

Roren работает поверх плюсовой библиотеки `yt/cpp/mapreduce` и поэтому для запуска операций первой строчкой `main` должна быть вызвана функция `NYT::Initialize()`.

После этого необходимо создать объект `NRoren::TPipeline`, который хранит описание графа вычислений c помощью функции `NRoren::MakeYtPipeline`. Функция принимает два аргумента:
  - кластер, на котором запускается операция
  - и директория для временных данных. Для экспериментов и тестирования здесь можно использовать `//tmp`, для продакшн процессов для большей надёжности и лучшей изоляции [лучше использовать директорию внутри проектной квоты](https://yt.yandex-team.ru/docs/user-guide/best-practice/howtorunproduction#zakazhite-neobhodimye-resursy).

Дальше можно приступать к созаднию пайплайна. Первым делом обычно указываются входные данные с помощью читающих преобразований-transform'ов.
```
TPCollection<TNode> input = pipeline | YtRead<TNode>("//home/tutorial/staff_unsorted")
```

Для чтения из YT есть преобразование `YtRead<T>`, в качестве шаблонного параметра можно указывать либо класс `NYT::TNode`, либо протобуф сообщение. Применение читающего преобразования к pipeline'у вернёт объект `TPCollection<TNode>`, который выражает большую иммутабельную коллекцию данных определённого типа. Из этой коллекции нельзя прочитать элементы или что-то туда записать, нельзя узнать размер этой коллекции и т.д. и т.п. Единственное, что можно сделать, это применить к коллекции преобразование (transform), в результате которого могут получиться новые объекты `TPCollection<>`. В контексте YT можно думать про `TPCollection<T>` как про таблицу, в строках которой хранятся объекты типа `T`. Сама таблица виртуальная, т.е. не обязана материализоваться как реальная таблица YT.

Примером такого преобразования является ParDo(), аналог стадии Map в модели MapReduce (более подробное описание будет ниже). Преобразования применяются через оператор `|`.

В конце-концов, мы применяем к каким-то объектам `TPCollection<>` пишущее преобразование `YtWrite`, которое означает, объекты этого `TPCollection<>` будут записаны в YT таблицу.

К одному объекту `TPCollection<>` можно применять несколько различных преобразований, в том числе можно применить `YtWrite`, и `ParDo`. Изменения применятся независимо.

В момент применения преобразований никаких вычислений не запускается, только сохраняется структура вычислительного графа. Сами вычисления запускаются в момент вызова `pipeline.Run()`.

### Оптимизация графа

Перед запуском вычислений на YT, применяется оптимизатор, который упрощает структуру графа, склеивая, например последовательные Map операции в одну.

### Описание преобразований

#### Ввод/вывод

`YtRead<T>(const TRichYPath& path)` преобразование, читающее таблицу в YT, в качестве шаблонного параметра можно указывать либо класс `NYT::TNode`, либо protobuf сообщение.

`YtWrite(const TRichYPath& path, const TTableSchema& schema)` преобразование, пишущее результаты в YT. Вторым аргументом следует указывать схему таблицы. Может быть применено либо к объектам `NYT::TNode`, либо к протобуф сообщениям.

#### ParDo

`ParDo` преобразование, позволяющее применить пользовательскую функцию ко всем элементам `TPCollection<?>`. Является аналогом операции Map в модели MapReduce.

Создать преобразование `ParDo` можно несколькими способами.

Если пользовательский код на каждый входной элемент порождает один выходной, то можно передать в ParDo указатель на обычную функцию, принимающую константную ссылку на входной тип и возвращающую выходной тип. Можно использовать lambda-функцию (c пустым capture list) с такой же сигнатурой.
```(cpp)
TResult ParDoFunc(const TInput& in);
...

TPCollection<TInput> pCollection = ...;

pCollection | ParDo(ParDoFunc) ...
pCollection | ParDo([] (const TInput& in) -> TResult {
    ...
}) ...

...
```

Если возможна ситуация, что пользовательская функция на один входной тип порождает несколько выходных или не порождает ни одного,
можно использовать другую сигнатуру для функции, принимающую вторым параметром ссылку на тип `TOutput<TResult>`. В коде такой функции, можно использовать метод `TOutput<TResult>::Add(const TResult&)`, чтобы добавить результат в вывод.

```
void ParDoFunc(const TInput& in, TOutput<TResult>& out);

TPCollection<TInput> pCollection = ...;

pCollection | ParDo(ParDoFunc) ...;
pCollection | ParDo([] (const TInput& in, TOutput<TResult>& out) {
    ...
    out.Add(in);
}) ...;
```

Наконец, последний способ это переопредеить интерфейс `IDoFn`, это способ, дающий больше всего контроля, но он так же является и наиболее многословным способом описать пользовательское преобразование.

Используя его, можно
 - передать какое-то состояние в пользовательский код,
 - выполнить какую-то инициализацию или финализацию на рабочих машинах,
 - накапливать какое-то состояние во время обработки.

Единственный обязательный к реализации метод интерфейса это `void Do(const TInput& in, TOutput<TResult>& out)`.

```
void TMyDoFn : public IDoFn<TInput, TResult>
{
    void Do(const TInput& in, TOutput<TResult>& out) override;
};

TPCollection<TInput> pCollection = ...;

pCollection | ParDo(MakeIntrusive<TMyDoFn>())
```

### GroupByKey
(раздел дописывается)

### CoGroupByKey
(раздел дописывается)

### Combine
(раздел дописывается)

### Flatten
(раздел дописывается)

### Локальный запуск
(раздел дописывается)

### Примеры

В папке [yt/cpp/roren/examples](https://a.yandex-team.ru/arcadia/yt/cpp/roren/examples) лежит набор примеров, которые можно собрать и запустить.
