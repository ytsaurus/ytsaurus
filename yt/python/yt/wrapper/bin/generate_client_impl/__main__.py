import argparse
import inspect
import os
import re
import typing

from collections import defaultdict
from copy import deepcopy
from itertools import chain


def _fix_indentation(text, width):
    indentation = " " * width
    lines = []
    for line in text.split("\n"):
        if all(map(str.isspace, line)):
            line = ""
        else:
            line = indentation + line.lstrip()
        lines.append(line.replace("\\", "\\\\"))
    return "\n".join(lines)


def join_args(args_tokens, indentation, line_limit=None, types=None):
    style_line_limit = 120
    if not line_limit:
        line_limit = 100 if not types else 1
    lines = []
    current_tokens = []
    current_len = len(indentation) + 1
    for token in args_tokens:
        if types and token in types:
            token += ": " + types[token]
        current_tokens.append(token)
        current_len += 3 + len(token)
        if current_len > line_limit:
            lines.append(", ".join(current_tokens))
            current_len = len(indentation)
            current_tokens = []

    if current_tokens:
        lines.append(", ".join(current_tokens))

    lines_sep = list(map(lambda l: ",\n" + indentation if len(l) <= style_line_limit else ",  # noqa\n" + indentation, lines))
    lines_sep[-1] = ""

    return "".join(chain(*zip(lines, lines_sep)))


def render_client_header(modules_registry: typing.Dict[str, typing.Set[str]]) -> str:
    modules_formatted = []
    for module_name in sorted(modules_registry.keys()):
        if module_name:
            module_objects = sorted(modules_registry[module_name], key=lambda module: module if isinstance(module, str) else "")
            if module_name == "builtins":
                continue
            module_name = module_name.replace("yt.wrapper.", ".")
            # modules_formatted.append(f"from {module_name} import {', '.join(module_objects)}")
            modules_formatted.append(f"from {module_name} import {', '.join(map(lambda module: f'{module[0]} as {module[1]}' if isinstance(module, tuple) else module,  module_objects))}")
        else:
            for module in sorted(modules_registry[module_name]):
                modules_formatted.append(f"import {module}")

    return '''# This file is auto-generated by yt/python/yt/wrapper/bin/generate_client_impl, please do not edit it manually!

from .cypress_commands import _KwargSentinelClass, _MapOrderSorted
from .client_helpers import initialize_client
from .client_state import ClientState
from .default_config import DefaultConfigType
from .mappings import VerifiedDict
from . import client_api

from typing import ForwardRef

{modules_formatted}


class YtClient(ClientState):
    """Implements YT client."""

    def __init__(self, proxy: str = None, token: str = None, config: Union[DefaultConfigType, VerifiedDict, Dict[str, Any]] = None):
        super(YtClient, self).__init__()
        initialize_client(self, proxy, token, config)
'''.format(
        modules_formatted="\n".join(modules_formatted),
    )


def render_client_method(name, doc, args=None, kwargs=None, kwargs_passed=None, return_type=None, tab=None, args_types=None) -> str:
    if args and kwargs:
        return '''
    def {name}(
        self,
        {def_args},
        {def_kwargs}
    ){def_ret_type}:
        \"\"\"
{doc}
        \"\"\"
        return client_api.{name}(
            {call_args},
            client=self,
            {call_kwargs}
        )
'''.format(
            name=name,
            def_args=join_args(args, indentation=tab * 2, types=args_types),
            def_kwargs=join_args(kwargs, indentation=tab * 2, types=args_types),
            def_ret_type=f" -> {return_type}" if return_type else "",
            call_args=join_args(args, indentation=tab * 3, types=None),
            call_kwargs=join_args(kwargs_passed, indentation=tab * 3),
            doc=doc.rstrip(),
        )

    elif args:
        return '''
    def {name}(
        self,
        {def_args}
    ){def_ret_type}:
        \"\"\"
{doc}
        \"\"\"
        return client_api.{name}(
            {args},
            client=self
        )
'''.format(
            name=name,
            args=join_args(args, indentation=tab * 3),
            def_args=join_args(args, indentation=tab * 2, types=args_types),
            def_ret_type=f" -> {return_type}" if return_type else "",
            doc=doc.rstrip(),
        )

    elif kwargs:
        return '''
    def {name}(
        self,
        {kwargs}
    ){def_ret_type}:
        \"\"\"
{doc}
        \"\"\"
        return client_api.{name}(
            client=self,
            {kwargs_passed}
        )
'''.format(
            name=name,
            kwargs=join_args(kwargs, indentation=tab * 2),
            kwargs_passed=join_args(kwargs_passed, indentation=tab * 3),
            def_ret_type=f" -> {return_type}" if return_type else "",
            doc=doc.rstrip(),
        )

    else:
        return '''
    def {name}(self){def_ret_type}:
        \"\"\"
{doc}
        \"\"\"
        return client_api.{name}(client=self)
'''.format(
            name=name,
            def_ret_type=f" -> {return_type}" if return_type else "",
            doc=doc.rstrip(),
        )


def get_argument_type(arg_type: typing.Type, modules_registry: typing.Dict[str, typing.Set[str]]) -> str:
    if not arg_type:
        return ""
    elif type(arg_type) in (type, typing._TypedDictMeta):
        # Process simple types
        # `int`, `bool` -> "int", "bool"
        # `yt.wrapper.query_commands.Query` -> "Query"
        # `yt.wrapper.spec_builders.SpecReduceType` -> "SpecReduceType"
        if arg_type.__module__ == "builtins" and arg_type.__name__ in ("list", "dict"):
            # patch `List`, `Dict`
            modules_registry[arg_type.__module__].add("typing")
            return arg_type.__name__.capitalize()
        else:
            modules_registry[arg_type.__module__].add(arg_type.__name__)
            return arg_type.__name__
    elif type(arg_type) is str:
        # Process type as string
        # `"TypeAsLiteral"`
        return f"\"{arg_type}\""
    else:
        # Process "typing" (typing._SpecialGenericAlias, typing._BaseGenericAlias, typing._SpecialForm...)
        # `typing.Union[list[str], yt.wrapper.ypath.YPath, NoneType]` -> "typing.Union[List[str], YPath, None]"
        # `typing.Literal['A']` -> "typing.Literal["A"]"
        tmp = str(arg_type)
        # patch None
        tmp = tmp.replace("NoneType", "None")
        # patch List
        tmp = re.sub(
            r"\b(list|dict)\b",
            lambda pattern:
                pattern.group(1).capitalize(),
            tmp,
        )

        # process modules
        def _replace_handler(pattern):
            module_name, module_object = pattern.group(1), pattern.group(3)
            if module_name.endswith("."):
                module_name = module_name[:-1]
            if module_object in ("TablePath",):
                modules_registry[module_name].add((module_object, module_object + "_"))
                return module_object + "_"
            else:
                modules_registry[module_name].add(module_object)
                return module_object

        return re.sub(
            r"(([a-zA-Z_]+\.)+)([a-zA-Z_]+)",
            _replace_handler,
            tmp,
        ).replace("'", "\"")


def main():
    os.environ["GENERATE_CLIENT"] = "YES"

    from yt.wrapper.cypress_commands import _KwargSentinelClass, _MapOrderSorted
    from yt.wrapper import client_api

    def dump_value(value):
        if isinstance(value, str):
            return f"\"{value}\""
        elif isinstance(value, _KwargSentinelClass):
            return "_KwargSentinelClass()"
        elif isinstance(value, _MapOrderSorted):
            return "_MapOrderSorted()"
        else:
            return str(value)

    parser = argparse.ArgumentParser(description="Generate client_impl")
    parser.add_argument("output")
    cli_args = parser.parse_args()

    output_methods = []

    modules_registry = defaultdict(set)
    for name in sorted(client_api.all_names):
        func = getattr(client_api, name)
        if not func.__doc__:
            raise RuntimeError(f"Public method \"{name}\" should described with docstring")
        doc = _fix_indentation(func.__doc__, 8)

        is_class = False
        if inspect.isclass(func):
            func = func.__dict__["__init__"]
            is_class = True

        arg_spec = inspect.getfullargspec(func)
        var_args = arg_spec.varargs
        var_kwargs = arg_spec.varkw
        defaults = arg_spec.defaults

        return_type = None
        args_types = {}

        for arg_name, arg_type in arg_spec.annotations.items():
            if arg_name == "return":
                return_type = get_argument_type(arg_type, modules_registry)
            else:
                args_types[arg_name] = get_argument_type(arg_type, modules_registry)

        if defaults:
            defaults = list(defaults)
        else:
            defaults = []

        all_args = deepcopy(arg_spec.args)
        if all_args and all_args[-1] == "client":
            all_args.pop()
            if defaults:
                defaults.pop()

        if defaults:
            args = all_args[:-len(defaults)]
            kwargs_names = all_args[-len(defaults):]
        else:
            args = all_args
            kwargs_names = []

        if is_class:
            args.pop(0)

        if var_args:
            args.append("*" + var_args)

        kwargs_typed = [f"{key}: {args_types[key]} = {dump_value(value)}" if key in args_types else f"{key}={dump_value(value)}" for key, value in zip(kwargs_names, defaults)]
        kwargs_passed = ["{}={}".format(key, key) for key in kwargs_names]
        if var_kwargs:
            kwargs_typed.append("**" + var_kwargs)
            kwargs_passed.append("**" + var_kwargs)

        tab = " " * 4

        output_methods.append(
            render_client_method(
                name=name,
                doc=doc,
                args=args,
                kwargs=kwargs_typed,
                kwargs_passed=kwargs_passed,
                return_type=return_type,
                tab=tab,
                args_types=args_types,
            )
        )

    with open(cli_args.output, "w") as fout:
        fout.write(render_client_header(modules_registry=modules_registry))
        for method in output_methods:
            fout.write(method)


if __name__ == "__main__":
    main()
