package NYT.NChunkClient.NProto;

import "yt/core/misc/proto/guid.proto";
import "yt/ytlib/chunk_client/read_limit.proto";
import "yt/ytlib/chunk_client/chunk_meta.proto";

////////////////////////////////////////////////////////////////////////////////

// Describes a portion of table chunk.
message TChunkSpec
{
    required NYT.NProto.TGuid chunk_id = 1;

    // Lower boundary, inclusive.
    optional TReadLimit lower_limit = 2;

    // Upper boundary, exclusive.
    optional TReadLimit upper_limit = 3;

    // Initial seed addresses. The reader may ask the master for additional ones.
    repeated fixed32 replicas = 4;

    // Deprecated = 5;
    // Deprecated = 6;

    optional int32 table_index = 7 [default = 0];

    // Deprecated = 8;

    optional int32 erasure_codec = 9 [default = 0];

    optional int64 table_row_index = 10 [default = 0];

    // Chunk meta can be omitted for intermediate chunks.
    optional TChunkMeta chunk_meta = 11;

    // Only makes sense as a part of data split.
    optional uint64 timestamp = 12;

    // Mapping to ranges.
    optional int32 range_index = 13;

    // Overrides the corresponding values in TMiscExt.
    optional int64 row_count_override = 14;
    optional int64 data_weight_override = 15;

    // Tag of the input data slice this chunk spec belongs to (if any).
    // It helps us restore the correspondence between data slices that
    // form the job input and the unread data slices returned as a
    // job interruption result.
    optional int64 data_slice_tag = 16;

    // Global chunk index for the operation. Helps to identify chunk_spec
    // if fetch returns the same chunk with different limits
    // (e.g. the chunk is shared between dynamic table tablets).
    optional int64 chunk_index = 17;
}

////////////////////////////////////////////////////////////////////////////////
