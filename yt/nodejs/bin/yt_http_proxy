#!/usr/bin/node --expose-gc

// Standard modules.
var cluster = require("cluster");
var fs = require("fs");
var net = require("net");
var http = require("http");

// NPM modules.
var optimist = require("optimist");
var uid_number = require("uid-number");

var Q = require("bluebird");

var v8_heapdump = require("heapdump");

// Program arguments.
var opts = optimist
    .usage("Provide HTTP API for YT.\nUsage: $0")

    .alias("c", "config")
    .describe("c", "Specify configuration file")

    .alias("p", "port")
    .describe("p", "Specify port to listen")

    .alias("a", "address")
    .describe("a", "Specify address to listen")

    .alias("n", "number-of-workers")
    .describe("n", "Specify number of worker processes")

    .alias("v", "version")
    .boolean("v")
    .describe("v", "Show version and exit")

    .alias("h", "help")
    .boolean("h")
    .describe("h", "Show help message and exit")
    ;

////////////////////////////////////////////////////////////////////////////////

var config;
var version;

try {
    version = JSON.parse(fs.readFileSync(__dirname + "/../package.json"));
} catch (ex) {
    version = { version : "(arcadia or local build)", dependencies : {} };
}

if (opts.argv.v) {
    console.error("*** YT HTTP Proxy ***");
    console.error("Version %s", version.version);
    for (var p in version.dependencies) {
        if (version.dependencies.hasOwnProperty(p)) {
            console.error("Depends on %s (%s)", p, version.dependencies[p]);
        }
    }
    process.exit(0);
}

if (opts.argv.h) {
    opts.showHelp();
    process.exit(0);
}

////////////////////////////////////////////////////////////////////////////////

function merge(lhs, rhs) {
    for (var p in rhs) {
        if (rhs.hasOwnProperty(p)) {
            try {
                if (typeof(rhs[p]) !== "undefined" && rhs[p] !== null) {
                    if (rhs[p].constructor === Object) {
                        lhs[p] = merge(lhs[p], rhs[p]);
                    } else {
                        lhs[p] = rhs[p];
                    }
                }
            } catch (err) {
                lhs[p] = rhs[p];
            }
        }
    }
    return lhs;
}

config = {
    port              : 80,
    address           : "::",
    ssl_port          : null,
    ssl_address       : null,
    ssl_key           : null,
    ssl_passphrase    : null,
    ssl_certificate   : null,
    ssl_ca            : null,
    ssl_ciphers       : "kEECDH+AES128:kEECDH:kEDH:-3DES:kRSA+AES128:kEDH+3DES:DES-CBC3-SHA:!RC4:!aNULL:!eNULL:!MD5:!EXPORT:!LOW:!SEED:!CAMELLIA:!IDEA:!PSK:!SRP:!SSLv2",
    ssl_reject_unauthorized : false,
    monitoring_port   : null,
    neighbours        : [ "::1" ],
    memory_limit      : 32 * 1024 * 1024,
    rss_limit         : 256 * 1024 * 1024,
    number_of_workers : 4,
    thread_limit      : 32,
    spare_threads     : 4,
    concurrency_limit : null,
    show_ports        : false,
    rewrite_yandex_team_domain : false,

    bind_retry_count  : 1,
    bind_retry_backoff: 1000,

    proxy             : {
        logging: { rules: [], writers: {} },
        tracing: { },
    },

    services: {
        oauth: {
            host: "oauth.yandex-team.ru",
            port: 80,
            nodelay: true,
            timeout: 3000
        },
        blackbox: {
            host: "blackbox.yandex-team.ru",
            port: 80,
            nodelay: true,
            timeout: 3000,
            retries: 5
        },
    },

    api: {
        rate_check_cache_size: 5000,
        rate_check_cache_age: 60 * 1000,
    },

    authentication: {
        enable: true,
        cache_max_size: 5000,
        cache_max_token_age: 60 * 1000,
        cache_max_exist_age: 86400 * 1000,
        optimism_timeout: 5000,
        create_users_on_demand: true,
        default_oauth_application_key: "",
        guest_login: "guest",
        guest_realm: "guest",
        cypress: {
            enable: true,
            where: "//sys/tokens",
        },
        blackbox: {
            enable: true,
            grant: "yt:api",
        },
        oauth: [
        ],
    },

    coordination: {
        enable: true,
        announce: true,
        heartbeat_interval: 15000,
        heartbeat_drift: 1500,
        fitness_la_coefficient: 1,
        fitness_net_coefficient: 50,
        fitness_phi_coefficient: 6,
        fitness_rnd_coefficient: 1,
        fitness_dmp_coefficient: 0.3,
        net_window_size: 5,
        afd_window_size: 24,
        afd_phi_threshold: 4,
        death_age: 300000,
    },

    min_python_wrapper_version: {
        enable: true,
        major: 0,
        minor: 5,
        patch: 0,
    },

    banned_python_wrapper_versions: [
        ["0.5.0", "0.5.100"],
        ["0.6.0", "0.6.9"],
        ["0.6.14", "0.6.15"]
    ],

    redirect: [],
    static: [],

    hosts: {
        fb: "HOST-fb.DOMAIN",
        fb867: "HOST-fb867.DOMAIN"
    }
};

config = merge(config, (opts.argv.c && JSON.parse(fs.readFileSync(opts.argv.c, "utf8"))) || {});
config = merge(config, {
    port              : opts.argv.p && parseInt(opts.argv.p),
    address           : opts.argv.a,
    number_of_workers : opts.argv.n && parseInt(opts.argv.n),
});

////////////////////////////////////////////////////////////////////////////////

function ensureFileExistsAndOwned(path, user, group) {
    return Q
        .promisify(fs.exists)(path)
        .catch(function(exists) {
            return exists || Q.promisify(fs.writeFile)(path, "").then(Q
                    .promisify(uid_number)(user || process.getuid(), group || process.getgid)
                    .spread(Q.promisify(fs.chown).bind(undefined, path))
                );
        });
}

function provideLoggerStream() {
    if (config.logging) {
        return ensureFileExistsAndOwned(config.logging.filename, config.user, config.group).then(function() {
            // console.error("Setting up logging to file '%s'", config.logging.filename);
            return {type: "file", path: config.logging.filename, level: "debug"};
        });
    } else {
        return Q.try(function() {
            // console.error("Setting up logging to console");
            return {type: "stream", stream: process.stderr, level: "debug"};
        });
    }
}

function provideLogger(stream) {
    var bunyan = require(__dirname + "/../lib/bunyan.js");
    return bunyan.createLogger({
        name: "yt",
        streams: [stream],
        hostname: config.fqdn,
        serializers: null,
    });
}

function createLogger() {
    return Q.try(provideLoggerStream).then(provideLogger);
}

function createProfiler() {
    return Q.try(function() {
        return new (require(__dirname + "/../lib/statistics.js").that)(15 * 60 * 1000);
    });
}

function checkConnection(master, attempt) {
    attempt = typeof attempt !== "undefined" ? attempt : 0;

    var fake_server = net.createServer();
    fake_server.listen(config.port, config.address);
    fake_server.on("error", function(err) {
        if (err.code === "EADDRINUSE") {
            attempt++;
            if (attempt == config.bind_retry_count) {
                throw new Error("Failed to bind socket on port " + config.port);
            } else {
                console.log("Failed to bind socket on port %s, starting new attempt", config.port);
                setTimeout(checkConnection, config.bind_retry_backoff, master, attempt);
            }
        }
    });
    fake_server.on("listening", function() {
        fake_server.close(function() {
            master.kickstart();
        });
    });
}

function runProxy(logger, profiler) {
    process.env.YT_PROXY_CONFIGURATION = JSON.stringify(config);
    process.env.YT_PROXY_VERSION = JSON.stringify(version);
    process.env.YT_PROXY_MASTER = process.pid.toString();

    logger.info("Logging started");

    var master = new (require(__dirname + "/../lib/master.js").that)(
        logger, profiler, config, {
            exec : __dirname + "/../lib/worker.js",
            args : []
    });

    checkConnection(master);

    if (config.monitoring_port) {
        var profiler_server = http.createServer(function(req, rsp) {
            if (req.url === "/") {
                rsp.writeHead(200, {"Content-Type": "text/plain"});
                rsp.end(profiler.dump());
            } else if (req.url === "/pbjson") {
                rsp.writeHead(200, {"Content-Type": "application/json"});
                rsp.end(profiler.dumpSolomon());
            } else {
                rsp.writeHead(404);
                rsp.end("Not Found");
            }
        }).listen(config.monitoring_port, config.address);
    }

    var cc1 = new Date(),
        cc2 = new Date(),
        cc3 = new Date();

    process.on("SIGHUP", function() {
        logger.reopenFileStreams();
        logger.info("Logging started");
    });

    process.on("SIGINT", function() {
        cc3 = cc2; cc2 = cc1; cc1 = new Date();
        var n = ((cc1 - cc2) < 1000 ? 1 : 0) +
                ((cc1 - cc3) < 1000 ? 1 : 0);
        switch (n) {
            case 0:
                master.restartWorkers();
                break;
            case 1:
                master.shutdownWorkers();
                break;
            case 2:
                process.exit(0);
                break;
        }
    });

    process.on("SIGUSR1", function() {
        console.error("[" + process.pid + "] Writing V8 heap dump...");
        try {
            v8_heapdump.writeSnapshot();
        } catch (ex) {
            console.error("Caught exception: " + ex.toString());
        }
    });
    process.on("SIGUSR2", master.restartWorkers.bind(master));
}

////////////////////////////////////////////////////////////////////////////////

// Magic line.
Q.all([ createLogger(), createProfiler() ]).spread(runProxy).done();
