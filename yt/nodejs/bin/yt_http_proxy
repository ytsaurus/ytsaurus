#!/usr/bin/env node

// Standard modules.
var cluster = require("cluster");
var fs = require("fs");
var net = require("net");

// NPM modules.
var optimist = require("optimist");
var uid_number = require("uid-number");
var winston = require("winston");

var Q = require("q");

var profiler = require("profiler");
var heapdump = require("heapdump");

// Program arguments.
var opts = optimist
    .usage("Provide HTTP API for YT.\nUsage: $0")

    .alias("c", "config")
    .describe("c", "Specify configuration file")

    .alias("p", "port")
    .describe("p", "Specify port to listen")

    .alias("a", "address")
    .describe("a", "Specify address to listen")

    .alias("n", "number-of-workers")
    .describe("n", "Specify number of worker processes")

    .alias("m", "memory-limit")
    .describe("m", "Specify memory limit (in MB) for data buffer size for each request")

    .alias("t", "thread-limit")
    .describe("t", "Specify thread limit for concurrent off-loop processing")

    .alias("s", "spare-threads")
    .describe("s", "Specify a number of threads reserved for non-heavy tasks")

    .alias("l", "log")
    .describe("l", "Specify log file")

    .alias("u", "user")
    .describe("u", "Specify a user to setuid() to")

    .alias("g", "group")
    .describe("g", "Specify a group to setgid() to")

    .alias("v", "version")
    .boolean("v")
    .describe("v", "Show version and exit")

    .alias("h", "help")
    .boolean("h")
    .describe("h", "Show help message and exit")

    .string("user_interface")
    .describe("user_interface", "Path to the UI")
    .default("user_interface", "/usr/share/yt")

    .boolean("read_only")
    .describe("read_only", "Enable read-only mode")
    .default("read_only", false)

    .boolean("agent")
    .describe("agent", "Enable V8 profiler agent")
    .default("agent", false)
    ;

////////////////////////////////////////////////////////////////////////////////

var agent;
var config;
var version;

try {
    version = JSON.parse(fs.readFileSync(__dirname + "/../package.json"));
} catch (ex) {
    version = { version : "(development)", dependencies : {} };
}

if (opts.argv.v) {
    console.error("*** YT HTTP Proxy ***");
    console.error("Version %s", version.version);
    for (var p in version.dependencies) {
        if (version.dependencies.hasOwnProperty(p)) {
            console.error("Depends on %s (%s)", p, version.dependencies[p]);
        }
    }
    process.exit(0);
}

if (opts.argv.h) {
    opts.showHelp();
    process.exit(0);
}

////////////////////////////////////////////////////////////////////////////////

function merge(lhs, rhs) {
    for (var p in rhs) {
        try {
            if (typeof(rhs[p]) !== "undefined" && rhs[p] !== null) {
                if (rhs[p].constructor === Object) {
                    lhs[p] = merge(lhs[p], rhs[p]);
                } else {
                    lhs[p] = rhs[p];
                }
            }
        } catch (err) {
            lhs[p] = rhs[p];
        }
    }
    return lhs;
}

config = {
    port              : 80,
    address           : "::",
    ssl_port          : null,
    ssl_address       : null,
    ssl_key           : null,
    ssl_passphrase    : null,
    ssl_certificate   : null,
    ssl_ca            : null,
    ssl_ciphers       : "kEECDH+AES128:kEECDH:kEDH:-3DES:kRSA+AES128:kEDH+3DES:DES-CBC3-SHA:!RC4:!aNULL:!eNULL:!MD5:!EXPORT:!LOW:!SEED:!CAMELLIA:!IDEA:!PSK:!SRP:!SSLv2",
    ssl_reject_unauthorized : false,
    neighbours        : [ "::1" ],
    number_of_workers : 4,
    memory_limit      : 32 * 1024 * 1024,
    thread_limit      : 32,
    spare_threads     : 4,
    user_interface    : opts.argv.user_interface,
    read_only         : opts.argv.read_only,
    agent             : opts.argv.agent,
    proxy             : { logging : { rules : [], writers : {} } },
    services : {
        oauth : {
            host: "oauth.yandex-team.ru",
            port: 80,
            nodelay: true,
            timeout: 3000
        },
        blackbox : {
            host: "blackbox.yandex-team.ru",
            port: 80,
            nodelay: true,
            timeout: 3000,
            retries: 5
        },
    },
    api : {
        rate_check_cache_size: 5000,
        rate_check_cache_age: 60 * 1000,
    },
    authentication : {
        enable: true,
        cache_max_size: 5000,
        cache_max_token_age: 60 * 1000,
        cache_max_exist_age: 86400 * 1000,
        create_users_on_demand: true,
        default_oauth_application_key: "kant",
        guest_login: "guest",
        guest_realm: "guest",
        cypress: {
            enable: true,
            where: "//sys/tokens",
        },
        blackbox: {
            enable: true,
            grant: "yt:api",
        },
        oauth: [
            {
                key: "kant",
                client_id: "7dc2b061bd884693b520730cfb61b011",
                client_secret: "c494ca8a946a40f9bbdb36615b14551f"
            },
            {
                key: "ui",
                client_id: "d3aa642b20bf42e6a85cb8b62ddb25ed",
                client_secret: "93008f89679c46b6a79fad9ebd776879"
            },
        ],
    },
    coordination: {
        enable: true,
        announce: true,
        heartbeat_interval: 5000,
        heartbeat_drift: 500,
        fitness_la_coefficient: 1,
        fitness_phi_coefficient: 6,
        fitness_rnd_coefficient: 1,
        fitness_dmp_coefficient: 0.3,
        afd_window_size: 24,
        afd_phi_threshold: 4,
        death_age: 300000,
        failure_threshold: 5,
        failure_timeout: 60000,
    },
    min_python_wrapper_version: {
        enable: true,
        major: 0,
        minor: 5,
        patch: 0,
    },
    redirect: [],
    static: [],
};

/*
var konfig = {
    blackbox: {

        cache_max_size: 5000,
        cache_max_age: 60 * 1000,
    },
    local_tokens: {
    }
};
*/

config = merge(config, (opts.argv.c && JSON.parse(fs.readFileSync(opts.argv.c, "utf8"))) || {});
config = merge(config, {
    port              : opts.argv.p && parseInt(opts.argv.p),
    address           : opts.argv.a,
    number_of_workers : opts.argv.n && parseInt(opts.argv.n),
    memory_limit      : opts.argv.m && parseInt(opts.argv.m) * 1024 * 1024,
    thread_limit      : opts.argv.t && parseInt(opts.argv.t),
    spare_threads     : opts.argv.s && parseInt(opts.argv.s),
    logging           : opts.argv.l && { filename : opts.argv.l, timestamp : false, raw : true },
    user              : opts.argv.u,
    group             : opts.argv.g
});

////////////////////////////////////////////////////////////////////////////////

if (config.agent) {
    agent = require("webkit-devtools-agent");
}

////////////////////////////////////////////////////////////////////////////////

function ensureFileExistsAndOwned(path, user, group) {
    return Q
        .nfcall(fs.exists, fs, path)
        .fail(function(exists) {
            return exists || Q
                .nfcall(fs.writeFile, fs, path, "")
                .then(Q
                    .nfcall(uid_number, undefined, user || process.getuid(), group || process.getgid)
                    .spread(Q.nfbind(fs.chown, path))
                );
        });
};

function provideWinstonTransport() {
    if (config.logging) {
        // XXX(sandello): We are forcing logging to use provided timestamps.
        config.logging.timestamp = false;
        return Q.when(
            ensureFileExistsAndOwned(config.logging.filename, config.user, config.group),
            function() {
                console.error("Setting up logging to file '%s'", config.logging.filename);
                return new winston.transports.File(config.logging);
            });
    } else {
        return Q.fcall(function() {
            console.error("Setting up logging to console");
            return new winston.transports.Console({ timestamp : false, raw : false, colorize : true });
        });
    }
}

function provideWinstonLogger(transport) {
    return new winston.Logger({ transports : [ transport ] });
}

function createLogger() {
    return Q.fcall(provideWinstonTransport).then(provideWinstonLogger);
}

function runProxy(logger) {
    process.env.YT_PROXY_CONFIGURATION = JSON.stringify(config);
    process.env.YT_PROXY_VERSION = JSON.stringify(version);
    process.env.YT_PROXY_MASTER = process.pid.toString();

    var master = new (require(__dirname + "/../lib/master.js").that)(
        logger, config.number_of_workers, {
            exec : __dirname + "/../lib/worker.js",
            args : []
    });

    logger.info("Starting HTTP proxy master", {
        pid: process.pid,
        timestamp: new Date().toISOString()
    });

    var fake_server = net.createServer();
    fake_server.listen(config.port, config.address, function() {
        fake_server.close(function() {
            master.kickstart();
        });
    });

    var cc1 = new Date(),
        cc2 = new Date(),
        cc3 = new Date();

    process.on("SIGINT", function() {
        cc3 = cc2; cc2 = cc1; cc1 = new Date();
        var n = ((cc1 - cc2) < 1000 ? 1 : 0) +
                ((cc1 - cc3) < 1000 ? 1 : 0);
        switch (n) {
            case 0:
                master.restartWorkers();
                break;
            case 1:
                master.shutdownWorkers();
                break;
            case 2:
                process.exit(0);
                break;
        }
    });

    process.on("SIGUSR1", function() {
        "use strict";
        console.error("Writing a heap snapshot (" + process.pid + ")");
        heapdump.writeSnapshot();
    });
    process.on("SIGUSR2", master.restartWorkers.bind(master));

    // process.on("SIGTERM", master.shutdownWorkers.bind(master));
    // process.on("SIGKILL", master.shutdownWorkers.bind(master));
}

////////////////////////////////////////////////////////////////////////////////

// Magic line.
Q.all([ createLogger() ]).spread(runProxy).done();
