package NYP.NClient.NApi.NProto;

import "yt/core/yson/proto/protobuf_interop.proto";

import "yp/client/api/proto/data_model.proto";
import "yp/client/api/proto/autogen.proto";

option python_package = "yp_proto.yp.client.api.proto";

option java_package = "ru.yandex.yp.client.api";
option java_outer_classname = "Object";

////////////////////////////////////////////////////////////////////////////////

// Describes the desired format of TPayload.
enum EPayloadFormat
{
    // Indicates a legacy client that is not aware of formats.
    PF_NONE = 0;
    PF_YSON = 1;
    PF_PROTOBUF = 2;
}

// Represents a polymorphic payload.
message TPayload
{
    oneof value {
        bool null = 1;
        bytes yson = 2 [(NYT.NYson.NProto.yson_string) = true];
        bytes protobuf = 3;
    }
}

////////////////////////////////////////////////////////////////////////////////

message TAttributeSelector
{
    // YPaths of requested attributes.
    repeated string paths = 1;
}

message TAttributeList
{
    // COMPAT(babenko): deprecated; use value_payloads instead.
    // Values are in YSON; nulls are encoded as empty strings.
    // Value order coincides with that of TAttributeSelector.paths.
    repeated bytes values = 1 [(NYT.NYson.NProto.yson_string) = true];

    // Value order coincides with that of TAttributeSelector.paths.
    // Empty if TGetObjectOptions.fetch_values is false.
    repeated TPayload value_payloads = 2;

    // Timestamp order coincides with that of TAttributeSelector.paths.
    // Empty if TGetObjectOptions.fetch_timestamps is false.
    repeated uint64 timestamps = 3;
}

message TObjectFilter
{
    // Textual query string (YP dialect).
    required string query = 1;
}

message TSelectLimit
{
    // Maximum number of results to fetch.
    required int64 value = 1;
}

message TSelectOffset
{
    // Number of leading results to skip.
    required int64 value = 1;
}

message TEvent
{
    // The timestamp of the event.
    required uint64 timestamp = 1;

    // Event type.
    required EEventType event_type = 2;

    // Event attributes (cf. TReqWatchObjects.selector).
    required TAttributeList attributes = 3;
}

message TSetUpdate
{
    // YPath pointing to the attribute to set.
    required string path = 1;

    // COMPAT(babenko): deprecated; use value_payload instead.
    // Attribute value; in YSON.
    optional bytes value = 2 [(NYT.NYson.NProto.yson_string) = true];

    // Attribute value.
    optional TPayload value_payload = 4;

    // If true then missing intermediate
    optional bool recursive = 3;
}

message TRemoveUpdate
{
    // YPath pointing to the attribute to remove.
    required string path = 1;
}

message TAttributeTimestampPrerequisite
{
    // YPath pointing to the attribute to check.
    required string path = 1;

    // For the prerequisite to succeed, the actual timestamp must not exceed this one.
    required uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGenerateTimestamp
{ }

message TRspGenerateTimestamp
{
    // A new (unique) timestamp.
    required uint64 timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqStartTransaction
{ }

message TRspStartTransaction
{
    // Transaction id.
    required string transaction_id = 1;

    // Start timestamp of the transaction.
    required uint64 start_timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqCommitTransaction
{
    // Transaction id.
    required string transaction_id = 1;
}

message TRspCommitTransaction
{
    // Commit timestamp of the transaction.
    required uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqAbortTransaction
{
    // Transaction id.
    required string transaction_id = 1;
}

message TRspAbortTransaction
{ }

////////////////////////////////////////////////////////////////////////////////

message TReqCreateObject
{
    // Transaction id.
    // If missing, just creates the object w/o any transaction.
    optional string transaction_id = 1;

    // Type of the object to create.
    required EObjectType object_type = 2;

    // COMPAT(babenko): deprecated; use attributes_payload instead.
    // Object attributes; in YSON.
    optional bytes attributes = 3 [(NYT.NYson.NProto.yson_string) = true];

    // Object attributes.
    optional TPayload attributes_payload = 4;
}

message TRspCreateObject
{
    // Object id.
    required string object_id = 1;

    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqCreateObjects
{
    // Transaction id.
    // If missing, just creates the objects w/o any transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to create.
        required EObjectType object_type = 1;

        // COMPAT(babenko): deprecated; use attributes_payload instead.
        // Object attributes; in YSON.
        optional bytes attributes = 2 [(NYT.NYson.NProto.yson_string) = true];

        // Object attributes.
        optional TPayload attributes_payload = 3;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;
}

message TRspCreateObjects
{
    message TSubresponse
    {
        // Object id.
        required string object_id = 1;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqRemoveObject
{
    // Transaction id.
    // If missing, just removes the object w/o any transaction.
    optional string transaction_id = 1;

    // Id of the object to remove.
    required string object_id = 2;

    // Type of the object to remove.
    required EObjectType object_type = 3;
}

message TRspRemoveObject
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqRemoveObjects
{
    // Transaction id.
    // If missing, just removes the objects w/o any transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to remove.
        required EObjectType object_type = 1;

        // Id of the object to remove.
        required string object_id = 2;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;
}

message TRspRemoveObjects
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqUpdateObject
{
    // Transaction id.
    // If missing, just updates the object w/o any transaction.
    optional string transaction_id = 1;

    // Id of the object to update.
    required string object_id = 2;

    // Type of the object to update.
    required EObjectType object_type = 5;

    // Describes set-like updates.
    repeated TSetUpdate set_updates = 3;

    // Describes remove-like updates.
    repeated TRemoveUpdate remove_updates = 4;

    // Prerequisities to check.
    repeated TAttributeTimestampPrerequisite attribute_timestamp_prerequisites = 6;
}

message TRspUpdateObject
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqUpdateObjects
{
    // Transaction id.
    // If missing, just updates the objects w/o any transaction.
    optional string transaction_id = 1;

    message TSubrequest
    {
        // Type of the object to update.
        required EObjectType object_type = 1;

        // Id of the object to update.
        required string object_id = 2;

        // Describes set-like updates.
        repeated TSetUpdate set_updates = 3;

        // Describes remove-like updates.
        repeated TRemoveUpdate remove_updates = 4;

         // Prerequisities to check.
         repeated TAttributeTimestampPrerequisite attribute_timestamp_prerequisites = 5;
   }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 2;
}

message TRspUpdateObjects
{
    // Commit timestamp in case the request was issued outside of an explicit transaction.
    optional uint64 commit_timestamp = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TGetObjectOptions
{
    // If false, GetObject(s) fails with an error on nonexistent object(s).
    // If true, silently returns null TAttributeList for nonexistent objects.
    optional bool ignore_nonexistent = 1;

    // If true then TAttributeList.value_payloads are filled.
    optional bool fetch_values = 2 [default = true];

    // If true then TAttributeList.timestamps are filled.
    optional bool fetch_timestamps = 3 [default = false];
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObject
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Id of the object to get.
    required string object_id = 2;

    // Type of the object to get.
    required EObjectType object_type = 4;

    // Describes which attributes are to fetched.
    // TRspGetObject.result.attributes will contain exactly this number of attributes.
    required TAttributeSelector selector = 3;

    // Format to use in response.
    optional EPayloadFormat format = 5;

    // Request options.
    optional TGetObjectOptions options = 6;
}

message TRspGetObject
{
    // The requested attributes.
    optional TAttributeList result = 1;

    // If TReqGetObject.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TRspGetObject.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObjects
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Type of objects to get.
    required EObjectType object_type = 2;

    message TSubrequest
    {
        // Id of the object to get.
        required string object_id = 1;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 3;

    // Describes which attributes to fetch.
    // TRspGetObjects.results.attributes will contain exactly this number of attributes.
    required TAttributeSelector selector = 4;

    // Format to use in response.
    optional EPayloadFormat format = 5;

    // Request options.
    optional TGetObjectOptions options = 6;
}

message TRspGetObjects
{
    message TSubresponse
    {
        // The requested attributes.
        optional TAttributeList result = 1;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqGetObject.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TRspGetObjects.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TSelectObjectsOptions
{
    // If true then TAttributeList.value_payloads are filled.
    optional bool fetch_values = 1 [default = true];

    // If true then TAttributeList.timestamps are filled.
    optional bool fetch_timestamps = 2 [default = false];

    // Number of leading results to skip.
    optional int32 offset = 3;

    // Maximum number of results to fetch.
    optional int32 limit = 4;
}

////////////////////////////////////////////////////////////////////////////////

message TReqSelectObjects
{
    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 1;

    // Type of objects to select.
    required EObjectType object_type = 2;

    // Provides means for filtering certain objects.
    optional TObjectFilter filter = 3;

    // Describes which attributes to fetch.
    // TRspSelectObjects.results.attributes will contain exactly this number of attributes.
    required TAttributeSelector selector = 4;

    // Enables limiting the number of results.
    // COMPAT(babenko): deprecated; use options instead.
    optional TSelectLimit limit = 5;

    // Enables skipping a number of leading results.
    // COMPAT(babenko): deprecated; use options instead.
    optional TSelectOffset offset = 6;

    // Format to use in response.
    optional EPayloadFormat format = 7;

    // Request options.
    optional TSelectObjectsOptions options = 8;
}

message TRspSelectObjects
{
    // The result set: each element of this list corresponds to a single
    // matching object.
    repeated TAttributeList results = 1;

    // If TReqSelectObjects.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqSelectObjects.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqCheckObjectPermissions
{
    message TSubrequest
    {
        // Id of the object to check.
        required string object_id = 1;

        // Type of the object to check.
        required EObjectType object_type = 2;

        // Id of subject accessing the object (either user or group).
        required string subject_id = 3;

        // Permission to check.
        required EAccessControlPermission permission = 4;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;

    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 2;
}

message TRspCheckObjectPermissions
{
    message TSubresponse
    {
        // Was request allowed or declined?
        required EAccessControlAction action = 1;

        // The object whose ACL contains the matching ACE. Can be null.
        optional string object_id = 2;

        // The type of object referred by object_id. Can be null.
        optional EObjectType object_type = 3;

        //! Subject to which the decision applies. Can be null.
        optional string subject_id = 4;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqCheckObjectPermissions.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqCheckObjectPermissions.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetObjectAccessAllowedFor
{
    message TSubrequest
    {
        // Id of the object to check.
        required string object_id = 1;

        // Type of the object to check.
        required EObjectType object_type = 2;

        // Permission to check.
        required EAccessControlPermission permission = 4;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;

    // Provides snapshot isolation.
    // If omitted then reads the latest state.
    optional uint64 timestamp = 2;
}

message TRspGetObjectAccessAllowedFor
{
    message TSubresponse
    {
        // Ids of users that are granted access.
        repeated string user_ids = 1;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;

    // If TReqGetObjectAccessAllowedFor.timestamp is missing, then this contains the actual timestamp
    // used for reading the DB; otherwise this is just the copy of TReqGetObjectAccessAllowedFor.timestamp.
    optional uint64 timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

message TReqGetUserAccessAllowedTo
{
    message TSubrequest
    {
        // Id of the user to check.
        required string user_id = 1;

        // Type of the object to check.
        required EObjectType object_type = 2;

        // Permission to check.
        required EAccessControlPermission permission = 3;

        // Continuation token indicates the next record to be fetched. Opaque for the client.
        optional string continuation_token = 4;

        // Maximum number of results to fetch.
        optional int32 limit = 5;
    }

    // Subrequests to serve.
    repeated TSubrequest subrequests = 1;
}

message TRspGetUserAccessAllowedTo
{
    message TSubresponse
    {
        // Ids of objects to which user is granted permission.
        repeated string object_ids = 1;

        // Continuation token - should be sent in subsequent requests to fetch the next batch
        // of objects. Opaque for the client.
        optional string continuation_token = 2;
    }

    // The i-th subresponse here contains the result for the i-th subrequest.
    repeated TSubresponse subresponses = 1;
}

////////////////////////////////////////////////////////////////////////////////

message TReqWatchObjects
{
    // Only fetches events with timestamp > start_timestamp.
    required uint64 start_timestamp = 1;

    // Type of objects to watch.
    required EObjectType object_type = 2;

    // Maximum number of events to wait for.
    // If omitted then no limit is imposed.
    optional int32 event_count_limit = 3;

    // If some events are already available, WatchObjects call just returns them.
    // Otherwise it waits up to time_limit ms (if given).
    // If no events (matching the filter) occurred then it returns zero events.
    // TRspWatchObjects.end_timestamp is always filled properly to enable another
    // call to WatchObjects with TReqWatchObjects.start_timestamp == TRspWatchObjects.end_timestamp
    // to proceed along the event queue.
    // If omitted then no limit is imposed.
    optional int32 time_limit = 4;

    // Provides means for filtering certain events.
    optional TObjectFilter filter = 5;

    // Describes which attributes are to be fetched.
    // TRspWatchObjects.events.attributes will contain exactly this number of attributes.
    optional TAttributeSelector selector = 6;
}

message TRspWatchObjects
{
    // Events read so far.
    repeated TEvent events = 1;

    // If events is not empty then this is the timestamp of the last one.
    // If no events are returned then this is a properly chosen timestamp (which is typically close to the current one).
    // In the latter case it is guaranteed that no event in (start_timestamp, end_timestamp] range
    // conforms to the filter.
    required uint64 end_timestamp = 2;
}

////////////////////////////////////////////////////////////////////////////////

service ObjectService
{
    // Generates a fresh monotoically increasing timestamp.
    rpc GenerateTimestamp (TReqGenerateTimestamp) returns (TRspGenerateTimestamp);

    // Starts a new transaction.
    // Transaction ids are opaque strings.
    // Transaction changes are transient (until commit); transactions are maintained by individual masters.
    // Clients must be choosing masters in a sticky way; cf. GetMasters.
    rpc StartTransaction (TReqStartTransaction) returns (TRspStartTransaction);

    // Commits an existing transaction.
    rpc CommitTransaction (TReqCommitTransaction) returns (TRspCommitTransaction);

    // Aborts an existing transaction.
    rpc AbortTransaction (TReqAbortTransaction) returns (TRspAbortTransaction);

    // Creates a new object.
    rpc CreateObject (TReqCreateObject) returns (TRspCreateObject);

    // Creates new objects.
    rpc CreateObjects (TReqCreateObjects) returns (TRspCreateObjects);

    // Removes an existing object.
    rpc RemoveObject (TReqRemoveObject) returns (TRspRemoveObject);

    // Removes existing objects.
    rpc RemoveObjects (TReqRemoveObjects) returns (TRspRemoveObjects);

    // Updates an existing object.
    rpc UpdateObject (TReqUpdateObject) returns (TRspUpdateObject);

    // Updates existing objects.
    rpc UpdateObjects (TReqUpdateObjects) returns (TRspUpdateObjects);

    // Fetches object attributes by object id.
    rpc GetObject (TReqGetObject) returns (TRspGetObject);

    // Fetches objects attributes by object ids.
    rpc GetObjects (TReqGetObjects) returns (TRspGetObjects);

    // Executes a query and fetches attributes for relevant objects.
    rpc SelectObjects (TReqSelectObjects) returns (TRspSelectObjects);

    // Runs permission checks for given objects, permissions, and users.
    rpc CheckObjectPermissions (TReqCheckObjectPermissions) returns (TRspCheckObjectPermissions);

    // Given objects and permissions, computes the set of users that are granted the specified permission.
    rpc GetObjectAccessAllowedFor (TReqGetObjectAccessAllowedFor) returns (TRspGetObjectAccessAllowedFor);

    // Computes the set of objects of a given type to which given users are granted given permissions.
    rpc GetUserAccessAllowedTo (TReqGetUserAccessAllowedTo) returns (TRspGetUserAccessAllowedTo);

    // Reads updates from event queue.
    rpc WatchObjects (TReqWatchObjects) returns (TRspWatchObjects);
}

////////////////////////////////////////////////////////////////////////////////
