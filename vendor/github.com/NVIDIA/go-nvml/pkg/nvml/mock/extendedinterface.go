// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/NVIDIA/go-nvml/pkg/nvml"
	"sync"
)

// Ensure, that ExtendedInterface does implement nvml.ExtendedInterface.
// If this is not the case, regenerate this file with moq.
var _ nvml.ExtendedInterface = &ExtendedInterface{}

// ExtendedInterface is a mock implementation of nvml.ExtendedInterface.
//
//	func TestSomethingThatUsesExtendedInterface(t *testing.T) {
//
//		// make and configure a mocked nvml.ExtendedInterface
//		mockedExtendedInterface := &ExtendedInterface{
//			LookupSymbolFunc: func(s string) error {
//				panic("mock out the LookupSymbol method")
//			},
//		}
//
//		// use mockedExtendedInterface in code that requires nvml.ExtendedInterface
//		// and then make assertions.
//
//	}
type ExtendedInterface struct {
	// LookupSymbolFunc mocks the LookupSymbol method.
	LookupSymbolFunc func(s string) error

	// calls tracks calls to the methods.
	calls struct {
		// LookupSymbol holds details about calls to the LookupSymbol method.
		LookupSymbol []struct {
			// S is the s argument value.
			S string
		}
	}
	lockLookupSymbol sync.RWMutex
}

// LookupSymbol calls LookupSymbolFunc.
func (mock *ExtendedInterface) LookupSymbol(s string) error {
	if mock.LookupSymbolFunc == nil {
		panic("ExtendedInterface.LookupSymbolFunc: method is nil but ExtendedInterface.LookupSymbol was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockLookupSymbol.Lock()
	mock.calls.LookupSymbol = append(mock.calls.LookupSymbol, callInfo)
	mock.lockLookupSymbol.Unlock()
	return mock.LookupSymbolFunc(s)
}

// LookupSymbolCalls gets all the calls that were made to LookupSymbol.
// Check the length with:
//
//	len(mockedExtendedInterface.LookupSymbolCalls())
func (mock *ExtendedInterface) LookupSymbolCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockLookupSymbol.RLock()
	calls = mock.calls.LookupSymbol
	mock.lockLookupSymbol.RUnlock()
	return calls
}
